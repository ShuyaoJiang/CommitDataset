[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import java.util.concurrent.ConcurrentHashMap;, +	private Map<ClassNode, JavaClass> classesMap = new ConcurrentHashMap<>();, +	private Map<MethodNode, JavaMethod> methodsMap = new ConcurrentHashMap<>();, +	private Map<FieldNode, JavaField> fieldsMap = new ConcurrentHashMap<>();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {, +				// cancel cast, +				return false;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {, +				// cancel cast, +				return false;, +			}, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java, +package jadx.tests.integration.invoke;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.anyOf;, +, +public class TestSuperInvokeWithGenerics extends IntegrationTest {, +, +	public static class TestCls {, +, +		public class A<T extends Exception, V> {, +			public A(T t) {, +				System.out.println("t" + t);, +			}, +, +			public A(V v) {, +				System.out.println("v" + v);, +			}, +		}, +, +		public class B extends A<Exception, String> {, +			public B(String s) {, +				super(s);, +			}, +, +			public B(Exception e) {, +				super(e);, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("super(e);"));, +		assertThat(code, containsOne("super(s);"));, +	}, +}]
[+++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +	protected boolean outputCFG = false;, +	protected String outDir = "test-out-tmp";, +, +			List<IDexTreeVisitor> passes = Jadx.getPassesList(new DefaultJadxArgs() {, +				@Override, +				public boolean isCFGOutput() {, +					return outputCFG;, +				}, +, +				@Override, +				public boolean isRawCFGOutput() {, +					return outputCFG;, +				}, +			}, new File(outDir));, +			fail("Class file not found: " + path);, +			fail("Class is not stored in a file.");, +			if (in != null) {, +}, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +	protected boolean outputCFG = false;, +	protected String outDir = "test-out-tmp";, +, +			List<IDexTreeVisitor> passes = Jadx.getPassesList(new DefaultJadxArgs() {, +				@Override, +				public boolean isCFGOutput() {, +					return outputCFG;, +				}, +, +				@Override, +				public boolean isRawCFGOutput() {, +					return outputCFG;, +				}, +			}, new File(outDir));, +			fail("Class file not found: " + path);, +			fail("Class is not stored in a file.");, +			if (in != null) {, +}, +++ b/jadx-core/src/test/resources/logback.xml, +<configuration>, +, +    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, +        <encoder>, +            <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +        </encoder>, +    </appender>, +, +    <root level="DEBUG">, +        <appender-ref ref="STDOUT"/>, +    </root>, +, +</configuration>]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, +			if (type instanceof ForLoop) {, +				ForLoop forLoop = (ForLoop) type;, +				makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, +				makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, +			if (type instanceof ForLoop) {, +				ForLoop forLoop = (ForLoop) type;, +				makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, +				makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static boolean isInstanceOf(ArgType type, ArgType of) {, +		if (type.equals(of)) {, +			return true;, +		}, +		if (!type.isObject() || !of.isObject()) {, +			return false;, +		}, +		return clsp.isImplements(type.getObject(), of.getObject());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, +			if (type instanceof ForLoop) {, +				ForLoop forLoop = (ForLoop) type;, +				makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, +				makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static boolean isInstanceOf(ArgType type, ArgType of) {, +		if (type.equals(of)) {, +			return true;, +		}, +		if (!type.isObject() || !of.isObject()) {, +			return false;, +		}, +		return clsp.isImplements(type.getObject(), of.getObject());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import java.util.List;, +, +public final class TernaryInsn extends InsnNode {, +	public void getRegisterArgs(List<RegisterArg> list) {, +		super.getRegisterArgs(list);, +		list.addAll(condition.getRegisterArgs());, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, +			if (type instanceof ForLoop) {, +				ForLoop forLoop = (ForLoop) type;, +				makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, +				makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static boolean isInstanceOf(ArgType type, ArgType of) {, +		if (type.equals(of)) {, +			return true;, +		}, +		if (!type.isObject() || !of.isObject()) {, +			return false;, +		}, +		return clsp.isImplements(type.getObject(), of.getObject());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import java.util.List;, +, +public final class TernaryInsn extends InsnNode {, +	public void getRegisterArgs(List<RegisterArg> list) {, +		super.getRegisterArgs(list);, +		list.addAll(condition.getRegisterArgs());, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +			compare.getInsn().getRegisterArgs(list);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, +			if (type instanceof ForLoop) {, +				ForLoop forLoop = (ForLoop) type;, +				makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, +				makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static boolean isInstanceOf(ArgType type, ArgType of) {, +		if (type.equals(of)) {, +			return true;, +		}, +		if (!type.isObject() || !of.isObject()) {, +			return false;, +		}, +		return clsp.isImplements(type.getObject(), of.getObject());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import java.util.List;, +, +public final class TernaryInsn extends InsnNode {]
[+++ b/.travis.yml, +        - $HOME/.gradle/caches/, +        - $HOME/.gradle/wrapper/, +, +before_cache:, +    - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// 'static' modifier not allowed for top classes (not inner), +		if (!cls.getClassInfo().isInner()) {, +			af = af.remove(AccessFlags.ACC_STATIC);, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// 'static' modifier not allowed for top classes (not inner), +		if (!cls.getClassInfo().isInner()) {, +			af = af.remove(AccessFlags.ACC_STATIC);, +		}, +, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.api.JadxInternalAccess;, +import jadx.tests.api.compiler.DynamicCompiler;, +import java.lang.reflect.Method;, +	protected boolean compile = true;, +	private DynamicCompiler dynamicCompiler;, +, +		compile(cls);, +	void compile(ClassNode cls) {, +		if (!compile) {, +			return;, +		}, +		try {, +			dynamicCompiler = new DynamicCompiler(cls);, +			boolean result = dynamicCompiler.compile();, +			assertTrue("Compilation failed on code: \n\n" + cls.getCode() + "\n", result);, +		} catch (Exception e) {, +			e.printStackTrace();, +			fail(e.getMessage());, +		}, +	}, +, +	public Object invoke(String method) throws Exception {, +		return invoke(method, new Class[0]);, +	}, +, +	public Object invoke(String method, Class[] types, Object... args) {, +		Method mth = getReflectMethod(method, types);, +		return invoke(mth, args);, +	}, +, +	public Method getReflectMethod(String method, Class... types) {, +		assertNotNull("dynamicCompiler not ready", dynamicCompiler);, +		try {, +			return dynamicCompiler.getMethod(method, types);, +		} catch (Exception e) {, +			e.printStackTrace();, +			fail(e.getMessage());, +		}, +		return null;, +	}, +, +	public Object invoke(Method mth, Object... args) {, +		assertNotNull("dynamicCompiler not ready", dynamicCompiler);, +		assertNotNull("unknown method", mth);, +		try {, +			return dynamicCompiler.invoke(mth, args);, +		} catch (Exception e) {, +			e.printStackTrace();, +			fail(e.getMessage());, +		}, +		return null;, +	}, +, +	// Try to make test class compilable, +	@Deprecated, +	public void disableCompilation() {, +		this.compile = false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// 'static' modifier not allowed for top classes (not inner), +		if (!cls.getClassInfo().isInner()) {, +			af = af.remove(AccessFlags.ACC_STATIC);, +		}, +, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.api.JadxInternalAccess;, +import jadx.tests.api.compiler.DynamicCompiler;, +import java.lang.reflect.Method;, +	protected boolean compile = true;, +	private DynamicCompiler dynamicCompiler;, +, +		compile(cls);, +	void compile(ClassNode cls) {, +		if (!compile) {, +			return;, +		}, +		try {, +			dynamicCompiler = new DynamicCompiler(cls);, +			boolean result = dynamicCompiler.compile();, +			assertTrue("Compilation failed on code: \n\n" + cls.getCode() + "\n", result);, +		} catch (Exception e) {, +			e.printStackTrace();, +			fail(e.getMessage());, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +		return fromIfNode((IfNode) header.getInstructions().get(0));, +	}, +, +	public static IfCondition fromIfNode(IfNode insn) {, +		return new IfCondition(new Compare(insn));, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +		return fromIfNode((IfNode) header.getInstructions().get(0));, +	}, +, +	public static IfCondition fromIfNode(IfNode insn) {, +		return new IfCondition(new Compare(insn));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.dex.instructions.args.RegisterArg;, +import static jadx.core.utils.BlockUtils.getBlockByOffset;, +import static jadx.core.utils.BlockUtils.isPathExists;, +import static jadx.core.utils.BlockUtils.selectOther;, +, +					if (isPathExists(loopExit, next)) {, +		BlockNode bThen = getBlockByOffset(ifnode.getTarget(), condBlock.getSuccessors());, +			BlockNode bElse = selectOther(bThen, condBlock.getSuccessors());, +			out = selectOther(loopBody, condBlock.getSuccessors());, +				boolean p = isPathExists(exitBlock, node);, +		BlockNode bThen = getBlockByOffset(ifnode.getTarget(), block.getSuccessors());, +		BlockNode bElse;, +		if (block.getSuccessors().size() == 1) {, +			// TODO eliminate useless 'if' instruction, +			bElse = bThen;, +		} else {, +			bElse = selectOther(bThen, block.getSuccessors());, +		}, +, +		BlockNode thenBlock = null;, +		for (BlockNode d : block.getDominatesOn()) {, +			if (d != bThen && d != bElse) {, +				out = d;, +				break;, +			}, +		}, +, +		IfRegion ifRegion = new IfRegion(currentRegion, block);, +		currentRegion.getSubBlocks().add(ifRegion);, +, +		// merge nested if nodes, +		boolean found;, +		do {, +			found = false;, +			for (BlockNode succ : block.getSuccessors()) {, +				BlockNode nestedIfBlock = getIfNode(succ);, +				if (nestedIfBlock != null && nestedIfBlock != block) {, +					IfNode nestedIfInsn = (IfNode) nestedIfBlock.getInstructions().get(0);, +					BlockNode nbThen = getBlockByOffset(nestedIfInsn.getTarget(), nestedIfBlock.getSuccessors());, +					BlockNode nbElse = selectOther(nbThen, nestedIfBlock.getSuccessors());, +, +					IfCondition condition;, +					boolean inverted = false;, +					if (isPathExists(bElse, nestedIfBlock)) {, +						// else branch, +						if (bThen != nbThen) {, +							if (bThen != nbElse) {, +								break; // not connected conditions, +							}, +							nestedIfInsn.invertOp(nbElse.getStartOffset());, +							inverted = true;, +						}, +						condition = IfCondition.or(ifRegion.getCondition(), IfCondition.fromIfNode(nestedIfInsn));, +					} else {, +						// then branch, +						if (bElse != nbElse) {, +							if (bElse != nbThen) {, +								break; // not connected conditions, +							}, +							nestedIfInsn.invertOp(nbElse.getStartOffset());, +							inverted = true;, +						}, +						condition = IfCondition.and(ifRegion.getCondition(), IfCondition.fromIfNode(nestedIfInsn));, +					}, +					ifRegion.setCondition(condition);, +					nestedIfBlock.getAttributes().add(AttributeFlag.SKIP);, +					// set new blocks, +					if (inverted) {, +						thenBlock = nbElse;, +						elseBlock = nbThen;, +					} else {, +						thenBlock = nbThen;, +						elseBlock = nbElse;, +					}, +					found = true;, +					block = nestedIfBlock;, +					bThen = thenBlock;, +					bElse = elseBlock;, +					break;, +				}, +			}, +		} while (found);, +, +		if (thenBlock == null) {, +			// invert condition (compiler often do it), +			ifnode.invertOp(bElse.getStartOffset());, +			BlockNode tmp = bThen;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, +		if (fieldNode != null) {, +			FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, +			if (replace != null) {, +				FieldInfo info = replace.getFieldInfo();, +				if (replace.isOuterClass()) {, +					code.add(useClass(info.getDeclClass())).add(".this");, +				}, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, +		if (fieldNode != null) {, +			FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, +			if (replace != null) {, +				FieldInfo info = replace.getFieldInfo();, +				if (replace.isOuterClass()) {, +					code.add(useClass(info.getDeclClass())).add(".this");, +				}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java, +	FIELD_REPLACE(true),, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, +		if (fieldNode != null) {, +			FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, +			if (replace != null) {, +				FieldInfo info = replace.getFieldInfo();, +				if (replace.isOuterClass()) {, +					code.add(useClass(info.getDeclClass())).add(".this");, +				}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java, +	FIELD_REPLACE(true),, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/FieldReplaceAttr.java, +package jadx.core.dex.attributes;, +, +import jadx.core.dex.info.FieldInfo;, +, +public class FieldReplaceAttr implements IAttribute {, +, +	private final FieldInfo fieldInfo;, +	private final boolean isOuterClass;, +, +	public FieldReplaceAttr(FieldInfo fieldInfo, boolean isOuterClass) {, +		this.fieldInfo = fieldInfo;, +		this.isOuterClass = isOuterClass;, +	}, +, +	public FieldInfo getFieldInfo() {, +		return fieldInfo;, +	}, +, +	public boolean isOuterClass() {, +		return isOuterClass;, +	}, +, +	@Override, +	public AttributeType getType() {, +		return AttributeType.FIELD_REPLACE;, +	}, +, +	@Override, +	public String toString() {, +		return "REPLACE: " + fieldInfo;, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, +		if (fieldNode != null) {, +			FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, +			if (replace != null) {, +				FieldInfo info = replace.getFieldInfo();, +				if (replace.isOuterClass()) {, +					code.add(useClass(info.getDeclClass())).add(".this");, +				}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java, +	FIELD_REPLACE(true),, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/FieldReplaceAttr.java, +package jadx.core.dex.attributes;, +, +import jadx.core.dex.info.FieldInfo;, +, +public class FieldReplaceAttr implements IAttribute {, +, +	private final FieldInfo fieldInfo;, +	private final boolean isOuterClass;, +, +	public FieldReplaceAttr(FieldInfo fieldInfo, boolean isOuterClass) {, +		this.fieldInfo = fieldInfo;, +		this.isOuterClass = isOuterClass;, +	}, +, +	public FieldInfo getFieldInfo() {, +		return fieldInfo;, +	}, +, +	public boolean isOuterClass() {, +		return isOuterClass;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Collections;, +import java.util.Comparator;, +		Map<BlockNode, BlockNode> fallThroughCases = new LinkedHashMap<BlockNode, BlockNode>();, +, +			BitSet df = s.getDomFrontier();, +			// fall through case block, +			if (df.cardinality() > 1) {, +				if (df.cardinality() > 2) {, +					LOG.debug("Unexpected case pattern, block: {}, mth: {}", s, mth);, +				} else {, +					BlockNode first = mth.getBasicBlocks().get(df.nextSetBit(0));, +					BlockNode second = mth.getBasicBlocks().get(df.nextSetBit(first.getId() + 1));, +					if (second.getDomFrontier().get(first.getId())) {, +						fallThroughCases.put(s, second);, +						df = new BitSet(df.size());, +						df.set(first.getId());, +					} else if (first.getDomFrontier().get(second.getId())) {, +						fallThroughCases.put(s, first);, +						df = new BitSet(df.size());, +						df.set(second.getId());, +					}, +				}, +			}, +			outs.or(df);, +		// check cases order if fall through case exists, +		if (!fallThroughCases.isEmpty()) {, +			if (isBadCasesOrder(blocksMap, fallThroughCases)) {, +				LOG.debug("Fixing incorrect switch cases order");, +				blocksMap = reOrderSwitchCases(blocksMap, fallThroughCases);, +				if (isBadCasesOrder(blocksMap, fallThroughCases)) {, +					LOG.error("Can't fix incorrect switch cases order, method: {}", mth);, +					mth.add(AFlag.INCONSISTENT_CODE);, +				}, +			}, +		}, +, +				outs.andNot(b.getDomFrontier());, +			BlockNode caseBlock = entry.getKey();, +			if (stack.containsExit(caseBlock)) {, +				BlockNode next = fallThroughCases.get(caseBlock);, +				stack.addExit(next);, +				Region caseRegion = makeRegion(caseBlock, stack);, +				stack.removeExit(next);, +				if (next != null) {, +					next.add(AFlag.FALL_THROUGH);, +					caseRegion.add(AFlag.FALL_THROUGH);, +				}, +				sw.addCase(entry.getValue(), caseRegion);, +				// 'break' instruction will be inserted in RegionMakerVisitor.PostRegionVisitor, +	private boolean isBadCasesOrder(final Map<BlockNode, List<Object>> blocksMap,, +			final Map<BlockNode, BlockNode> fallThroughCases) {, +		BlockNode nextCaseBlock = null;, +		for (BlockNode caseBlock : blocksMap.keySet()) {, +			if (nextCaseBlock != null && !caseBlock.equals(nextCaseBlock)) {, +				return true;, +			}, +			nextCaseBlock = fallThroughCases.get(caseBlock);, +		}, +		return nextCaseBlock != null;, +	}, +, +	private Map<BlockNode, List<Object>> reOrderSwitchCases(Map<BlockNode, List<Object>> blocksMap,, +			final Map<BlockNode, BlockNode> fallThroughCases) {, +		List<BlockNode> list = new ArrayList<BlockNode>(blocksMap.size());, +		list.addAll(blocksMap.keySet());, +		Collections.sort(list, new Comparator<BlockNode>() {, +			@Override, +			public int compare(BlockNode a, BlockNode b) {, +				BlockNode nextA = fallThroughCases.get(a);, +				if (nextA != null) {, +					if (b.equals(nextA)) {, +						return -1;, +					}, +				} else if (a.equals(fallThroughCases.get(b))) {, +					return 1;, +				}, +				return 0;, +			}, +		});, +, +		Map<BlockNode, List<Object>> newBlocksMap = new LinkedHashMap<BlockNode, List<Object>>(blocksMap.size());, +		for (BlockNode key : list) {, +			newBlocksMap.put(key, blocksMap.get(key));, +		}, +		return newBlocksMap;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Collections;, +import java.util.Comparator;]
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(new FallbackModeVisitor(), mth);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(new FallbackModeVisitor(), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +package jadx.core.dex.visitors;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.utils.ErrorsCounter;, +, +public class DepthTraversal {, +, +	public static void visit(IDexTreeVisitor visitor, ClassNode cls) {, +		try {, +			if (visitor.visit(cls)) {, +				for (ClassNode inCls : cls.getInnerClasses()) {, +					visit(visitor, inCls);, +				}, +				for (MethodNode mth : cls.getMethods()) {, +					visit(visitor, mth);, +				}, +			}, +		} catch (Throwable e) {, +			ErrorsCounter.classError(cls,, +					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);, +		}, +	}, +, +	public static void visit(IDexTreeVisitor visitor, MethodNode mth) {, +		try {, +			visitor.visit(mth);, +		} catch (Throwable e) {, +			ErrorsCounter.methodError(mth,, +					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);, +		}, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(new FallbackModeVisitor(), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +package jadx.core.dex.visitors;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.utils.ErrorsCounter;, +, +public class DepthTraversal {, +, +	public static void visit(IDexTreeVisitor visitor, ClassNode cls) {, +		try {, +			if (visitor.visit(cls)) {, +				for (ClassNode inCls : cls.getInnerClasses()) {, +					visit(visitor, inCls);, +				}, +				for (MethodNode mth : cls.getMethods()) {, +					visit(visitor, mth);, +				}, +			}, +		} catch (Throwable e) {, +			ErrorsCounter.classError(cls,, +					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);, +		}, +	}, +, +	public static void visit(IDexTreeVisitor visitor, MethodNode mth) {, +		try {, +			visitor.visit(mth);, +		} catch (Throwable e) {, +			ErrorsCounter.methodError(mth,, +					e.getClass().getSimpleName() + " in pass: " + visitor.getClass().getSimpleName(), e);, +		}, +	}, +}, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.visitors.DepthTraversal;, +				DepthTraversal.visit(new FallbackModeVisitor(), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +package jadx.core.dex.visitors;, +, +import jadx.core.dex.nodes.ClassNode;]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JCertificate.java, +package jadx.gui.treemodel;, +import jadx.api.ResourceFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.gui.utils.CertificateManager;, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.*;, +import java.io.*;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, +public class JCertificate extends JNode {, +, +	private static final ImageIcon CERTIFICATE_ICON = Utils.openIcon("certificate_obj");, +    private final transient ResourceFile rf;, +, +	public JCertificate(ResourceFile resFile) {, +        this.rf = resFile;, +	}, +, +	@Override, +	public JClass getJParent() {, +		return null;, +	}, +, +	@Override, +	public Icon getIcon() {, +		return CERTIFICATE_ICON;, +	}, +, +	@Override, +	public String makeString() {, +		return NLS.str("certificate.title");, +	}, +, +	@Override, +	public String getContent() {, +, +		try {, +			ResourceFile.ZipRef zipRef = rf.getZipRef();, +			if (zipRef == null) {, +				File file = new File(rf.getName());, +				try (InputStream inputStream = new BufferedInputStream(new FileInputStream(file))) {, +					return CertificateManager.decode(inputStream);, +				}, +			} else {, +				try (ZipFile zipFile = new ZipFile(zipRef.getZipFile())) {, +					ZipEntry entry = zipFile.getEntry(zipRef.getEntryName());, +					if (entry == null) {, +						throw new IOException("Zip entry not found: " + zipRef);, +					}, +					if (!ZipSecurity.isValidZipEntry(entry)) {, +						return null;, +					}, +					try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) {, +						return  CertificateManager.decode(inputStream);, +					}, +				}, +			}, +		} catch (Exception e) {, +			e.printStackTrace();, +		//	throw new JadxException("Error decode: " + rf.getName(), e);, +		}, +, +		return null;, +	}, +, +, +}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JCertificate.java, +package jadx.gui.treemodel;, +import jadx.api.ResourceFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.gui.utils.CertificateManager;, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.*;, +import java.io.*;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, +public class JCertificate extends JNode {, +, +	private static final ImageIcon CERTIFICATE_ICON = Utils.openIcon("certificate_obj");, +    private final transient ResourceFile rf;, +, +	public JCertificate(ResourceFile resFile) {, +        this.rf = resFile;, +	}, +, +	@Override, +	public JClass getJParent() {, +		return null;, +	}, +, +	@Override, +	public Icon getIcon() {, +		return CERTIFICATE_ICON;, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +, +			// process instructions from field init, +			FieldInitAttr fieldInitAttr = fieldNode.get(AType.FIELD_INIT);, +			if (fieldInitAttr != null && fieldInitAttr.getValueType() == FieldInitAttr.InitType.INSN) {, +				processInsn(dex, depList, fieldInitAttr.getInsn());, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +			super(ArgType.OBJECT.getObject());, +					&& bounds == ((WildcardType) obj).bounds, +					&& type.equals(((WildcardType) obj).type);, +			return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +			super(ArgType.OBJECT.getObject());, +					&& bounds == ((WildcardType) obj).bounds, +					&& type.equals(((WildcardType) obj).type);, +			return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +		end = sign.length();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +			super(ArgType.OBJECT.getObject());, +					&& bounds == ((WildcardType) obj).bounds, +					&& type.equals(((WildcardType) obj).type);, +			return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +		end = sign.length();, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +			e.printStackTrace();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +			super(ArgType.OBJECT.getObject());, +					&& bounds == ((WildcardType) obj).bounds, +					&& type.equals(((WildcardType) obj).type);, +			return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +		end = sign.length();, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +			e.printStackTrace();, +++ b/jadx-core/src/test/java/jadx/tests/internal/generics/TestGenerics3.java, +package jadx.tests.internal.generics;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.util.List;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestGenerics3 extends InternalJadxTest {, +, +	public static class TestCls {, +, +		public static void mthExtendsArray(List<? extends byte[]> list) {, +		}, +, +		public static void mthSuperArray(List<? super int[]> list) {, +		}, +, +		public static void mthSuperInteger(List<? super Integer> list) {, +		}, +, +		public static void mthExtendsString(List<? super String> list) {, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsString("mthExtendsArray(List<? extends byte[]> list)"));, +		assertThat(code, containsString("mthSuperArray(List<? super int[]> list)"));, +		assertThat(code, containsString("mthSuperInteger(List<? super Integer> list)"));, +		assertThat(code, containsString("mthExtendsString(List<? super String> list)"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, +		super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, +		this.callMth = callMth;, +		this.callType = callType;, +		this.instanceArg = instanceArg;, +	}, +, +	public CallType getCallType() {, +		return callType;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, +		super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, +		this.callMth = callMth;, +		this.callType = callType;, +		this.instanceArg = instanceArg;, +	}, +, +	public CallType getCallType() {, +		return callType;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.codegen.TypeGen;, +				ConstructorInsn replace = processConstructor(mth, co);, +				if (replace != null) {, +					replaceInsn(block, insnNumber, replace);, +				}, +	 * Replace call of synthetic constructor, +	 */, +	private static ConstructorInsn processConstructor(MethodNode mth, ConstructorInsn co) {, +		MethodNode callMth = mth.dex().resolveMethod(co.getCallMth());, +		if (callMth != null, +				&& callMth.getAccessFlags().isSynthetic(), +				&& allArgsNull(co)) {, +			// if all arguments is null => replace with default constructor, +			ClassNode classNode = mth.dex().resolveClass(callMth.getParentClass().getClassInfo());, +			boolean passThis = co.getArgsCount() >= 1 && co.getArg(0).isThis();, +			String ctrId = "<init>(" + (passThis ? TypeGen.signature(co.getArg(0).getType()) : "") + ")V";, +			MethodNode defCtr = classNode.searchMethodByName(ctrId);, +			if (defCtr != null) {, +				ConstructorInsn newInsn = new ConstructorInsn(defCtr.getMethodInfo(), co.getCallType(), co.getInstanceArg());, +				newInsn.setResult(co.getResult());, +				return newInsn;, +			}, +		}, +		return null;, +	}, +, +	private static boolean allArgsNull(InsnNode insn) {, +		for (InsnArg insnArg : insn.getArguments()) {, +			if (insnArg.isLiteral()) {, +				LiteralArg lit = (LiteralArg) insnArg;, +				if (lit.getLiteral() != 0) {, +					return false;, +				}, +			} else if (!insnArg.isThis()) {, +				return false;, +			}, +		}, +		return true;, +	}, +, +	/**, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, +		super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, +		this.callMth = callMth;, +		this.callType = callType;, +		this.instanceArg = instanceArg;, +	}, +, +	public CallType getCallType() {, +		return callType;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.codegen.TypeGen;, +				ConstructorInsn replace = processConstructor(mth, co);, +				if (replace != null) {, +					replaceInsn(block, insnNumber, replace);, +				}, +	 * Replace call of synthetic constructor, +	 */, +	private static ConstructorInsn processConstructor(MethodNode mth, ConstructorInsn co) {, +		MethodNode callMth = mth.dex().resolveMethod(co.getCallMth());, +		if (callMth != null, +				&& callMth.getAccessFlags().isSynthetic(), +				&& allArgsNull(co)) {, +			// if all arguments is null => replace with default constructor, +			ClassNode classNode = mth.dex().resolveClass(callMth.getParentClass().getClassInfo());, +			boolean passThis = co.getArgsCount() >= 1 && co.getArg(0).isThis();, +			String ctrId = "<init>(" + (passThis ? TypeGen.signature(co.getArg(0).getType()) : "") + ")V";, +			MethodNode defCtr = classNode.searchMethodByName(ctrId);, +			if (defCtr != null) {, +				ConstructorInsn newInsn = new ConstructorInsn(defCtr.getMethodInfo(), co.getCallType(), co.getInstanceArg());, +				newInsn.setResult(co.getResult());, +				return newInsn;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.DexNode;, +		String baseClass = useClassInternal(cls.getClassInfo(), classInfo);, +	private String useClassInternal(ClassInfo useCls, ClassInfo classInfo) {, +		if (parentGen != null) {, +			return parentGen.useClassInternal(useCls, classInfo);, +		}, +		if (fallback) {, +		}, +			if (isClassInnerFor(classInfo, useCls)) {, +			}, +			if (classInfo.getPackage().equals(useCls.getPackage()) && !classInfo.isInner()) {, +			}, +			if (classInfo.getPackage().equals(useCls.getPackage())) {, +				clsStr = classInfo.getNameWithoutPackage();, +			}, +			if (searchCollision(cls.dex(), useCls, shortName)) {, +				return clsStr;, +			}, +					if (cls.getShortName().equals(shortName)) {, +			}, +	private static boolean isClassInnerFor(ClassInfo inner, ClassInfo parent) {, +			return p.equals(parent) || isClassInnerFor(p, parent);, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, String shortName) {, +		if (useCls == null) {, +			return false;, +		}, +		if (useCls.getShortName().equals(shortName)) {, +			return true;, +		}, +		ClassNode classNode = dex.resolveClass(useCls);, +		for (ClassNode inner : classNode.getInnerClasses()) {, +			if (inner.getShortName().equals(shortName)) {, +				return true;, +			}, +		}, +		return searchCollision(dex, useCls.getParentClass(), shortName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.DexNode;, +		String baseClass = useClassInternal(cls.getClassInfo(), classInfo);, +	private String useClassInternal(ClassInfo useCls, ClassInfo classInfo) {, +		if (parentGen != null) {, +			return parentGen.useClassInternal(useCls, classInfo);, +		}, +		if (fallback) {, +		}, +			if (isClassInnerFor(classInfo, useCls)) {, +			}, +			if (classInfo.getPackage().equals(useCls.getPackage()) && !classInfo.isInner()) {, +			}, +			if (classInfo.getPackage().equals(useCls.getPackage())) {, +				clsStr = classInfo.getNameWithoutPackage();, +			}, +			if (searchCollision(cls.dex(), useCls, shortName)) {, +				return clsStr;, +			}, +					if (cls.getShortName().equals(shortName)) {, +			}, +	private static boolean isClassInnerFor(ClassInfo inner, ClassInfo parent) {, +			return p.equals(parent) || isClassInnerFor(p, parent);, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, String shortName) {, +		if (useCls == null) {, +			return false;, +		}, +		if (useCls.getShortName().equals(shortName)) {, +			return true;, +		}, +		ClassNode classNode = dex.resolveClass(useCls);, +		for (ClassNode inner : classNode.getInnerClasses()) {, +			if (inner.getShortName().equals(shortName)) {, +				return true;, +			}, +		}, +		return searchCollision(dex, useCls.getParentClass(), shortName);, +	}, +, +++ b/jadx-samples/src/main/java/jadx/samples/TestInnerNames.java, +package jadx.samples;, +, +public class TestInnerNames extends AbstractTest {, +, +	public int D;, +, +	public class A extends TestInner.MyThread {, +		public A(String name) {, +			super(name);, +		}, +	}, +, +	public class B extends A {, +		public B(String name) {, +			super(name);, +		}, +, +		public class C extends TestInner2.B {, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			code.add("/* anonymous class already generated */");, +			ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);, +			return;, +		}, +			InsnNode inlCopy = inl.copy();, +			inlCopy.getRegisterArgs(inlArgs);, +						inlCopy.replaceArg(r, repl);, +			makeInsn(inlCopy, code, Flags.BODY_ONLY);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			code.add("/* anonymous class already generated */");, +			ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);, +			return;, +		}, +			InsnNode inlCopy = inl.copy();, +			inlCopy.getRegisterArgs(inlArgs);, +						inlCopy.replaceArg(r, repl);, +			makeInsn(inlCopy, code, Flags.BODY_ONLY);, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +	public static String classError(ClassNode cls, String errorMsg) {, +		return classError(cls, errorMsg, null);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			code.add("/* anonymous class already generated */");, +			ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);, +			return;, +		}, +			InsnNode inlCopy = inl.copy();, +			inlCopy.getRegisterArgs(inlArgs);, +						inlCopy.replaceArg(r, repl);, +			makeInsn(inlCopy, code, Flags.BODY_ONLY);, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +	public static String classError(ClassNode cls, String errorMsg) {, +		return classError(cls, errorMsg, null);, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass12.java, +package jadx.tests.integration.inner;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestAnonymousClass12 extends IntegrationTest {, +, +	public static class TestCls {, +, +		public abstract static class BasicAbstract {, +			public abstract void doSomething();, +		}, +, +		private BasicAbstract outer;, +		private BasicAbstract inner;, +, +		public void test() {, +			outer = new BasicAbstract() {, +				@Override, +				public void doSomething() {, +					inner = new BasicAbstract() {, +						@Override, +						public void doSomething() {, +							inner = null;, +						}, +					};, +				}, +			};, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("outer = new BasicAbstract() {"));, +		assertThat(code, containsOne("inner = new BasicAbstract() {"));, +		assertThat(code, containsOne("inner = null;"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			code.add("/* anonymous class already generated */");, +			ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);, +			return;, +		}, +			InsnNode inlCopy = inl.copy();, +			inlCopy.getRegisterArgs(inlArgs);, +						inlCopy.replaceArg(r, repl);, +			makeInsn(inlCopy, code, Flags.BODY_ONLY);, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +	public static String classError(ClassNode cls, String errorMsg) {, +		return classError(cls, errorMsg, null);]
[+++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.file=文件, +menu.view=视图, +menu.recent_files=最近打开文件, +menu.no_recent_files=无最近打开文件, +menu.preferences=偏好, +menu.sync=同步, +menu.flatten=Show flatten packages, +menu.navigation=导航, +menu.text_search=搜索文字, +menu.class_search=搜索类, +menu.tools=工具, +menu.log=日志查看器, +menu.help=帮助, +menu.about=关于, +menu.update_label=发现新版本 %s !, +, +file.open=打开文件, +file.save_all=保存全部, +file.export_gradle=另存为 gradle project, +file.save_all_msg=选择反编译资源路径, +file.select=选择, +file.exit=退出, +, +tree.loading=稍等..., +, +search=搜索, +search.previous=预览, +search.next=下一个, +search.mark_all=标记全部, +search.regex=正则表达式, +search.match_case=区分大小写, +search.whole_word=整个词语, +search.find=查询, +, +tabs.close=关闭, +tabs.closeOthers=关闭其他, +tabs.closeAll=关闭全部, +, +nav.back=后退, +nav.forward=向前, +, +search_dialog.open=打开, +search_dialog.cancel=取消, +search_dialog.open_by_name=搜索文本\:, +search_dialog.search_in=Search definitions of \:, +search_dialog.class=类, +search_dialog.method=方法, +search_dialog.field=变量, +search_dialog.code=代码, +, +usage_dialog.title=使用搜索 , +usage_dialog.label=Usage for:, +, +preferences.title=偏好, +preferences.deobfuscation=Deobfuscation, +preferences.editor=编辑, +preferences.decompile=反编译, +preferences.other=其他, +preferences.check_for_updates=启动时检查更新, +preferences.fallback=Fallback mode (simple dump), +preferences.showInconsistentCode=显示不一致的代码, +preferences.escapeUnicode=Unicode转义, +preferences.replaceConsts=替换常量, +preferences.skipResourcesDecode=Don't decode resources, +preferences.threads=Processing threads count, +preferences.cfg=Generate methods CFG graphs (in 'dot' format), +preferences.raw_cfg=Generate RAW CFG graphs, +preferences.font=编辑器字体, +preferences.start_jobs=自动开启后台反编译, +preferences.select_font=选择, +preferences.deobfuscation_on=Enable deobfuscation, +preferences.deobfuscation_force=Force rewrite deobfuscation map file, +preferences.deobfuscation_min_len=最小命名长度, +preferences.deobfuscation_max_len=最大命名长度, +preferences.deobfuscation_source_alias=使用资源名作为类的别名, +preferences.save=保存, +preferences.cancel=取消, +preferences.reset=重置, +preferences.reset_message=恢复默认设置？, +preferences.reset_title=重置设置, +, +msg.open_file=请打开文件, +msg.saving_sources=保存资源, +log.level=日志等级:, +, +popup.undo=撤销, +popup.redo=重复上一次操作, +popup.cut=剪切, +popup.copy=复制, +popup.paste=粘贴, +popup.delete=删除, +popup.select_all=全选]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			makeClsAlias(cls);, +	public String getClsAlias(ClassNode cls) {, +		DeobfClsInfo deobfClsInfo = clsMap.get(cls.getClassInfo());, +		if (deobfClsInfo != null) {, +			return deobfClsInfo.getAlias();, +		}, +		return makeClsAlias(cls);, +	}, +, +		ClassInfo classInfo = cls.getClassInfo();, +		String clsName = classInfo.getShortName();, +		String alias = String.format("C%04d%s", clsIndex++, makeName(clsName));, +, +		PackageNode pkg = getPackageNode(classInfo.getPackage(), true);, +		clsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));, +		return alias;, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			makeClsAlias(cls);, +	public String getClsAlias(ClassNode cls) {, +		DeobfClsInfo deobfClsInfo = clsMap.get(cls.getClassInfo());, +		if (deobfClsInfo != null) {, +			return deobfClsInfo.getAlias();, +		}, +		return makeClsAlias(cls);, +	}, +, +		ClassInfo classInfo = cls.getClassInfo();, +		String clsName = classInfo.getShortName();, +		String alias = String.format("C%04d%s", clsIndex++, makeName(clsName));, +, +		PackageNode pkg = getPackageNode(classInfo.getPackage(), true);, +		clsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));, +		return alias;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import org.apache.commons.io.IOCase;, +, +	private static final boolean CASE_SENSITIVE_FS = IOCase.SYSTEM.isCaseSensitive();, +, +		checkClasses(root);, +	private void checkClasses(RootNode root) {, +		Set<String> clsNames = new HashSet<String>();, +		for (ClassNode cls : root.getClasses(true)) {, +			checkClassName(cls);, +			if (!CASE_SENSITIVE_FS) {, +				ClassInfo classInfo = cls.getClassInfo();, +				String clsFileName = classInfo.getAlias().getFullPath();, +				if (!clsNames.add(clsFileName.toLowerCase())) {, +					String newShortName = deobfuscator.getClsAlias(cls);, +					String newFullName = classInfo.makeFullClsName(newShortName, true);, +					classInfo.rename(cls.dex(), newFullName);, +					clsNames.add(classInfo.getAlias().getFullPath().toLowerCase());, +				}, +			}, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.isAnonymous() && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.isAnonymous() && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/LiveVarAnalysis.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.isAnonymous() && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/LiveVarAnalysis.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +	private static void process(MethodNode mth) {, +		int regsCount = mth.getRegsCount();, +		for (int i = 0; i < regsCount; i++) {, +	private static void placePhi(MethodNode mth, int regNum, LiveVarAnalysis la) {, +	private static void addPhi(BlockNode block, int regNum) {, +	private static void renameVariables(MethodNode mth) {, +	private static void renameVar(MethodNode mth, SSAVar[] vars, int[] vers, BlockNode block) {, +	private static void removeUselessPhi(MethodNode mth) {, +	private static void removePhiWithSameArgs(PhiInsn phi, List<PhiInsn> insnToRemove) {, +	private static void removePhiList(MethodNode mth, List<PhiInsn> insnToRemove) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java, +	public boolean noWrapWith(ArithOp other) {, +		return (this == ADD && other == ADD), +				|| (this == MUL && other == MUL), +				|| (this == AND && other == AND), +				|| (this == OR && other == OR);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java, +	public boolean noWrapWith(ArithOp other) {, +		return (this == ADD && other == ADD), +				|| (this == MUL && other == MUL), +				|| (this == AND && other == AND), +				|| (this == OR && other == OR);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.InsnType;, +, +		if (insn.getType() == InsnType.ARITH && parent.getType() == InsnType.ARITH, +				&& ((ArithNode) insn).getOp().noWrapWith(((ArithNode) parent).getOp())) {, +			insn.add(AFlag.DONT_WRAP);, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java, +	public boolean noWrapWith(ArithOp other) {, +		return (this == ADD && other == ADD), +				|| (this == MUL && other == MUL), +				|| (this == AND && other == AND), +				|| (this == OR && other == OR);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.InsnType;, +, +		if (insn.getType() == InsnType.ARITH && parent.getType() == InsnType.ARITH, +				&& ((ArithNode) insn).getOp().noWrapWith(((ArithNode) parent).getOp())) {, +			insn.add(AFlag.DONT_WRAP);, +		}, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java, +, +		public boolean test3(boolean a, boolean b, boolean c) {, +			return a | b | c;, +		}, +, +		public boolean test4(boolean a, boolean b, boolean c) {, +			return a & b & c;, +		}, +, +		public int substract(int a, int b, int c) {, +			return a - (b - c);, +		}, +, +		public int divide(int a, int b, int c) {, +			return a / (b / c);, +		}, +, +		assertThat(code, containsString("return a | b | c;"));, +		assertThat(code, not(containsString("return (a | b) | c;")));, +, +		assertThat(code, containsString("return a & b & c;"));, +		assertThat(code, not(containsString("return (a & b) & c;")));, +, +		assertThat(code, containsString("return a - (b - c);"));, +		assertThat(code, not(containsString("return a - b - c;")));, +, +		assertThat(code, containsString("return a / (b / c);"));, +		assertThat(code, not(containsString("return a / b / c;")));]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.utils.InstructionRemover;, +			InstructionRemover remover = new InstructionRemover(block.getInstructions());, +			for (InsnNode insn : block.getInstructions()) {, +					remover.add(insn);, +			remover.perform();, +		int assignCount = 0;, +				assignCount++;, +		return replaceCount == use.size() - assignCount;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.utils.InstructionRemover;, +			InstructionRemover remover = new InstructionRemover(block.getInstructions());, +			for (InsnNode insn : block.getInstructions()) {, +					remover.add(insn);, +			remover.perform();, +		int assignCount = 0;, +				assignCount++;, +		return replaceCount == use.size() - assignCount;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessReturnInsns.java, +import jadx.core.dex.regions.IfRegion;, +import jadx.core.dex.regions.SwitchRegion;, +			// ignore paths on other branches, +			if (region instanceof IfRegion, +					|| region instanceof SwitchRegion) {, +				curContainer = region;, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.utils.InstructionRemover;, +			InstructionRemover remover = new InstructionRemover(block.getInstructions());, +			for (InsnNode insn : block.getInstructions()) {, +					remover.add(insn);, +			remover.perform();, +		int assignCount = 0;, +				assignCount++;, +		return replaceCount == use.size() - assignCount;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessReturnInsns.java, +import jadx.core.dex.regions.IfRegion;, +import jadx.core.dex.regions.SwitchRegion;, +			// ignore paths on other branches, +			if (region instanceof IfRegion, +					|| region instanceof SwitchRegion) {, +				curContainer = region;, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (elseBlock != null && stack.containsExit(elseBlock)) {, +		IfInfo info = new IfInfo();, +		info.setIfnode(block);, +		info.setCondition(IfCondition.fromIfBlock(block));, +		info.setThenBlock(bThen);, +		info.setElseBlock(bElse);, +		return mergeNestedIfNodes(info, merged);, +	}, +, +	private IfInfo mergeNestedIfNodes(IfInfo info, List<BlockNode> merged) {, +		BlockNode bThen = info.getThenBlock();, +		BlockNode bElse = info.getElseBlock();, +		BlockNode ifBlock = info.getIfnode();, +		BlockNode nestedIfBlock = getNextIfBlock(ifBlock);, +		if (nestedIfBlock == null) {, +			return null;, +		}, +, +		IfCondition nestedCondition = IfCondition.fromIfNode(nestedIfInsn);, +		IfCondition condition = info.getCondition();, +					return null;, +					return null;, +		nestedIfBlock.getAttributes().add(AttributeFlag.SKIP);, +		BlockNode blockToNestedIfBlock = BlockUtils.getNextBlockToPath(ifBlock, nestedIfBlock);, +		skipSimplePath(BlockUtils.selectOther(blockToNestedIfBlock, ifBlock.getCleanSuccessors()));, +		IfInfo result = new IfInfo();, +		result.setCondition(condition);, +		// search next nested if block, +		IfInfo next = mergeNestedIfNodes(result, merged);, +		if (next != null) {, +			return next;, +	private BlockNode getNextIfBlock(BlockNode block) {, +		for (BlockNode succ : block.getSuccessors()) {, +			BlockNode nestedIfBlock = getIfNode(succ);, +			if (nestedIfBlock != null && nestedIfBlock != block) {, +				return nestedIfBlock;, +			}, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.utils.InstructionRemover;, +			InstructionRemover remover = new InstructionRemover(block.getInstructions());, +			for (InsnNode insn : block.getInstructions()) {, +					remover.add(insn);, +			remover.perform();, +		int assignCount = 0;, +				assignCount++;, +		return replaceCount == use.size() - assignCount;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessReturnInsns.java, +import jadx.core.dex.regions.IfRegion;, +import jadx.core.dex.regions.SwitchRegion;, +			// ignore paths on other branches]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AttributeType;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(RegisterArg.class);, +, +	public Object getConstValue(DexNode dex) {, +				case SGET:, +					FieldInfo f = (FieldInfo) ((IndexInsnNode) parInsn).getIndex();, +					FieldNode fieldNode = dex.resolveField(f);, +					if (fieldNode != null) {, +						FieldValueAttr attr = (FieldValueAttr) fieldNode.getAttributes().get(AttributeType.FIELD_VALUE);, +						if (attr != null) {, +							return attr.getValue();, +						}, +					} else {, +						LOG.warn("Field {} not found in dex {}", f, dex);, +					}, +					break;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AttributeType;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(RegisterArg.class);, +, +	public Object getConstValue(DexNode dex) {, +				case SGET:, +					FieldInfo f = (FieldInfo) ((IndexInsnNode) parInsn).getIndex();, +					FieldNode fieldNode = dex.resolveField(f);, +					if (fieldNode != null) {, +						FieldValueAttr attr = (FieldValueAttr) fieldNode.getAttributes().get(AttributeType.FIELD_VALUE);, +						if (attr != null) {, +							return attr.getValue();, +						}, +					} else {, +						LOG.warn("Field {} not found in dex {}", f, dex);, +					}, +					break;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import jadx.core.dex.info.FieldInfo;, +	public FieldNode resolveField(FieldInfo field) {, +		ClassNode cls = resolveClass(field.getDeclClass());, +		if (cls != null) {, +			return cls.searchField(field);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AttributeType;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(RegisterArg.class);, +, +	public Object getConstValue(DexNode dex) {, +				case SGET:, +					FieldInfo f = (FieldInfo) ((IndexInsnNode) parInsn).getIndex();, +					FieldNode fieldNode = dex.resolveField(f);, +					if (fieldNode != null) {, +						FieldValueAttr attr = (FieldValueAttr) fieldNode.getAttributes().get(AttributeType.FIELD_VALUE);, +						if (attr != null) {, +							return attr.getValue();, +						}, +					} else {, +						LOG.warn("Field {} not found in dex {}", f, dex);, +					}, +					break;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import jadx.core.dex.info.FieldInfo;, +	public FieldNode resolveField(FieldInfo field) {, +		ClassNode cls = resolveClass(field.getDeclClass());, +		if (cls != null) {, +			return cls.searchField(field);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +				String name = (String) nameArg.getConstValue(cls.dex());, +				if (name == null) {, +					throw new JadxException("Unknown enum field name: " + cls);, +				}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +		DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +		DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor) {, +	public static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {, +			repeat = traverseIterativeInternal(mth, visitor, mth.getRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +		DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor) {, +	public static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {, +			repeat = traverseIterativeInternal(mth, visitor, mth.getRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +	private static final TernaryVisitor TERNARY_VISITOR = new TernaryVisitor();, +, +		DepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);, +		DepthRegionTraversal.traverse(mth, this);, +		DepthRegionTraversal.traverseIterative(mth, this);, +	}, +, +	private static class TernaryVisitor implements IRegionIterativeVisitor {, +			return region instanceof IfRegion, +					&& TernaryMod.makeTernaryInsn(mth, (IfRegion) region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +		DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor) {, +	public static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {, +			repeat = traverseIterativeInternal(mth, visitor, mth.getRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +	private static final TernaryVisitor TERNARY_VISITOR = new TernaryVisitor();, +, +		DepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);, +		DepthRegionTraversal.traverse(mth, this);, +		DepthRegionTraversal.traverseIterative(mth, this);, +	}, +, +	private static class TernaryVisitor implements IRegionIterativeVisitor {, +			return region instanceof IfRegion, +					&& TernaryMod.makeTernaryInsn(mth, (IfRegion) region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		DepthRegionTraversal.traverse(mth, this);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +		DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor) {, +	public static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {, +			repeat = traverseIterativeInternal(mth, visitor, mth.getRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +	private static final TernaryVisitor TERNARY_VISITOR = new TernaryVisitor();, +, +		DepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);, +		DepthRegionTraversal.traverse(mth, this);, +		DepthRegionTraversal.traverseIterative(mth, this);, +	}, +, +	private static class TernaryVisitor implements IRegionIterativeVisitor {, +			return region instanceof IfRegion, +					&& TernaryMod.makeTernaryInsn(mth, (IfRegion) region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		DepthRegionTraversal.traverse(mth, this);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +			DepthRegionTraversal.traverseIncludingExcHandlers(mth, new AbstractRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +		DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor) {, +	public static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {, +			repeat = traverseIterativeInternal(mth, visitor, mth.getRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +	private static final TernaryVisitor TERNARY_VISITOR = new TernaryVisitor();, +, +		DepthRegionTraversal.traverseIterative(mth, TERNARY_VISITOR);, +		DepthRegionTraversal.traverse(mth, this);, +		DepthRegionTraversal.traverseIterative(mth, this);, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		if (body != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		if (body != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +			if (BlockUtils.checkLastInsnType(block, InsnType.RETURN)) {, +				if (!edges.isEmpty()) {, +		return splitReturn(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		if (body != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +			if (BlockUtils.checkLastInsnType(block, InsnType.RETURN)) {, +				if (!edges.isEmpty()) {, +		return splitReturn(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.dex.nodes.MethodNode;, +import java.util.Collection;, +import java.util.Set;, +, +		IfNode ifNode = (IfNode) ifBlock.getInstructions().get(0);, +		IfCondition condition = IfCondition.fromIfNode(ifNode);, +		IfInfo info = new IfInfo(condition, ifNode.getThenBlock(), ifNode.getElseBlock());, +		info.setIfBlock(ifBlock);, +		info.getMergedBlocks().add(ifBlock);, +		return info;, +	static IfInfo restructureIf(MethodNode mth, BlockNode block, IfInfo info) {, +		final BlockNode thenBlock = info.getThenBlock();, +		final BlockNode elseBlock = info.getElseBlock();, +, +		// select 'then', 'else' and 'exit' blocks, +		if (thenBlock.contains(AFlag.RETURN) && elseBlock.contains(AFlag.RETURN)) {, +			info.setOutBlock(null);, +			return info;, +		}, +		boolean badThen = !allPathsFromIf(thenBlock, info);, +		boolean badElse = !allPathsFromIf(elseBlock, info);, +		if (badThen && badElse) {, +			return null;, +		}, +		if (badThen || badElse) {, +			if (badElse && isPathExists(thenBlock, elseBlock)) {, +				info = new IfInfo(info.getCondition(), thenBlock, null);, +				info.setOutBlock(elseBlock);, +			} else if (badThen && isPathExists(elseBlock, thenBlock)) {, +				info = IfInfo.invert(info);, +				info = new IfInfo(info.getCondition(), info.getThenBlock(), null);, +				info.setOutBlock(thenBlock);, +			} else if (badElse) {, +				info = new IfInfo(info.getCondition(), thenBlock, null);, +				info.setOutBlock(null);, +			} else {, +				info = IfInfo.invert(info);, +				info = new IfInfo(info.getCondition(), info.getThenBlock(), null);, +				info.setOutBlock(null);, +			}, +		} else {, +			List<BlockNode> thenSC = thenBlock.getCleanSuccessors();]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java, +		if (getProjectPath() != null) {, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +		currentTag = deobfClassName(getString(startNSName));, +		currentTag = getValidTagAttributeName(currentTag);, +		String elemName = deobfClassName(getString(elementNameId));, +		elemName = getValidTagAttributeName(elemName);]
[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	public boolean isSet() {, +		return line != 0 || offset != 0;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	public boolean isSet() {, +		return line != 0 || offset != 0;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		classGen.useType(code, a.getType());, +				classGen.useType(code, ex);, +			classGen.useType(code, (ArgType) val);, +			code.add(".class");, +			InsnGen.makeStaticFieldAccess(code, field, classGen);, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	public boolean isSet() {, +		return line != 0 || offset != 0;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		classGen.useType(code, a.getType());, +				classGen.useType(code, ex);, +			classGen.useType(code, (ArgType) val);, +			code.add(".class");, +			InsnGen.makeStaticFieldAccess(code, field, classGen);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +			clsCode.add("extends ");, +			useClass(clsCode, sup);, +			clsCode.add(' ');, +				useClass(clsCode, interf);, +			if (type.isGenericType()) {, +				code.add(type.getObject());, +			} else {, +				useClass(code, ClassInfo.fromType(type));, +			}, +					if (g.isGenericType()) {, +						code.add(g.getObject());, +					} else {, +						useClass(code, ClassInfo.fromType(g));, +					}, +			useType(code, f.getType());, +		if (enumFields == null) {, +			return;, +		}, +, +	public void useType(CodeWriter code, ArgType type) {, +		final PrimitiveType stype = type.getPrimitiveType();, +		if (stype == null) {, +			code.add(type.toString());, +		} else if (stype == PrimitiveType.OBJECT) {, +			if (type.isGenericType()) {, +				code.add(type.getObject());, +			} else {, +				useClass(code, ClassInfo.fromType(type));, +			}, +		} else if (stype == PrimitiveType.ARRAY) {, +			useType(code, type.getArrayElement());, +			code.add("[]");, +		} else {, +			code.add(stype.getLongName());, +		}, +	public void useClass(CodeWriter code, ClassInfo classInfo) {, +		ClassNode classNode = cls.dex().resolveClass(classInfo);, +		if (classNode != null) {, +			code.attachAnnotation(classNode);, +		ArgType[] generics = classInfo.getType().getGenericTypes();, +		code.add(baseClass);, +		if (generics != null) {, +			code.add('<');, +					code.add(", ");, +					code.add('?');, +						code.add(bounds == -1 ? " super " : " extends ");, +						useType(code, wt);, +					useType(code, gt);, +			code.add('>');, +		}, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	public boolean isSet() {, +		return line != 0 || offset != 0;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		classGen.useType(code, a.getType());, +				classGen.useType(code, ex);, +			classGen.useType(code, (ArgType) val);, +			code.add(".class");, +			InsnGen.makeStaticFieldAccess(code, field, classGen);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +			clsCode.add("extends ");, +			useClass(clsCode, sup);, +			clsCode.add(' ');, +				useClass(clsCode, interf);, +			if (type.isGenericType()) {, +				code.add(type.getObject());, +			} else {, +				useClass(code, ClassInfo.fromType(type));]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public boolean isNameEquals(InsnArg arg) {, +		if (name == null || !(arg instanceof Named)) {, +			return false;, +		}, +		return name.equals(((Named) arg).getName());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public boolean isNameEquals(InsnArg arg) {, +		if (name == null || !(arg instanceof Named)) {, +			return false;, +		}, +		return name.equals(((Named) arg).getName());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	public int getUseCount() {, +		return useList.size();, +	}, +, +		return useList.size() + usedInPhi.getResult().getSVar().getUseCount();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public boolean isNameEquals(InsnArg arg) {, +		if (name == null || !(arg instanceof Named)) {, +			return false;, +		}, +		return name.equals(((Named) arg).getName());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	public int getUseCount() {, +		return useList.size();, +	}, +, +		return useList.size() + usedInPhi.getResult().getSVar().getUseCount();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +	public void load() {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public boolean isNameEquals(InsnArg arg) {, +		if (name == null || !(arg instanceof Named)) {, +			return false;, +		}, +		return name.equals(((Named) arg).getName());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	public int getUseCount() {, +		return useList.size();, +	}, +, +		return useList.size() + usedInPhi.getResult().getSVar().getUseCount();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +	public void load() {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public Iterable<ExceptionHandler> getExceptionHandlers() {, +		return exceptionHandlers;, +	}, +, +	public boolean isNoExceptionHandlers() {, +		return exceptionHandlers.isEmpty();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public static JadxSettings makeDefault() {, +		JadxSettings jadxSettings = new JadxSettings();, +		jadxSettings.fixOnLoad();, +		return jadxSettings;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public static JadxSettings makeDefault() {, +		JadxSettings jadxSettings = new JadxSettings();, +		jadxSettings.fixOnLoad();, +		return jadxSettings;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +				settings = JadxSettings.makeDefault();, +			} else {, +			}, +			if (LOG.isDebugEnabled()) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public static JadxSettings makeDefault() {, +		JadxSettings jadxSettings = new JadxSettings();, +		jadxSettings.fixOnLoad();, +		return jadxSettings;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +				settings = JadxSettings.makeDefault();, +			} else {, +			}, +			if (LOG.isDebugEnabled()) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import jadx.gui.ui.codearea.EditorTheme;, +				String defaults = JadxSettingsAdapter.makeString(JadxSettings.makeDefault());]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, +		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, +	private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, +			return;, +		if (!af.isSynthetic()) {, +			return;, +		}, +		if (removeBridgeMethod(cls, mth)) {, +			return;, +		}, +		if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, +		List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, +		if (allInsns.size() == 1) {, +			InsnNode wrappedInsn = allInsns.get(0);, +			if (wrappedInsn.getType() == InsnType.RETURN) {, +				InsnArg arg = wrappedInsn.getArg(0);, +				if (arg.isInsnWrap()) {, +					wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, +				}, +			}, +			if (checkSyntheticWrapper(mth, wrappedInsn)) {, +				return true;, +			}, +		}, +		return !isMethodUnique(cls, mth);, +	}, +, +	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.INVOKE) {, +			MethodInfo callMth = ((InvokeNode) insn).getCallMth();, +			MethodNode wrappedMth = mth.root().deepResolveMethod(callMth);, +			if (wrappedMth != null) {, +				String alias = mth.getAlias();, +				if (!wrappedMth.getAlias().equals(alias) && wrappedMth.isVirtual()) {, +					wrappedMth.getMethodInfo().setAlias(alias);, +				}, +				return true;, +			}, +		}, +		return false;, +	}, +, +	private static boolean isMethodUnique(ClassNode cls, MethodNode mth) {, +	private static void removeEmptyMethods(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, +		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, +	private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, +			return;, +		if (!af.isSynthetic()) {, +			return;, +		}, +		if (removeBridgeMethod(cls, mth)) {, +			return;, +		}, +		if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, +		List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, +		if (allInsns.size() == 1) {, +			InsnNode wrappedInsn = allInsns.get(0);, +			if (wrappedInsn.getType() == InsnType.RETURN) {, +				InsnArg arg = wrappedInsn.getArg(0);, +				if (arg.isInsnWrap()) {, +					wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, +				}, +			}, +			if (checkSyntheticWrapper(mth, wrappedInsn)) {, +				return true;, +			}, +		}, +		return !isMethodUnique(cls, mth);, +	}, +, +	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.INVOKE) {, +			MethodInfo callMth = ((InvokeNode) insn).getCallMth();, +			MethodNode wrappedMth = mth.root().deepResolveMethod(callMth);, +			if (wrappedMth != null) {, +				String alias = mth.getAlias();, +				if (!wrappedMth.getAlias().equals(alias) && wrappedMth.isVirtual()) {, +					wrappedMth.getMethodInfo().setAlias(alias);, +				}, +				return true;, +			}, +		}, +		return false;, +	}, +, +	private static boolean isMethodUnique(ClassNode cls, MethodNode mth) {, +	private static void removeEmptyMethods(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +]
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/README.md, +, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, +	public static String bytesToHex(byte[] bytes) {, +		char[] hexArray = "0123456789abcdef".toCharArray();, +		if (bytes == null || bytes.length <= 0) {, +			return null;, +		}, +		char[] hexChars = new char[bytes.length * 2];, +		for ( int j = 0; j < bytes.length; j++ ) {, +			int v = bytes[j] & 0xFF;, +			hexChars[j * 2] = hexArray[v >>> 4];, +			hexChars[j * 2 + 1] = hexArray[v & 0x0F];, +		}, +		return new String(hexChars);, +	}, +, +	public static boolean isZipfile(File file) {, +		boolean isZipfile = false;, +		InputStream is = null;, +		try {, +			byte[] headers = new byte[4];, +			is = new FileInputStream(file);, +			is.read(headers, 0, 4);, +			System.out.println(bytesToHex(headers));, +			String headerString = bytesToHex(headers);, +			if (headerString.equals("504b0304")) {, +				isZipfile = true;, +			}, +		} catch (Exception e) {, +			e.printStackTrace();, +		} finally {, +			if (is != null) {, +				try {, +					is.close();, +				} catch (IOException e) {, +					e.printStackTrace();, +				}, +			}, +		}, +, +		return isZipfile;, +	}, +, +	public static List<String> getZipfileList(File file) {, +		List<String> filelist = new ArrayList<String>();, +		ZipFile zipFile = null;, +		try {, +			zipFile = new ZipFile(file);, +			Enumeration<? extends ZipEntry> entries = zipFile.entries();, +, +			while(entries.hasMoreElements()){, +				ZipEntry entry = entries.nextElement();, +				filelist.add(entry.getName());, +				System.out.println(entry.getName());, +			}, +		} catch (IOException e) {, +			e.printStackTrace();, +			System.out.println(e.getMessage());, +		}, +, +		return filelist;, +	}, +, +	public static boolean isApkfile(File file) {, +		boolean isApkfile = false;, +		if (isZipfile(file)) {, +			List<String> filelist = getZipfileList(file);, +			if (filelist.contains("AndroidManifest.xml") && filelist.contains("classes.dex")) {, +				isApkfile = true;, +			}, +		}, +		return isApkfile;, +	}, +, +	public static boolean isZipDexfile(File file) {, +		boolean isZipDexFile = false;, +		if (isZipfile(file)) {, +			List<String> filelist = getZipfileList(file);, +			if (filelist.contains("classes.dex")) {, +				isZipDexFile = true;, +			}, +		}, +, +		return isZipDexFile;, +	}, +++ b/.DS_Store, +++ b/README.md, +]
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java, +		if (currentPos >= 0 && currentPos < list.size()) {, +		int size = list.size();, +		if (size == 0) {, +			currentPos = 0;, +			return null;, +		}, +		if (newPos >= size) {, +			currentPos = size - 1;, +++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java, +		if (currentPos >= 0 && currentPos < list.size()) {, +		int size = list.size();, +		if (size == 0) {, +			currentPos = 0;, +			return null;, +		}, +		if (newPos >= size) {, +			currentPos = size - 1;, +++ b/jadx-gui/src/test/groovy/jadx/gui/tests/TestJumpManager.groovy, +    def "empty history 2"() {, +        expect:, +        jm.getPrev() == null, +        jm.getNext() == null, +        jm.getPrev() == null, +        jm.getNext() == null, +        jm.getPrev() == null, +    }, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		int result = 0;, +				result = processAndSave(jadxArgs);, +			result = 1;, +		} finally {, +			System.exit(result);, +	static int processAndSave(JadxCLIArgs inputArgs) {, +			return 1;, +		int errorsCount = jadx.getErrorsCount();, +		if (errorsCount != 0) {, +		return errorsCount;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		int result = 0;, +				result = processAndSave(jadxArgs);, +			result = 1;, +		} finally {, +			System.exit(result);, +	static int processAndSave(JadxCLIArgs inputArgs) {, +			return 1;, +		int errorsCount = jadx.getErrorsCount();, +		if (errorsCount != 0) {, +		return errorsCount;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public int getWarnsCount() {, +		if (root == null) {, +			return 0;, +		}, +		return root.getErrorsCounter().getWarnsCount();, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		int result = 0;, +				result = processAndSave(jadxArgs);, +			result = 1;, +		} finally {, +			System.exit(result);, +	static int processAndSave(JadxCLIArgs inputArgs) {, +			return 1;, +		int errorsCount = jadx.getErrorsCount();, +		if (errorsCount != 0) {, +		return errorsCount;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public int getWarnsCount() {, +		if (root == null) {, +			return 0;, +		}, +		return root.getErrorsCounter().getWarnsCount();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.attributes.nodes.JadxError;, +import jadx.core.dex.attributes.nodes.JadxWarn;, +			int savedIndent = code.getIndent();, +				code.setIndent(savedIndent);, +			insertDecompilationProblems(code, mth);, +					code.startLine("/* Code decompiled incorrectly, please refer to instructions dump. */");, +	private void insertDecompilationProblems(CodeWriter code, MethodNode mth) {, +		List<JadxError> errors = mth.getAll(AType.JADX_ERROR);, +		List<JadxWarn> warns = mth.getAll(AType.JADX_WARN);, +		if (!errors.isEmpty()) {, +			errors.forEach(err -> {, +				code.startLine("/*  JADX ERROR: ").add(err.getError());, +				Throwable cause = err.getCause();, +				if (cause != null) {, +					code.incIndent();, +					Utils.appendStackTrace(code, cause);, +					code.decIndent();, +				}, +				code.add("*/");, +			});, +		}, +		if (!warns.isEmpty()) {, +			warns.forEach(warn -> code.startLine("/* JADX WARNING: ").add(warn.getWarn()).add(" */"));, +		}, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		int result = 0;, +				result = processAndSave(jadxArgs);, +			result = 1;, +		} finally {, +			System.exit(result);, +	static int processAndSave(JadxCLIArgs inputArgs) {, +			return 1;, +		int errorsCount = jadx.getErrorsCount();, +		if (errorsCount != 0) {, +		return errorsCount;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public int getWarnsCount() {, +		if (root == null) {, +			return 0;, +		}, +		return root.getErrorsCounter().getWarnsCount();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.attributes.nodes.JadxError;, +import jadx.core.dex.attributes.nodes.JadxWarn;, +			int savedIndent = code.getIndent();, +				code.setIndent(savedIndent);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, +	private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, +	private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int argsCount = list.size();, +			for (int i = 0; i < argsCount; i++) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode, +							+ ", expected to be less than " + regsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, +	private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int argsCount = list.size();, +			for (int i = 0; i < argsCount; i++) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode, +							+ ", expected to be less than " + regsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +			ArgType argType = arg.getType();, +			if (argType.isObject() && literal != 0) {, +				argType = ArgType.NARROW_NUMBERS;, +			}, +				litArg = InsnArg.lit(literal, argType);, +				litArg = InsnArg.lit(literal, argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, +	private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int argsCount = list.size();, +			for (int i = 0; i < argsCount; i++) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode, +							+ ", expected to be less than " + regsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +			ArgType argType = arg.getType();, +			if (argType.isObject() && literal != 0) {, +				argType = ArgType.NARROW_NUMBERS;, +			}, +				litArg = InsnArg.lit(literal, argType);, +				litArg = InsnArg.lit(literal, argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (excHandlerAttr == null) {, +			LOG.warn("Missing exception handler attribute for start block");, +		} else {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, +	private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int argsCount = list.size();, +			for (int i = 0; i < argsCount; i++) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode, +							+ ", expected to be less than " + regsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +			ArgType argType = arg.getType();, +			if (argType.isObject() && literal != 0) {, +				argType = ArgType.NARROW_NUMBERS;, +			}, +				litArg = InsnArg.lit(literal, argType);, +				litArg = InsnArg.lit(literal, argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (excHandlerAttr == null) {, +			LOG.warn("Missing exception handler attribute for start block");, +		} else {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java, +				ArgType resultType = result.getType();, +				boolean skip = castType.isObject() && resultType.isObject(), +						&& castType.getObject().equals(resultType.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, +	private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int argsCount = list.size();, +			for (int i = 0; i < argsCount; i++) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode, +							+ ", expected to be less than " + regsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +			ArgType argType = arg.getType();, +			if (argType.isObject() && literal != 0) {, +				argType = ArgType.NARROW_NUMBERS;, +			}, +				litArg = InsnArg.lit(literal, argType);, +				litArg = InsnArg.lit(literal, argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (excHandlerAttr == null) {, +			LOG.warn("Missing exception handler attribute for start block");, +		} else {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java, +				ArgType resultType = result.getType();, +				boolean skip = castType.isObject() && resultType.isObject(), +						&& castType.getObject().equals(resultType.getObject());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +			"files", "input", "outputDir", "verbose", "printHelp"]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, +			Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, +			Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +		for (Class<?> type : types) {, +	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, +			Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +		for (Class<?> type : types) {, +	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java, +		List<Class<?>> classList = new ArrayList<Class<?>>(passes.size());, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, +			Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +		for (Class<?> type : types) {, +	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java, +		List<Class<?>> classList = new ArrayList<Class<?>>(passes.size());, +++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java, +		private static final HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>, +				mCreators = new HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>();, +				HashMap<String, Parcelable.Creator<?>> map = mCreators.get(loader);, +					map = new HashMap<String, Parcelable.Creator<?>>();, +				creator = (Parcelable.Creator<T>) map.get(name);, +						Class<?> c = loader == null ?, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, +			Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +		for (Class<?> type : types) {, +	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java, +		List<Class<?>> classList = new ArrayList<Class<?>>(passes.size());, +++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java, +		private static final HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>, +				mCreators = new HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>();, +				HashMap<String, Parcelable.Creator<?>> map = mCreators.get(loader);, +					map = new HashMap<String, Parcelable.Creator<?>>();, +				creator = (Parcelable.Creator<T>) map.get(name);, +						Class<?> c = loader == null ?, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, +			Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +		for (Class<?> type : types) {, +	private Class<?> checkType(Class<?> type) throws ClassNotFoundException {, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxVisitorsOrderTest.java, +		List<Class<?>> classList = new ArrayList<Class<?>>(passes.size());, +++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestIssue13a.java, +		private static final HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>, +				mCreators = new HashMap<ClassLoader, HashMap<String, Parcelable.Creator<?>>>();, +				HashMap<String, Parcelable.Creator<?>> map = mCreators.get(loader);, +					map = new HashMap<String, Parcelable.Creator<?>>();, +				creator = (Parcelable.Creator<T>) map.get(name);, +						Class<?> c = loader == null ?, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +		@SuppressWarnings("unchecked")]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, +			passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, +			passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (!els.contains(AFlag.ELSE_IF_CHAIN)) {, +			return false;, +		}, +		if (!(els instanceof Region)) {, +			return false;, +		}, +		List<IContainer> subBlocks = ((Region) els).getSubBlocks();, +		if (subBlocks.size() == 1, +				&& subBlocks.get(0) instanceof IfRegion) {, +			makeIf((IfRegion) subBlocks.get(0), code, false);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, +			passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (!els.contains(AFlag.ELSE_IF_CHAIN)) {, +			return false;, +		}, +		if (!(els instanceof Region)) {, +			return false;, +		}, +		List<IContainer> subBlocks = ((Region) els).getSubBlocks();, +		if (subBlocks.size() == 1, +				&& subBlocks.get(0) instanceof IfRegion) {, +			makeIf((IfRegion) subBlocks.get(0), code, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +	public String baseString() {, +		return Integer.toString(id);, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, +			passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (!els.contains(AFlag.ELSE_IF_CHAIN)) {, +			return false;, +		}, +		if (!(els instanceof Region)) {, +			return false;, +		}, +		List<IContainer> subBlocks = ((Region) els).getSubBlocks();, +		if (subBlocks.size() == 1, +				&& subBlocks.get(0) instanceof IfRegion) {, +			makeIf((IfRegion) subBlocks.get(0), code, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +	public String baseString() {, +		return Integer.toString(id);, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IContainer.java, +, +	// unique id for use in 'toString()' method, +	String baseString();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, +			passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (!els.contains(AFlag.ELSE_IF_CHAIN)) {, +			return false;, +		}, +		if (!(els instanceof Region)) {, +			return false;, +		}, +		List<IContainer> subBlocks = ((Region) els).getSubBlocks();, +		if (subBlocks.size() == 1, +				&& subBlocks.get(0) instanceof IfRegion) {, +			makeIf((IfRegion) subBlocks.get(0), code, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +	public String baseString() {, +		return Integer.toString(id);, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IContainer.java, +, +	// unique id for use in 'toString()' method, +	String baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java, +	@Override, +	public String baseString() {, +		return Integer.toString(insns.size());, +	}, +, +	@Override, +	public String toString() {, +		return "InsnContainer:" + insns.size();, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, +			passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (!els.contains(AFlag.ELSE_IF_CHAIN)) {]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		if (methodInfo.isClassInit() || methodInfo.isConstructor()) {, +			return null;, +		}]
[+++ b/build.gradle, +apply plugin: 'java', +apply plugin: 'application', +, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +sourceCompatibility = 1.6, +targetCompatibility = 1.6, +, +version = 'dev', +, +mainClassName = "jadx.Main", +, +project.ext {, +    mainSamplesClass = "jadx.samples.RunTests"  , +    samplesJadxSrcDir = "${buildDir}/samples-jadx/src", +}, +, +dependencies {, +    compile 'com.google.android.tools:dx:1.7', +    compile 'com.beust:jcommander:1.30', +    compile 'org.slf4j:slf4j-api:1.6.6', +    compile 'ch.qos.logback:logback-classic:1.0.9', +    testCompile 'junit:junit:4.8.2', +}, +, +repositories {, +    mavenCentral(), +}, +, +sourceSets {, +    samples, +    //TODO don't add to eclipse classpath, +    samplesJadx {, +        java {, +            srcDir samplesJadxSrcDir, +            output.classesDir "${buildDir}/samples-jadx/output", +        }, +    }, +}, +, +task samplesRun(type: JavaExec, dependsOn: compileSamplesJava) {  , +    classpath = sourceSets.samples.output, +    main = mainSamplesClass  , +}, +, +task samplesJar(type: Jar, dependsOn: samplesRun) {, +    baseName = 'samples', +    from sourceSets.samples.output, +}, +, +task samplesJadxCreate(type: JavaExec, dependsOn: [compileJava, samplesJar]) {  , +    classpath = sourceSets.main.output + configurations.compile, +    main = mainClassName , +    args = ['-d', samplesJadxSrcDir, samplesJar.archivePath], +}, +, +compileSamplesJadxJava.dependsOn samplesJadxCreate, +, +task samplesJadxRun(type: JavaExec, dependsOn: compileSamplesJadxJava) {  , +    classpath = sourceSets.samplesJadx.output, +    main = mainSamplesClass  , +}, +, +task samples (dependsOn: samplesJadxRun) {, +}, +, +//check.dependsOn samples, +build.dependsOn distZip, +build.dependsOn installApp, +, +startScripts {, +    doLast {, +        // increase default max heap size, +        String var = 'DEFAULT_JVM_OPTS=', +        String args = '-Xmx1500M', +        unixScript.text = unixScript.text.replace(var + '""', var + '"' + args + '"'), +        windowsScript.text = windowsScript.text.replace(var, var + args), +    }, +}, +, +applicationDistribution.with {, +    into('') {, +        from '.', +        include 'README.md', +        include 'NOTICE', +    }, +}, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.4', +}, +, +++ b/build.gradle, +apply plugin: 'java', +apply plugin: 'application', +, +apply plugin: 'eclipse', +apply plugin: 'idea']
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public void parseAndSaveXML() {, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(outDir, "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +	}, +, +		parseAndSaveXML();, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public void parseAndSaveXML() {, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(outDir, "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +	}, +, +		parseAndSaveXML();, +, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +					decompiler.parseAndSaveXML();]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +			}, +			if (j2d.isError()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +			}, +			if (j2d.isError()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java, +import java.lang.reflect.Field;, +, +			debug = true;, +			resetOutDexVar();, +	private void resetOutDexVar() throws JadxException {, +		try {, +			Field outputDex = Main.class.getDeclaredField("outputDex");, +			outputDex.setAccessible(true);, +			outputDex.set(null, null);, +		} catch (Exception e) {, +			throw new JadxException("Failed to reset outputDex field", e);, +		}, +	}, +, +		return dxErrors != null && !dxErrors.isEmpty();]
[+++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, +		checkForUpdate();, +	}, +, +	private void checkForUpdate() {, +		// TODO: add option for disable update checks, +		JadxUpdate.check(new IUpdateCallback() {, +++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, +		checkForUpdate();, +	}, +, +	private void checkForUpdate() {, +		// TODO: add option for disable update checks, +		JadxUpdate.check(new IUpdateCallback() {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import org.fife.ui.rtextarea.SearchResult;, +		context.setMarkAll(markAllCB.isSelected());, +		SearchResult result = SearchEngine.find(rTextArea, context);, +		if (!result.wasFound()) {, +++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, +		checkForUpdate();, +	}, +, +	private void checkForUpdate() {, +		// TODO: add option for disable update checks, +		JadxUpdate.check(new IUpdateCallback() {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import org.fife.ui.rtextarea.SearchResult;, +		context.setMarkAll(markAllCB.isSelected());, +		SearchResult result = SearchEngine.find(rTextArea, context);, +		if (!result.wasFound()) {, +++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java, +					|| release.isPreRelease()) {, +		if (VersionComparator.checkAndCompare(version, latest.getName()) >= 0) {, +		LOG.info("Found new jadx version: {}", latest);, +++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, +		checkForUpdate();, +	}, +, +	private void checkForUpdate() {, +		// TODO: add option for disable update checks, +		JadxUpdate.check(new IUpdateCallback() {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import org.fife.ui.rtextarea.SearchResult;, +		context.setMarkAll(markAllCB.isSelected());, +		SearchResult result = SearchEngine.find(rTextArea, context);, +		if (!result.wasFound()) {, +++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java, +					|| release.isPreRelease()) {, +		if (VersionComparator.checkAndCompare(version, latest.getName()) >= 0) {, +		LOG.info("Found new jadx version: {}", latest);, +++ b/jadx-gui/src/main/java/jadx/gui/update/data/Asset.java, +import com.google.gson.annotations.SerializedName;, +, +, +	@SerializedName("download_count"), +	private int downloadCount;, +, +	@SerializedName("browser_download_url"), +	private String downloadUrl;, +, +	@SerializedName("created_at"), +	private String createdAt;, +	public int getDownloadCount() {, +		return downloadCount;, +	public void setDownloadCount(int downloadCount) {, +		this.downloadCount = downloadCount;, +	}, +, +	public String getDownloadUrl() {, +		return downloadUrl;, +	}, +, +	public void setDownloadUrl(String downloadUrl) {, +		this.downloadUrl = downloadUrl;, +	}, +, +	public String getCreatedAt() {, +		return createdAt;, +	}, +, +	public void setCreatedAt(String createdAt) {, +		this.createdAt = createdAt;, +	}, +, +	@Override]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +import java.util.Locale;, +				return floatToString(Float.intBitsToFloat(data));, +		NumberFormat f = NumberFormat.getInstance(Locale.ROOT);, +	private static String floatToString(float value) {, +		return doubleToString((double) value);, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, +			passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, +			passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.codegen.CodeGen;, +import jadx.core.utils.ErrorsCounter;, +import org.jetbrains.annotations.Nullable;, +import static jadx.core.dex.nodes.ProcessState.GENERATED;, +import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;, +import static jadx.core.dex.nodes.ProcessState.PROCESSED;, +import static jadx.core.dex.nodes.ProcessState.STARTED;, +import static jadx.core.dex.nodes.ProcessState.UNLOADED;, +, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, @Nullable CodeGen codeGen) {, +		synchronized (cls) {, +				if (cls.getState() == NOT_LOADED) {, +					cls.setState(STARTED);, +					for (ClassNode clsNode : cls.getDependencies()) {, +						process(clsNode, passes, null);, +					}, +					cls.setState(PROCESSED);, +				}, +				if (cls.getState() == PROCESSED && codeGen != null) {, +					codeGen.visit(cls);, +					cls.setState(GENERATED);, +				}, +				ErrorsCounter.classError(cls, e.getClass().getSimpleName(), e);, +				if (cls.getState() == GENERATED) {, +					cls.setState(UNLOADED);, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, +			passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.codegen.CodeGen;, +import jadx.core.utils.ErrorsCounter;, +import org.jetbrains.annotations.Nullable;, +import static jadx.core.dex.nodes.ProcessState.GENERATED;, +import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;, +import static jadx.core.dex.nodes.ProcessState.PROCESSED;, +import static jadx.core.dex.nodes.ProcessState.STARTED;, +import static jadx.core.dex.nodes.ProcessState.UNLOADED;, +, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, @Nullable CodeGen codeGen) {, +		synchronized (cls) {, +				if (cls.getState() == NOT_LOADED) {, +					cls.setState(STARTED);, +					for (ClassNode clsNode : cls.getDependencies()) {, +						process(clsNode, passes, null);, +					}, +					cls.setState(PROCESSED);, +				}, +				if (cls.getState() == PROCESSED && codeGen != null) {]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public synchronized void unload() {, +		cls.unload();, +	}, +, +			mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public synchronized void unload() {, +		cls.unload();, +	}, +, +			mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public synchronized void unload() {, +		cls.unload();, +	}, +, +			mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +public class CodeGen {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public synchronized void unload() {, +		cls.unload();, +	}, +, +			mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +public class CodeGen {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import static jadx.core.dex.nodes.ProcessState.UNLOADED;, +, +		setState(UNLOADED);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public synchronized void unload() {, +		cls.unload();, +	}, +, +			mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +public class CodeGen {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import static jadx.core.dex.nodes.ProcessState.UNLOADED;, +, +		setState(UNLOADED);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		trimList(blocks);, +		trimList(exitBlocks);, +	private void trimList(List<BlockNode> blocks) {, +		if (blocks instanceof ArrayList) {, +			((ArrayList<BlockNode>)blocks).trimToSize();, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				try {, +				} catch (Exception e) {, +					LOG.error("Error saving class: {}", cls.getFullName(), e);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public synchronized void unload() {, +		cls.unload();, +	}, +, +			mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java]
[+++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], +	path = jadx-test-app/test-app, +	url = git://github.com/skylot/jadx-test-app.git, +++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], +	path = jadx-test-app/test-app, +	url = git://github.com/skylot/jadx-test-app.git, +++ b/build.gradle, +task testAppCheck(dependsOn: 'jadx-test-app:testAppCheck') {, +}, +, +++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], +	path = jadx-test-app/test-app, +	url = git://github.com/skylot/jadx-test-app.git, +++ b/build.gradle, +task testAppCheck(dependsOn: 'jadx-test-app:testAppCheck') {, +}, +, +++ b/jadx-test-app/README.md, +### Run jadx on test android application, +, +This module contains build scripts for test recompilation of simple android app from:, +https://github.com/skylot/jadx-test-app, +, +For run tests type follow commands in jadx root directory:, +, +```java, +git submodule init, +git submodule update, +./gradlew testAppCheck, +```, +, +Note: You will need connected device or emulator for success, +++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], +	path = jadx-test-app/test-app, +	url = git://github.com/skylot/jadx-test-app.git, +++ b/build.gradle, +task testAppCheck(dependsOn: 'jadx-test-app:testAppCheck') {, +}, +, +++ b/jadx-test-app/README.md, +### Run jadx on test android application, +, +This module contains build scripts for test recompilation of simple android app from:, +https://github.com/skylot/jadx-test-app, +, +For run tests type follow commands in jadx root directory:, +, +```java, +git submodule init, +git submodule update, +./gradlew testAppCheck, +```, +, +Note: You will need connected device or emulator for success, +++ b/jadx-test-app/build.gradle, +project.ext {, +    testAppDir = 'test-app', +    testAppTmpDir = 'test-app-tmp', +, +    buildFile = "${testAppTmpDir}/build.gradle", +    apkFile = "${testAppTmpDir}/build/outputs/apk/test-app-tmp-debug.apk", +    outSrcDir = "${testAppTmpDir}/src/main/java", +    outResDir = "${testAppTmpDir}/src/main", +    checkTask = 'connectedCheck', +}, +, +dependencies {, +    compile(project(":jadx-cli")), +}, +, +sonarRunner {, +    skipProject = true, +}, +, +task deleteTmp(type:Delete) {, +    delete testAppTmpDir, +}, +, +task copyApp(type:Copy, dependsOn: deleteTmp) {, +    from testAppDir, +    into testAppTmpDir, +}, +, +task buildApp(type:Exec, dependsOn: copyApp) {, +    workingDir testAppTmpDir, +    commandLine "./gradlew clean build ${checkTask}".split(' '), +}, +, +task removeSource(type:Delete, dependsOn: buildApp) {, +    delete "${outResDir}/**", +}, +, +task runJadxSrc(type: JavaExec, dependsOn: removeSource) {, +    classpath = sourceSets.main.output + configurations.compile, +    main = project(':jadx-cli').mainClassName, +    args = ['-d', outSrcDir, '-r', apkFile, '-v']]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected static final int DEFAULT_THREADS_COUNT = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +, +	protected int threadsCount = DEFAULT_THREADS_COUNT;, +				throw new JadxException("Threads count must be positive, got: " + threadsCount);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected static final int DEFAULT_THREADS_COUNT = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +, +	protected int threadsCount = DEFAULT_THREADS_COUNT;, +				throw new JadxException("Threads count must be positive, got: " + threadsCount);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public void fixOnLoad() {, +		if (threadsCount <= 0) {, +			threadsCount = DEFAULT_THREADS_COUNT;, +		}, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected static final int DEFAULT_THREADS_COUNT = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +, +	protected int threadsCount = DEFAULT_THREADS_COUNT;, +				throw new JadxException("Threads count must be positive, got: " + threadsCount);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public void fixOnLoad() {, +		if (threadsCount <= 0) {, +			threadsCount = DEFAULT_THREADS_COUNT;, +		}, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +			settings.fixOnLoad();]
[+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + '/' + CLST_FILENAME));, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + '/' + CLST_FILENAME));, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ')');, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + '/' + CLST_FILENAME));, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					return parent + '.' + shortName;, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + '/' + CLST_FILENAME));, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					return parent + '.' + shortName;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(insn.getType().toString()).add('(');, +				code.add(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		arg.getSVar().setVariableName(name);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		arg.getSVar().setVariableName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	public void setVariableName(String name) {, +		setName(name);, +		if (isUsedInPhi()) {, +			PhiInsn phi = getUsedInPhi();, +			phi.getResult().getSVar().setVariableName(name);, +			for (InsnArg arg : phi.getArguments()) {, +				if (arg.isRegister()) {, +					RegisterArg reg = (RegisterArg) arg;, +					SSAVar sVar = reg.getSVar();, +					if (sVar != this && !name.equals(reg.getName())) {, +						sVar.setVariableName(name);, +					}, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		arg.getSVar().setVariableName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	public void setVariableName(String name) {, +		setName(name);, +		if (isUsedInPhi()) {, +			PhiInsn phi = getUsedInPhi();, +			phi.getResult().getSVar().setVariableName(name);, +			for (InsnArg arg : phi.getArguments()) {, +				if (arg.isRegister()) {, +					RegisterArg reg = (RegisterArg) arg;, +					SSAVar sVar = reg.getSVar();, +					if (sVar != this && !name.equals(reg.getName())) {, +						sVar.setVariableName(name);, +					}, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/internal/inline/TestInline2.java, +		public int test() throws InterruptedException {, +		System.out.println(code);, +		assertThat(code, containsString("long i_2 ="));, +		assertThat(code, containsString("+ i_2"));, +		assertThat(code, containsString("i_2--;"));]
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java, +		StringBuilder buf = new StringBuilder(bytes.length * 3);]
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java, +				int lineLength = line.length();, +				if (lineLength == 0 || (lineLength == 1 && line.charAt(0) == '}')) {, +					continue;, +				}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		ClassNode pCls = mth.getParentClass();, +		FieldNode fieldNode = pCls.searchField(field);, +, +		while ((fieldNode == null) , +					&& (pCls.getParentClass() != pCls) && (pCls.getParentClass() != null)), +		{, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		ClassNode pCls = mth.getParentClass();, +		FieldNode fieldNode = pCls.searchField(field);, +, +		while ((fieldNode == null) , +					&& (pCls.getParentClass() != pCls) && (pCls.getParentClass() != null)), +		{, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +++ b/jadx-samples/src/main/java/jadx/samples/TestInner3.java, +package jadx.samples;, +, +public class TestInner3 extends AbstractTest {, +, +	private String i0;, +, +	public class A {, +		, +		protected String a;, +		, +		public A() {, +			a="";, +		}, +, +		public String a() {, +			return "";, +		}, +	}, +, +	public class I0 {, +		private String i0;, +		private String i1;, +, +		public class I1 {, +			private String i0;, +			private String i1;, +			private String i2;, +, +			public I1() {, +				TestInner3.this.i0 = "i0";, +				I0.this.i0 = "i1";, +				I0.this.i1 = "i2";, +, +				i0 = "i0";, +				i1 = "i1";, +				i2 = "i2";, +			}, +, +			public String i() {, +, +				String result = TestInner3.this.i0 + I0.this.i0 + I0.this.i1 + i0 + i1 + i2;, +				, +				A a = new A() {, +, +					public String a() {, +						TestInner3.this.i0 = "i1";, +						I0.this.i0 = "i2";, +						I0.this.i1 = "i3";, +						I1.this.i0 = "i1";, +						I1.this.i1 = "i2";, +						I1.this.i2 = "i3";, +						a = "a";, +, +						return TestInner3.this.i0 + I0.this.i0 + I0.this.i1 + I1.this.i0 + I1.this.i1 + I1.this.i2 + a;, +					}, +				};, +, +				return result + a.a();, +			}, +		}, +, +		public I0() {, +			TestInner3.this.i0 = "i-";, +			i0 = "i0";, +			i1 = "i1";, +		}, +, +		public String i() {, +			String result = TestInner3.this.i0 + i0 + i1;, +			return result + (new I1()).i();, +		}, +	}, +, +	@Override, +	public boolean testRun() throws Exception {, +		assertTrue((new I0()).i().equals("i-i0i1i0i1i2i0i1i2i1i2i3i1i2i3a"));, +		assertTrue(i0.equals("i1"));, +, +		return true;]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +				// remove INFO ThresholdFilter, +				rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +				// remove INFO ThresholdFilter, +				rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/resources/logback.xml, +        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">, +            <level>INFO</level>, +        </filter>, +    <root level="DEBUG">, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +				// remove INFO ThresholdFilter, +				rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/resources/logback.xml, +        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">, +            <level>INFO</level>, +        </filter>, +    <root level="DEBUG">, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LogCollector;, +			LogCollector.register();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +				// remove INFO ThresholdFilter, +				rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/resources/logback.xml, +        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">, +            <level>INFO</level>, +        </filter>, +    <root level="DEBUG">, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LogCollector;, +			LogCollector.register();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +package jadx.gui.ui;, +, +import ch.qos.logback.classic.Level;, +import jadx.gui.utils.LogCollector;, +import jadx.gui.utils.NLS;, +, +import javax.swing.BorderFactory;, +import javax.swing.JButton;, +import javax.swing.JComboBox;, +import javax.swing.JDialog;, +import javax.swing.JLabel;, +import javax.swing.JPanel;, +import javax.swing.JScrollPane;, +import javax.swing.SwingUtilities;, +import java.awt.BorderLayout;, +import java.awt.Container;, +import java.awt.event.ActionEvent;, +import java.awt.event.ActionListener;, +, +import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;, +, +class LogViewer extends JDialog {, +	private static final long serialVersionUID = -2188700277429054641L;, +	private static final Level[] LEVEL_ITEMS = {Level.DEBUG, Level.INFO, Level.WARN, Level.ERROR};, +, +	private static Level level = Level.WARN;, +	private RSyntaxTextArea textPane;, +, +	public LogViewer() {, +		initUI();, +		registerLogListener();, +	}, +, +	public final void initUI() {, +		textPane = new RSyntaxTextArea();, +		textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));, +, +		JPanel controlPane = new JPanel();, +		controlPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));, +		final JComboBox cb = new JComboBox(LEVEL_ITEMS);, +		cb.setSelectedItem(level);, +		cb.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				int i = cb.getSelectedIndex();, +				level = LEVEL_ITEMS[i];, +				registerLogListener();, +			}, +		});, +		JLabel levelLabel = new JLabel(NLS.str("log.level"));, +		levelLabel.setLabelFor(cb);, +		controlPane.add(levelLabel);, +		controlPane.add(cb);, +, +		JScrollPane scrollPane = new JScrollPane(textPane);, +, +		JButton close = new JButton(NLS.str("tabs.close"));, +		close.addActionListener(new ActionListener() {, +			public void actionPerformed(ActionEvent event) {, +				close();, +			}, +		});, +		close.setAlignmentX(0.5f);, +, +		Container contentPane = getContentPane();, +		contentPane.add(controlPane, BorderLayout.PAGE_START);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +						} else {, +							if (inv.getArgsCount() > 0) {, +								for (int j = 0; j < inv.getArgsCount(); j++) {, +									InsnArg arg = inv.getArg(j);, +									if (arg.isLiteral()) {, +										f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +										if (f != null) {, +											arg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, +										}, +									}, +								}, +							}]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +				String nsValue = entry.getValue();, +				writer.add(" xmlns");, +				if (nsValue != null && !nsValue.trim().isEmpty()) {, +					writer.add(':');, +					writer.add(nsValue);, +				}, +				writer.add("=\"").add(entry.getKey()).add("\"");]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case CAST: {, +			}, +			case INSTANCE_OF: {, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add(arg(insn, 0));, +				code.add(" instanceof ");, +				code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, +				if (wrap) {, +					code.add(")");, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case CAST: {, +			}, +			case INSTANCE_OF: {, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add(arg(insn, 0));, +				code.add(" instanceof ");, +				code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, +				if (wrap) {, +					code.add(")");, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +			if (lit.getLiteral() == 0) {, +			}, +				return arg(firstArg, false); // == true, +		return arg(firstArg, isWrapNeeded(firstArg)), +				+ " " + op.getSymbol() + " ", +				+ arg(secondArg, isWrapNeeded(secondArg));, +	}, +, +	private boolean isWrapNeeded(InsnArg arg) {, +		if (!arg.isInsnWrap()) {, +			return false;, +		}, +		InsnNode insn = ((InsnWrapArg) arg).getWrapInsn();, +		if(insn.getType() == InsnType.ARITH) {, +			ArithNode arith = ((ArithNode) insn);, +			switch (arith.getOp()) {, +				case ADD:, +				case SUB:, +				case MUL:, +				case DIV:, +				case REM:, +					return false;, +			}, +		}, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case CAST: {, +			}, +			case INSTANCE_OF: {, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add(arg(insn, 0));, +				code.add(" instanceof ");, +				code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, +				if (wrap) {, +					code.add(")");, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +			if (lit.getLiteral() == 0) {, +			}, +				return arg(firstArg, false); // == true, +		return arg(firstArg, isWrapNeeded(firstArg)), +				+ " " + op.getSymbol() + " ", +				+ arg(secondArg, isWrapNeeded(secondArg));, +	}, +, +	private boolean isWrapNeeded(InsnArg arg) {, +		if (!arg.isInsnWrap()) {, +			return false;, +		}, +		InsnNode insn = ((InsnWrapArg) arg).getWrapInsn();, +		if(insn.getType() == InsnType.ARITH) {, +			ArithNode arith = ((ArithNode) insn);, +			switch (arith.getOp()) {, +				case ADD:, +				case SUB:, +				case MUL:, +				case DIV:, +				case REM:, +					return false;, +			}, +		}, +		return true;]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	@Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), +	protected boolean showInconsistentCode = false;, +, +	public boolean isShowInconsistentCode() {, +		return showInconsistentCode;, +	}, +, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	@Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), +	protected boolean showInconsistentCode = false;, +, +	public boolean isShowInconsistentCode() {, +		return showInconsistentCode;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isShowInconsistentCode() {, +		return false;, +	}, +, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	@Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), +	protected boolean showInconsistentCode = false;, +, +	public boolean isShowInconsistentCode() {, +		return showInconsistentCode;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isShowInconsistentCode() {, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	boolean isShowInconsistentCode();, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	@Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), +	protected boolean showInconsistentCode = false;, +, +	public boolean isShowInconsistentCode() {, +		return showInconsistentCode;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isShowInconsistentCode() {, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	boolean isShowInconsistentCode();, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.api.IJadxArgs;, +	private boolean showInconsistentCode = false;, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, IJadxArgs jadxArgs) {, +		this(cls, parentClsGen, jadxArgs.isFallbackMode());, +		this.showInconsistentCode = jadxArgs.isShowInconsistentCode();, +	}, +, +				if (showInconsistentCode) {, +					mth.remove(AFlag.INCONSISTENT_CODE);, +				}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	@Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), +	protected boolean showInconsistentCode = false;, +, +	public boolean isShowInconsistentCode() {, +		return showInconsistentCode;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isShowInconsistentCode() {, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	boolean isShowInconsistentCode();, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.api.IJadxArgs;, +	private boolean showInconsistentCode = false;, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, IJadxArgs jadxArgs) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	public void setParentInsn(@Nullable InsnNode parentInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	public void setParentInsn(@Nullable InsnNode parentInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import org.jetbrains.annotations.Nullable;, +, +						if (inline(arg, assignInsn, assignBlock, mth)) {, +		}, +				inline(wrapInfo.getArg(), wrapInfo.getInsn(), block, mth);, +	private static boolean inline(RegisterArg arg, InsnNode insn, @Nullable BlockNode block, MethodNode mth) {, +		InsnNode parentInsn = arg.getParentInsn();, +		// replace move instruction if needed, +		if (parentInsn != null && parentInsn.getType() == InsnType.MOVE) {, +			if (block == null) {, +				block = BlockUtils.getBlockByInsn(mth, parentInsn);, +			}, +			if (block != null) {, +				int index = InsnList.getIndex(block.getInstructions(), parentInsn);, +				if (index != -1) {, +					insn.setResult(parentInsn.getResult());, +					insn.copyAttributesFrom(parentInsn);, +					insn.setOffset(parentInsn.getOffset());, +, +					block.getInstructions().set(index, insn);, +					return true;, +				}, +			}, +		}, +		// simple case, +		return arg.wrapInstruction(insn) != null;, +	}, +, +					inline(rarg, ai, null, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	public void setParentInsn(@Nullable InsnNode parentInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import org.jetbrains.annotations.Nullable;, +, +						if (inline(arg, assignInsn, assignBlock, mth)) {, +		}, +				inline(wrapInfo.getArg(), wrapInfo.getInsn(), block, mth);, +	private static boolean inline(RegisterArg arg, InsnNode insn, @Nullable BlockNode block, MethodNode mth) {, +		InsnNode parentInsn = arg.getParentInsn();, +		// replace move instruction if needed, +		if (parentInsn != null && parentInsn.getType() == InsnType.MOVE) {, +			if (block == null) {, +				block = BlockUtils.getBlockByInsn(mth, parentInsn);, +			}, +			if (block != null) {, +				int index = InsnList.getIndex(block.getInstructions(), parentInsn);, +				if (index != -1) {, +					insn.setResult(parentInsn.getResult());, +					insn.copyAttributesFrom(parentInsn);, +					insn.setOffset(parentInsn.getOffset());, +, +					block.getInstructions().set(index, insn);, +					return true;, +				}, +			}, +		}, +		// simple case, +		return arg.wrapInstruction(insn) != null;, +	}, +, +					inline(rarg, ai, null, mth);, +++ b/jadx-core/src/test/java/jadx/tests/smali/TestInlineVarArg.java, +package jadx.tests.smali;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestInlineVarArg extends SmaliTest {, +, +	@Test, +	public void test() {, +		noDebugInfo();, +		ClassNode cls = getClassNodeFromSmali("TestInlineVarArg");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("f(\"a\", \"b\", \"c\");"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	public void setParentInsn(@Nullable InsnNode parentInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import org.jetbrains.annotations.Nullable;, +, +						if (inline(arg, assignInsn, assignBlock, mth)) {, +		}, +				inline(wrapInfo.getArg(), wrapInfo.getInsn(), block, mth);, +	private static boolean inline(RegisterArg arg, InsnNode insn, @Nullable BlockNode block, MethodNode mth) {, +		InsnNode parentInsn = arg.getParentInsn();, +		// replace move instruction if needed, +		if (parentInsn != null && parentInsn.getType() == InsnType.MOVE) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Window;, +import java.util.HashMap;, +import java.util.Map;, +	private Map<String, WindowLocation> windowPos = new HashMap<String, WindowLocation>();, +, +	public void saveWindowPos(Window window) {, +		WindowLocation pos = new WindowLocation(window.getClass().getSimpleName(),, +				window.getX(), window.getY(),, +				window.getWidth(), window.getHeight(), +		);, +		windowPos.put(pos.getWindowId(), pos);, +		sync();, +	}, +, +	public boolean loadWindowPos(Window window) {, +		WindowLocation pos = windowPos.get(window.getClass().getSimpleName());, +		if (pos == null) {, +			return false;, +		}, +		window.setLocation(pos.getX(), pos.getY());, +		window.setSize(pos.getWidth(), pos.getHeight());, +		return true;, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Window;, +import java.util.HashMap;, +import java.util.Map;, +	private Map<String, WindowLocation> windowPos = new HashMap<String, WindowLocation>();, +, +	public void saveWindowPos(Window window) {, +		WindowLocation pos = new WindowLocation(window.getClass().getSimpleName(),, +				window.getX(), window.getY(),, +				window.getWidth(), window.getHeight(), +		);, +		windowPos.put(pos.getWindowId(), pos);, +		sync();, +	}, +, +	public boolean loadWindowPos(Window window) {, +		WindowLocation pos = windowPos.get(window.getClass().getSimpleName());, +		if (pos == null) {, +			return false;, +		}, +		window.setLocation(pos.getX(), pos.getY());, +		window.setSize(pos.getWidth(), pos.getHeight());, +		return true;, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import javax.swing.JOptionPane;, +, +		setTitle(NLS.str("preferences.title"));, +		setSize(400, 550);, +		setLocationRelativeTo(null);, +		setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);, +		setModalityType(ModalityType.APPLICATION_MODAL);, +		pack();, +		JButton resetBtn = new JButton(NLS.str("preferences.reset"));, +		resetBtn.addActionListener(new ActionListener() {, +			public void actionPerformed(ActionEvent event) {, +				int res = JOptionPane.showConfirmDialog(, +						JadxSettingsWindow.this,, +						NLS.str("preferences.reset_message"),, +						NLS.str("preferences.reset_title"),, +						JOptionPane.YES_NO_OPTION);, +				if (res == JOptionPane.YES_OPTION) {, +					String defaults = JadxSettingsAdapter.makeString(new JadxSettings());, +					JadxSettingsAdapter.fill(settings, defaults);, +					getContentPane().removeAll();, +					initUI();, +					pack();, +					repaint();, +				}, +			}, +		});, +, +		buttonPane.add(resetBtn);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Window;, +import java.util.HashMap;, +import java.util.Map;, +	private Map<String, WindowLocation> windowPos = new HashMap<String, WindowLocation>();, +, +	public void saveWindowPos(Window window) {, +		WindowLocation pos = new WindowLocation(window.getClass().getSimpleName(),, +				window.getX(), window.getY(),, +				window.getWidth(), window.getHeight(), +		);, +		windowPos.put(pos.getWindowId(), pos);, +		sync();, +	}, +, +	public boolean loadWindowPos(Window window) {, +		WindowLocation pos = windowPos.get(window.getClass().getSimpleName());, +		if (pos == null) {, +			return false;, +		}, +		window.setLocation(pos.getX(), pos.getY());]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	private static final String CLASS_NAME_SEPARATOR = ".";, +	private static final String INNER_CLASS_SEPARATOR = "$";, +	private final Set<String> pkgSet = new TreeSet<String>();, +		if (fullPkgName.isEmpty() || fullPkgName.equals(CLASS_NAME_SEPARATOR)) {, +			int idx = fullPkgName.indexOf(CLASS_NAME_SEPARATOR);, +				prefix += INNER_CLASS_SEPARATOR;, +			return pkg.getFullAlias() + CLASS_NAME_SEPARATOR + makeNameWithoutPkg();, +			prefix += INNER_CLASS_SEPARATOR;, +		return String.format("C%04d%s", clsIndex++, makeName(clsName));, +		if (!pkg.hasAlias() && shouldRename(pkgName)) {, +			final String pkgAlias = String.format("p%03d%s", pkgIndex++, makeName(pkgName));, +		return s.length() > maxLength, +				|| s.length() < minLength, +				|| NameMapper.isReserved(s), +				|| !NameMapper.isAllCharsPrintable(s);, +	}, +, +	private String makeName(String name) {, +		if (name.length() > maxLength) {, +			return "x" + Integer.toHexString(name.hashCode());, +		}, +		if (NameMapper.isReserved(name)) {, +			return name;, +		}, +		if (!NameMapper.isAllCharsPrintable(name)) {, +			return removeInvalidChars(name);, +		}, +		return name;, +	}, +, +	private String removeInvalidChars(String name) {, +		StringBuilder sb = new StringBuilder();, +		for (int i = 0; i < name.length(); i++) {, +			int ch = name.charAt(i);, +			if (NameMapper.isPrintableChar(ch)) {, +				sb.append((char) ch);, +			}, +		}, +		return sb.toString();, +				String[] va = splitAndTrim(l);, +				String[] va = splitAndTrim(l);, +		return getPackageName(clsInfo.getPackage()) + CLASS_NAME_SEPARATOR + getClassName(clsInfo);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	private static final String CLASS_NAME_SEPARATOR = ".";, +	private static final String INNER_CLASS_SEPARATOR = "$";, +	private final Set<String> pkgSet = new TreeSet<String>();, +		if (fullPkgName.isEmpty() || fullPkgName.equals(CLASS_NAME_SEPARATOR)) {, +			int idx = fullPkgName.indexOf(CLASS_NAME_SEPARATOR);, +				prefix += INNER_CLASS_SEPARATOR;, +			return pkg.getFullAlias() + CLASS_NAME_SEPARATOR + makeNameWithoutPkg();, +			prefix += INNER_CLASS_SEPARATOR;, +		return String.format("C%04d%s", clsIndex++, makeName(clsName));, +		if (!pkg.hasAlias() && shouldRename(pkgName)) {, +			final String pkgAlias = String.format("p%03d%s", pkgIndex++, makeName(pkgName));, +		return s.length() > maxLength, +				|| s.length() < minLength, +				|| NameMapper.isReserved(s), +				|| !NameMapper.isAllCharsPrintable(s);, +	}, +, +	private String makeName(String name) {, +		if (name.length() > maxLength) {, +			return "x" + Integer.toHexString(name.hashCode());, +		}, +		if (NameMapper.isReserved(name)) {, +			return name;, +		}, +		if (!NameMapper.isAllCharsPrintable(name)) {, +			return removeInvalidChars(name);, +		}, +		return name;, +	}, +, +	private String removeInvalidChars(String name) {, +		StringBuilder sb = new StringBuilder();, +		for (int i = 0; i < name.length(); i++) {, +			int ch = name.charAt(i);, +			if (NameMapper.isPrintableChar(ch)) {, +				sb.append((char) ch);, +			}, +		}, +		return sb.toString();, +				String[] va = splitAndTrim(l);, +				String[] va = splitAndTrim(l);, +		return getPackageName(clsInfo.getPackage()) + CLASS_NAME_SEPARATOR + getClassName(clsInfo);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +		return VALID_JAVA_IDENTIFIER.matcher(str).matches() && isAllCharsPrintable(str);, +		return VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches() && isAllCharsPrintable(str);, +	}, +, +	public static boolean isPrintableChar(int c) {, +		return 32 <= c && c <= 126;, +	}, +, +	public static boolean isAllCharsPrintable(String str) {, +		for (int i = 0; i < str.length(); i++) {, +			 if (!isPrintableChar(str.charAt(i))) {, +				 return false;, +			 }]
[+++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.Code;, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.Code;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import com.android.dex.ClassData;, +import com.android.dex.ClassData.Field;, +import com.android.dex.ClassData.Method;, +import com.android.dex.ClassDef;, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.Code;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import com.android.dex.ClassData;, +import com.android.dex.ClassData.Field;, +import com.android.dex.ClassData.Method;, +import com.android.dex.ClassDef;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.ClassData;, +import com.android.dex.ClassData.Method;, +import com.android.dex.ClassDef;, +import com.android.dex.Code;, +import com.android.dex.Dex;, +import com.android.dex.FieldId;, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +import com.android.dex.TypeList;, +import com.android.dex.TableOfContents; , +	private final Dex dexBuf;, +	public Dex.Section openSection(int offset) {, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.Code;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import com.android.dex.ClassData;, +import com.android.dex.ClassData.Field;, +import com.android.dex.ClassData.Method;, +import com.android.dex.ClassDef;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.ClassData;, +import com.android.dex.ClassData.Method;, +import com.android.dex.ClassDef;, +import com.android.dex.Code;, +import com.android.dex.Dex;, +import com.android.dex.FieldId;, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +import com.android.dex.TypeList;, +import com.android.dex.TableOfContents; , +	private final Dex dexBuf;, +	public Dex.Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java]
[+++ b/.gitignore, +node_modules/, +++ b/.gitignore, +node_modules/, +++ b/.releaserc.yml, +branch: release, +verifyConditions:, +  - '@semantic-release/github', +prepare:, +  - path: '@semantic-release/exec', +    cmd: "JADX_VERSION=${nextRelease.version} ./gradlew clean dist", +publish:, +  - path: '@semantic-release/exec', +    cmd: "JADX_VERSION=${nextRelease.version} BINTRAY_PACKAGE=releases bash scripts/bintray-upload.sh", +  - path: '@semantic-release/github', +    assets:, +      - path: 'build/*.zip', +        label: 'zip bundle', +      - path: 'build/*.exe', +        label: 'jadx-gui windows', +, +++ b/.gitignore, +node_modules/, +++ b/.releaserc.yml, +branch: release, +verifyConditions:, +  - '@semantic-release/github', +prepare:, +  - path: '@semantic-release/exec', +    cmd: "JADX_VERSION=${nextRelease.version} ./gradlew clean dist", +publish:, +  - path: '@semantic-release/exec', +    cmd: "JADX_VERSION=${nextRelease.version} BINTRAY_PACKAGE=releases bash scripts/bintray-upload.sh", +  - path: '@semantic-release/github', +    assets:, +      - path: 'build/*.zip', +        label: 'zip bundle', +      - path: 'build/*.exe', +        label: 'jadx-gui windows', +, +++ b/.travis.yml, +# don't build on tag push, +if: tag IS blank, +, +git:, +  depth: false, +, +    - JADX_VERSION="$(git describe --abbrev=0 --tags)-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)", +  - provider: script, +    script: bash scripts/travis-master.sh, +, +  - provider: script, +    skip_cleanup: true, +    on:, +      branch: release, +      tags: false, +      condition: $JDK = oracle-8, +    script: bash scripts/travis-release.sh, +++ b/.gitignore, +node_modules/, +++ b/.releaserc.yml, +branch: release, +verifyConditions:, +  - '@semantic-release/github', +prepare:, +  - path: '@semantic-release/exec', +    cmd: "JADX_VERSION=${nextRelease.version} ./gradlew clean dist", +publish:, +  - path: '@semantic-release/exec', +    cmd: "JADX_VERSION=${nextRelease.version} BINTRAY_PACKAGE=releases bash scripts/bintray-upload.sh", +  - path: '@semantic-release/github', +    assets:, +      - path: 'build/*.zip', +        label: 'zip bundle', +      - path: 'build/*.exe', +        label: 'jadx-gui windows', +, +++ b/.travis.yml, +# don't build on tag push, +if: tag IS blank, +, +git:, +  depth: false, +, +    - JADX_VERSION="$(git describe --abbrev=0 --tags)-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)", +  - provider: script, +    script: bash scripts/travis-master.sh, +, +  - provider: script, +    skip_cleanup: true, +    on:, +      branch: release, +      tags: false, +      condition: $JDK = oracle-8, +    script: bash scripts/travis-release.sh, +++ b/README.md, +[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release), +++ b/.gitignore, +node_modules/, +++ b/.releaserc.yml]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		enterBlock = null;, +		sVars.clear();, +		region = null;, +		loops.clear();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		enterBlock = null;, +		sVars.clear();, +		region = null;, +		loops.clear();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +		removeInnerClassesFromDeps(cls, depList);, +, +	private void removeInnerClassesFromDeps(ClassNode cls, Set<ClassNode> depList) {, +		cls.getInnerClasses().forEach(inner -> {, +			depList.remove(inner);, +			removeInnerClassesFromDeps(inner, depList);, +		});, +	}]
[+++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, +    - build/jadx*.exe, +++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, +    - build/jadx*.exe, +++ b/.travis.yml, +    - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, +    - build/jadx*.exe, +++ b/.travis.yml, +    - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/bintray.json, +      "includePattern": "build/(jadx.*\.(zip|exe))",, +++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, +    - build/jadx*.exe, +++ b/.travis.yml, +    - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/bintray.json, +      "includePattern": "build/(jadx.*\.(zip|exe))",, +++ b/build.gradle, +task copyExe(type: Copy, dependsOn: 'jadx-gui:createExe') {, +    group 'jadx', +    description = 'Copy exe to build dir', +    destinationDir buildDir, +    from tasks.getByPath('jadx-gui:createExe').outputs, +    include '*.exe', +}, +, +task dist(dependsOn: [pack, copyExe]) {, +    group 'jadx', +    group 'jadx', +    group 'jadx', +    group 'jadx', +++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, +    - build/jadx*.exe, +++ b/.travis.yml, +    - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/bintray.json, +      "includePattern": "build/(jadx.*\.(zip|exe))",, +++ b/build.gradle, +task copyExe(type: Copy, dependsOn: 'jadx-gui:createExe') {, +    group 'jadx', +    description = 'Copy exe to build dir', +    destinationDir buildDir, +    from tasks.getByPath('jadx-gui:createExe').outputs, +    include '*.exe', +}, +, +task dist(dependsOn: [pack, copyExe]) {, +    group 'jadx', +    group 'jadx', +    group 'jadx', +    group 'jadx', +++ b/jadx-gui/build.gradle, +plugins {, +    id 'edu.sc.seis.launch4j' version '2.4.3', +    id 'com.github.johnrengelman.shadow' version '2.0.2', +}, +, +launch4j {, +    mainClassName = 'jadx.gui.JadxGUI', +    copyConfigurable = project.tasks.shadowJar.outputs.files, +    jar = "lib/${project.tasks.shadowJar.archiveName}", +//  icon = "${projectDir}/icons/myApp.ico", +    outfile = "jadx-gui-${version}.exe", +    copyright = 'Skylot', +    windowTitle = 'jadx', +    jreRuntimeBits = "64", +    initialHeapPercent = 5, +    maxHeapSize = 4096, +    maxHeapPercent = 70, +}, +, +++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, +    - build/jadx*.exe, +++ b/.travis.yml, +    - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/bintray.json, +      "includePattern": "build/(jadx.*\.(zip|exe))",, +++ b/build.gradle, +task copyExe(type: Copy, dependsOn: 'jadx-gui:createExe') {, +    group 'jadx', +    description = 'Copy exe to build dir', +    destinationDir buildDir, +    from tasks.getByPath('jadx-gui:createExe').outputs, +    include '*.exe', +}, +, +task dist(dependsOn: [pack, copyExe]) {, +    group 'jadx', +    group 'jadx', +    group 'jadx', +    group 'jadx', +++ b/jadx-gui/build.gradle, +plugins {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.info.MethodInfo;, +				return makeNameFromInvoke(inv.getCallMth());, +, +	private static String makeNameFromInvoke(MethodInfo callMth) {, +		String name = callMth.getName();, +		if (name.startsWith("get") || name.startsWith("set")) {, +			return fromName(name.substring(3));, +		}, +		ArgType declType = callMth.getDeclClass().getType();, +		if ("iterator".equals(name)) {, +			return "it";, +		}, +		if ("toString".equals(name)) {, +			return makeNameForType(declType);, +		}, +		if ("forName".equals(name) && declType.equals(ArgType.CLASS)) {, +			return OBJ_ALIAS.get(Consts.CLASS_CLASS);, +		}, +		return name;, +	}]
[+++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java, +import org.junit.jupiter.api.Disabled;, +import org.junit.jupiter.api.Test;, +	@Disabled, +++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java, +import org.junit.jupiter.api.Disabled;, +import org.junit.jupiter.api.Test;, +	@Disabled, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import org.junit.jupiter.api.Test;, +++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java, +import org.junit.jupiter.api.Disabled;, +import org.junit.jupiter.api.Test;, +	@Disabled, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java, +import org.junit.jupiter.api.Test;, +++ b/build.gradle, +, +        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', +        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', +    }, +, +    test {, +        useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java, +import org.junit.jupiter.api.Disabled;, +import org.junit.jupiter.api.Test;, +	@Disabled]
[+++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +	private final int id;, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +	private final int id;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.Consts;, +				ClassInfo superCallCls = getClassForSuperCall(code, callMth);, +				if (superCallCls != null) {, +					useClass(code, superCallCls);, +					code.add('.');, +				}, +	@Nullable, +	private ClassInfo getClassForSuperCall(CodeWriter code, MethodInfo callMth) {, +		ClassNode useCls = mth.getParentClass();, +		ClassInfo insnCls = useCls.getAlias();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					BlockNode ss = s.get(0);, +					BlockNode cross = BlockUtils.getPathCross(mth, ss, handler);, +					if (cross != null && cross != ss && cross != handler) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					BlockNode ss = s.get(0);, +					BlockNode cross = BlockUtils.getPathCross(mth, ss, handler);, +					if (cross != null && cross != ss && cross != handler) {, +++ b/jadx-core/src/test/java/jadx/tests/internal/others/TestIssue13.java, +package jadx.tests.internal.others;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.lang.reflect.Field;, +import java.util.HashMap;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestIssue13 extends InternalJadxTest {, +, +	public static class TestCls {, +		private static final String TAG = "Parcel";, +		private static HashMap<ClassLoader, HashMap<String, Parcelable.Creator>> mCreators;, +, +		public final <T extends Parcelable> T test(ClassLoader loader) {, +			String name = readString();, +			if (name == null) {, +				return null;, +			}, +			Parcelable.Creator<T> creator;, +			synchronized (mCreators) {, +				HashMap<String, Parcelable.Creator> map = mCreators.get(loader);, +				if (map == null) {, +					map = new HashMap<String, Parcelable.Creator>();, +					mCreators.put(loader, map);, +				}, +				creator = map.get(name);, +				if (creator == null) {, +					try {, +						Class c = loader == null ?, +								Class.forName(name) : Class.forName(name, true, loader);, +						Field f = c.getField("CREATOR");, +						creator = (Parcelable.Creator) f.get(null);, +					} catch (IllegalAccessException e) {, +						Log.e(TAG, "1" + name + ", e: " + e);, +						throw new RuntimeException("2" + name);, +					} catch (ClassNotFoundException e) {, +						Log.e(TAG, "3" + name + ", e: " + e);, +						throw new RuntimeException("4" + name);, +					} catch (ClassCastException e) {, +						throw new RuntimeException("5" + name);, +					} catch (NoSuchFieldException e) {, +						throw new RuntimeException("6" + name);, +					}, +					if (creator == null) {, +						throw new RuntimeException("7" + name);, +					}, +					map.put(name, creator);, +				}, +			}, +			if (creator instanceof Parcelable.ClassLoaderCreator<?>) {, +				return ((Parcelable.ClassLoaderCreator<T>) creator).createFromParcel(this, loader);, +			}, +			return creator.createFromParcel(this);, +		}, +, +		private String readString() {, +			return "";, +		}, +, +		private class Parcelable {, +			public class Creator<T> {, +				public T createFromParcel(TestCls testCls) {, +					return null;, +				}, +			}, +, +			public class ClassLoaderCreator<T> extends Creator<T> {, +				public T createFromParcel(TestCls testCls, ClassLoader loader) {, +					return null;, +				}, +			}, +		}, +, +		private static class Log {, +			public static void e(String tag, String s) {, +, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, +			InsnRemover.fixUsedInPhiFlag(reg);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, +			InsnRemover.fixUsedInPhiFlag(reg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import jadx.core.utils.InsnRemover;, +		attachArg(arg);, +	}, +, +	public void setArg(int n, InsnArg arg) {, +		arguments.set(n, arg);, +		attachArg(arg);, +	}, +, +	private void attachArg(InsnArg arg) {, +				InsnRemover.unbindArgUsage(null, arg);, +				InsnRemover.unbindArgUsage(null, arg);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, +			InsnRemover.fixUsedInPhiFlag(reg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import jadx.core.utils.InsnRemover;, +		attachArg(arg);, +	}, +, +	public void setArg(int n, InsnArg arg) {, +		arguments.set(n, arg);, +		attachArg(arg);, +	}, +, +	private void attachArg(InsnArg arg) {, +				InsnRemover.unbindArgUsage(null, arg);, +				InsnRemover.unbindArgUsage(null, arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InsnRemover;, +		InsnRemover.remove(mth, block, insn);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, +			InsnRemover.fixUsedInPhiFlag(reg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import jadx.core.utils.InsnRemover;, +		attachArg(arg);, +	}, +, +	public void setArg(int n, InsnArg arg) {, +		arguments.set(n, arg);, +		attachArg(arg);, +	}, +, +	private void attachArg(InsnArg arg) {, +				InsnRemover.unbindArgUsage(null, arg);, +				InsnRemover.unbindArgUsage(null, arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InsnRemover;, +		InsnRemover.remove(mth, block, insn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.InsnRemover;, +			InsnRemover.removeAllAndUnbind(mth, block, toRemove);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, +			InsnRemover.fixUsedInPhiFlag(reg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import jadx.core.utils.InsnRemover;, +		attachArg(arg);, +	}, +, +	public void setArg(int n, InsnArg arg) {, +		arguments.set(n, arg);, +		attachArg(arg);, +	}, +, +	private void attachArg(InsnArg arg) {, +				InsnRemover.unbindArgUsage(null, arg);, +				InsnRemover.unbindArgUsage(null, arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InsnRemover;, +		InsnRemover.remove(mth, block, insn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.InsnRemover;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +						&& canDeclareInRegion(u, assignRegion), +				if (canDeclareInRegion(u, region)) {, +	private static boolean canDeclareInRegion(Usage u, IRegion region) {, +		// TODO: make index for faster search, +		return isAllRegionsAfter(region, u.getAssigns()), +				&& isAllRegionsAfter(region, u.getUseRegions());, +	private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +						&& canDeclareInRegion(u, assignRegion), +				if (canDeclareInRegion(u, region)) {, +	private static boolean canDeclareInRegion(Usage u, IRegion region) {, +		// TODO: make index for faster search, +		return isAllRegionsAfter(region, u.getAssigns()), +				&& isAllRegionsAfter(region, u.getUseRegions());, +	private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					if (exitBlocks.contains(exitEdge.getSource())) {, +		}, +			Region body = makeRegion(loopStart, stack);, +			loopRegion.setBody(body);, +		BlockNode out = null;, +		if (exitEdges.size() == 1) {, +			Edge exitEdge = exitEdges.get(0);, +					out = nextBlock;, +				}, +			}, +		} else {, +			for (Edge exitEdge : exitEdges) {, +				BlockNode exit = exitEdge.getTarget();, +				List<BlockNode> blocks = BlockUtils.bitSetToBlocks(mth, exit.getDomFrontier());, +				for (BlockNode block : blocks) {, +					if (BlockUtils.isPathExists(exit, block)) {, +						stack.addExit(block);, +						insertBreak(stack, block, exitEdge);, +						out = block;, +					} else {, +						insertBreak(stack, exit, exitEdge);, +					}, +		if (out == null) {, +			out = RegionUtils.isRegionContainsBlock(body, next) ? null : next;, +		return out;, +	private static void traverseMonitorExits(SynchronizedRegion region, InsnArg arg, BlockNode block, Set<BlockNode> exits,, +	                                         Set<BlockNode> visited) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +						&& canDeclareInRegion(u, assignRegion), +				if (canDeclareInRegion(u, region)) {, +	private static boolean canDeclareInRegion(Usage u, IRegion region) {, +		// TODO: make index for faster search, +		return isAllRegionsAfter(region, u.getAssigns()), +				&& isAllRegionsAfter(region, u.getUseRegions());, +	private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					if (exitBlocks.contains(exitEdge.getSource())) {, +		}, +			Region body = makeRegion(loopStart, stack);, +			loopRegion.setBody(body);, +		BlockNode out = null;, +		if (exitEdges.size() == 1) {, +			Edge exitEdge = exitEdges.get(0);, +					out = nextBlock;, +				}, +			}, +		} else {, +			for (Edge exitEdge : exitEdges) {, +				BlockNode exit = exitEdge.getTarget();, +				List<BlockNode> blocks = BlockUtils.bitSetToBlocks(mth, exit.getDomFrontier());, +				for (BlockNode block : blocks) {, +					if (BlockUtils.isPathExists(exit, block)) {, +						stack.addExit(block);, +						insertBreak(stack, block, exitEdge);, +						out = block;]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	private List<JavaClass> classes;, +			ex.shutdown();, +		if (classes == null) {, +			List<JavaClass> clsList = new ArrayList<JavaClass>(classNodeList.size());, +				clsList.add(new JavaClass(this, classNode));, +			classes = Collections.unmodifiableList(clsList);, +		}, +		return classes;, +		for (JavaClass javaClass : getClasses()) {, +		reset();, +	private void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +, +	JavaClass findJavaClass(ClassNode cls) {, +		if (cls == null) {, +			return null;, +		}, +		for (JavaClass javaClass : getClasses()) {, +			if (javaClass.getClassNode().equals(cls)) {, +				return javaClass;, +			}, +		}, +		return null;, +	}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	private List<JavaClass> classes;, +			ex.shutdown();, +		if (classes == null) {, +			List<JavaClass> clsList = new ArrayList<JavaClass>(classNodeList.size());, +				clsList.add(new JavaClass(this, classNode));, +			classes = Collections.unmodifiableList(clsList);, +		}, +		return classes;, +		for (JavaClass javaClass : getClasses()) {, +		reset();, +	private void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +, +	JavaClass findJavaClass(ClassNode cls) {, +		if (cls == null) {, +			return null;, +		}, +		for (JavaClass javaClass : getClasses()) {, +			if (javaClass.getClassNode().equals(cls)) {, +				return javaClass;, +			}, +		}, +		return null;, +	}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	ClassNode getClassNode() {, +		return cls;, +	}, +, +		decompile();, +			if (clsNode == null) {, +				return null;, +			}, +			JavaClass jCls = decompiler.findJavaClass(clsNode);, +			if (jCls == null) {, +				return null;, +			}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	private List<JavaClass> classes;, +			ex.shutdown();, +		if (classes == null) {, +			List<JavaClass> clsList = new ArrayList<JavaClass>(classNodeList.size());, +				clsList.add(new JavaClass(this, classNode));, +			classes = Collections.unmodifiableList(clsList);, +		}, +		return classes;, +		for (JavaClass javaClass : getClasses()) {, +		reset();, +	private void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +, +	JavaClass findJavaClass(ClassNode cls) {, +		if (cls == null) {, +			return null;, +		}, +		for (JavaClass javaClass : getClasses()) {, +			if (javaClass.getClassNode().equals(cls)) {, +				return javaClass;, +			}, +		}, +		return null;, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, +			passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, +			passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, +			passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected enum Flags {, +		INLINE, +	protected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +				if (flag != Flags.INLINE) {, +				}, +				if (flag != Flags.INLINE) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, +			passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected enum Flags {, +		INLINE, +	protected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +				if (flag != Flags.INLINE) {, +				}, +				if (flag != Flags.INLINE) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfRegion;, +import jadx.core.dex.regions.loops.IndexLoop;, +import jadx.core.dex.regions.loops.LoopRegion;, +import jadx.core.dex.regions.loops.LoopType;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			if (!insn.contains(AFlag.SKIP)) {, +		}, +		LoopType type = region.getType();, +		if (type != null) {, +			if (type instanceof IndexLoop) {, +				IndexLoop indexLoop = (IndexLoop) type;, +				code.startLine("for (");, +				makeInsn(indexLoop.getInitInsn(), code, Flags.INLINE);, +				code.add("; ");, +				conditionGen.add(code, condition);, +				code.add("; ");, +				makeInsn(indexLoop.getIncrInsn(), code, Flags.INLINE);, +				code.add(") {");, +				makeRegionIndent(code, region.getBody());, +				code.startLine('}');, +				return code;, +			}, +			throw new JadxRuntimeException("Unknown loop type: " + type.getClass());, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, +			passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected enum Flags {, +		INLINE, +	protected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +				if (flag != Flags.INLINE) {, +				}, +				if (flag != Flags.INLINE) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfRegion;, +import jadx.core.dex.regions.loops.IndexLoop;, +import jadx.core.dex.regions.loops.LoopRegion;, +import jadx.core.dex.regions.loops.LoopType;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			if (!insn.contains(AFlag.SKIP)) {, +		}, +		LoopType type = region.getType();, +		if (type != null) {, +			if (type instanceof IndexLoop) {, +				IndexLoop indexLoop = (IndexLoop) type;, +				code.startLine("for (");, +				makeInsn(indexLoop.getInitInsn(), code, Flags.INLINE);, +				code.add("; ");, +				conditionGen.add(code, condition);, +				code.add("; ");, +				makeInsn(indexLoop.getIncrInsn(), code, Flags.INLINE);]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +			long size;, +			ZipRef zipRef = rf.getZipRef();, +			if (zipRef == null) {, +				File file = new File(rf.getName());, +				inputStream = new BufferedInputStream(new FileInputStream(file));, +				size = file.length();, +			} else {, +				size = entry.getSize();, +			}, +			result = decoder.decode(size, inputStream);, +			throw new JadxException("Error decode: " + rf.getName(), e);, +				LOG.error("Error close zip file: {}", rf.getName(), e);, +			addResourceFile(list, file);, +	private void addResourceFile(List<ResourceFile> list, File file) {, +		String name = file.getAbsolutePath();, +		ResourceType type = ResourceType.getFileType(name);, +		ResourceFile rf = new ResourceFile(jadxRef, name, type);, +		list.add(rf);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +			long size;, +			ZipRef zipRef = rf.getZipRef();, +			if (zipRef == null) {, +				File file = new File(rf.getName());, +				inputStream = new BufferedInputStream(new FileInputStream(file));, +				size = file.length();, +			} else {, +				size = entry.getSize();, +			}, +			result = decoder.decode(size, inputStream);, +			throw new JadxException("Error decode: " + rf.getName(), e);, +				LOG.error("Error close zip file: {}", rf.getName(), e);, +			addResourceFile(list, file);, +	private void addResourceFile(List<ResourceFile> list, File file) {, +		String name = file.getAbsolutePath();, +		ResourceType type = ResourceType.getFileType(name);, +		ResourceFile rf = new ResourceFile(jadxRef, name, type);, +		list.add(rf);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import jadx.core.dex.nodes.DexNode;, +import java.util.List;, +		List<DexNode> dexNodes = root.getDexNodes();, +		if (dexNodes.size() == 0) {, +			return;, +		}, +		InputFile firstInputFile = dexNodes.get(0).getDexFile().getInputFile();, +		deobfuscator = new Deobfuscator(args, dexNodes, deobfMapFile);, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +			long size;, +			ZipRef zipRef = rf.getZipRef();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +		return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +		return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +		return body == null ? "-" : body.baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +		return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +		return body == null ? "-" : body.baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		// printRegion(mth);, +	private void printRegion(MethodNode mth) {, +		LOG.debug("|" + mth.toString());, +		printRegion(mth, mth.getRegion(), "| ");, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +		return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +		return body == null ? "-" : body.baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		// printRegion(mth);, +	private void printRegion(MethodNode mth) {, +		LOG.debug("|" + mth.toString());, +		printRegion(mth, mth.getRegion(), "| ");, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import static jadx.core.dex.visitors.regions.RegionMaker.isEqualPaths;, +import static jadx.core.dex.visitors.regions.RegionMaker.isReturnBlocks;, +			pred = BlockUtils.skipSyntheticPredecessor(pred);, +		if (!isEqualPaths(curThen, nextIf.getThenBlock()), +				&& !isEqualPaths(curElse, nextIf.getElseBlock())) {, +			otherBranchBlock = BlockUtils.skipSyntheticSuccessor(otherBranchBlock);, +				if (!canMerge(currentIf, nextIf, followThenBranch)) {, +					return currentIf;, +				}, +		return isEqualPaths(currentIf.getElseBlock(), nextIf.getThenBlock()), +				|| isEqualPaths(currentIf.getThenBlock(), nextIf.getElseBlock());, +	}, +, +	private static boolean canMerge(IfInfo a, IfInfo b, boolean followThenBranch) {, +		if (followThenBranch) {, +			return isEqualPaths(a.getElseBlock(), b.getElseBlock());, +		} else {, +			return isEqualPaths(a.getThenBlock(), b.getThenBlock());, +		}, +		// skip synthetic successor if both parts leads to same block, +		BlockNode thenBlock;, +		BlockNode elseBlock;, +		if (followThenBranch) {, +			thenBlock = second.getThenBlock();, +			elseBlock = getCrossBlock(first.getElseBlock(), second.getElseBlock());, +		} else {, +			thenBlock = getCrossBlock(first.getThenBlock(), second.getThenBlock());, +			elseBlock = second.getElseBlock();, +		}, +		IfInfo result = new IfInfo(condition, thenBlock, elseBlock);, +	private static BlockNode getCrossBlock(BlockNode first, BlockNode second) {, +		if (isSameBlocks(first, second)) {, +			return second;, +		}, +		BlockNode firstSkip = BlockUtils.skipSyntheticSuccessor(first);, +		if (isSameBlocks(firstSkip, second)) {, +			return second;, +		}, +		BlockNode secondSkip = BlockUtils.skipSyntheticSuccessor(second);, +		if (isSameBlocks(firstSkip, secondSkip) || isSameBlocks(first, secondSkip)) {, +			return secondSkip;, +		}, +		throw new JadxRuntimeException("Unexpected merge pattern");, +	}, +, +	private static boolean isSameBlocks(BlockNode first, BlockNode second) {, +		return first == second || isReturnBlocks(first, second);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +		return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +		return body == null ? "-" : body.baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +		// printRegion(mth);, +	private void printRegion(MethodNode mth) {, +		LOG.debug("|" + mth.toString());, +		printRegion(mth, mth.getRegion(), "| ");, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import static jadx.core.dex.visitors.regions.RegionMaker.isEqualPaths;, +import static jadx.core.dex.visitors.regions.RegionMaker.isReturnBlocks;, +			pred = BlockUtils.skipSyntheticPredecessor(pred);, +		if (!isEqualPaths(curThen, nextIf.getThenBlock()), +				&& !isEqualPaths(curElse, nextIf.getElseBlock())) {, +			otherBranchBlock = BlockUtils.skipSyntheticSuccessor(otherBranchBlock);, +				if (!canMerge(currentIf, nextIf, followThenBranch)) {, +					return currentIf;]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +		code.add(callMth.getAlias());, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxClasspathTest.java, +package jadx.tests.functional;, +, +import jadx.core.clsp.ClspGraph;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.utils.exceptions.DecodeException;, +, +import java.io.IOException;, +, +import org.junit.Before;, +import org.junit.Test;, +, +import static jadx.core.dex.instructions.args.ArgType.object;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +, +public class JadxClasspathTest {, +, +	private static final String JAVA_LANG_EXCEPTION = "java.lang.Exception";, +	private static final String JAVA_LANG_THROWABLE = "java.lang.Throwable";, +, +	ClspGraph clsp;, +, +	@Before, +	public void initClsp() throws IOException, DecodeException {, +		clsp = new ClspGraph();, +		clsp.load();, +		ArgType.setClsp(clsp);, +	}, +, +	@Test, +	public void test() {, +		ArgType objExc = object(JAVA_LANG_EXCEPTION);, +		ArgType objThr = object(JAVA_LANG_THROWABLE);, +, +		assertTrue(clsp.isImplements(JAVA_LANG_EXCEPTION, JAVA_LANG_THROWABLE));, +		assertFalse(clsp.isImplements(JAVA_LANG_THROWABLE, JAVA_LANG_EXCEPTION));, +, +		assertFalse(ArgType.isCastNeeded(objExc, objThr));, +		assertTrue(ArgType.isCastNeeded(objThr, objExc));, +	}, +}, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxClasspathTest.java, +package jadx.tests.functional;, +, +import jadx.core.clsp.ClspGraph;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.utils.exceptions.DecodeException;, +, +import java.io.IOException;, +, +import org.junit.Before;, +import org.junit.Test;, +, +import static jadx.core.dex.instructions.args.ArgType.object;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +, +public class JadxClasspathTest {, +, +	private static final String JAVA_LANG_EXCEPTION = "java.lang.Exception";, +	private static final String JAVA_LANG_THROWABLE = "java.lang.Throwable";, +, +	ClspGraph clsp;, +, +	@Before, +	public void initClsp() throws IOException, DecodeException {]
[+++ b/.travis.yml, +    - JADX_LAST_TAG=$(git describe --abbrev=0 --tags), +    - JADX_VERSION="${JADX_LAST_TAG:1}-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)"]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions.java, +package jadx.tests.internal.conditions;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestConditions extends InternalJadxTest {, +, +	public static class TestCls {, +		private boolean f1(boolean a, boolean b, boolean c) {, +			return (a && b) || c;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, not(containsString("(!a || !b) && !c")));, +		assertThat(code, containsString("(a && b) || c"));, +//		assertThat(code, containsString("return (a && b) || c;"));, +	}, +}, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions.java, +package jadx.tests.internal.conditions;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestConditions extends InternalJadxTest {, +, +	public static class TestCls {, +		private boolean f1(boolean a, boolean b, boolean c) {, +			return (a && b) || c;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, not(containsString("(!a || !b) && !c")));, +		assertThat(code, containsString("(a && b) || c"));, +//		assertThat(code, containsString("return (a && b) || c;"));, +	}, +}, +++ b/jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions2.java, +package jadx.tests.internal.conditions;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestConditions2 extends InternalJadxTest {, +, +	public static class TestCls extends Exception {, +		int c;, +		String d;, +		String f;, +, +		public void testComplexIf(String a, int b) {, +			if (d == null || (c == 0 && b != -1 && d.length() == 0)) {, +				c = a.codePointAt(c);, +			} else {, +				if (a.hashCode() != 0xCDE) {, +					c = f.compareTo(a);, +				}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, +				ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, +				ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, +	public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, +				ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, +	public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				ArgType arrType = dex.getType(insn.getIndex());, +				return new NewArrayNode(arrType,, +						InsnArg.reg(insn, 0, arrType),, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, +				ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, +	public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				ArgType arrType = dex.getType(insn.getIndex());, +				return new NewArrayNode(arrType,, +						InsnArg.reg(insn, 0, arrType),, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/NewArrayNode.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.InsnNode;, +, +import org.jetbrains.annotations.NotNull;, +, +public class NewArrayNode extends InsnNode {, +, +	private final ArgType arrType;, +, +	public NewArrayNode(@NotNull ArgType arrType, RegisterArg res, InsnArg size) {, +		super(InsnType.NEW_ARRAY, 1);, +		this.arrType = arrType;, +		setResult(res);, +		addArg(size);, +	}, +, +	public ArgType getArrayType() {, +		return arrType;, +	}, +, +	@Override, +	public boolean isSame(InsnNode obj) {, +		if (this == obj) {, +			return true;, +		}, +		if (!(obj instanceof NewArrayNode) || !super.isSame(obj)) {, +			return false;, +		}, +		NewArrayNode other = (NewArrayNode) obj;, +		return arrType == other.arrType;, +	}, +, +	@Override, +	public String toString() {, +		return super.toString() + " type: " + arrType;, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, +				ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, +	public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				ArgType arrType = dex.getType(insn.getIndex());, +				return new NewArrayNode(arrType,, +						InsnArg.reg(insn, 0, arrType),, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/NewArrayNode.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.InsnNode;, +, +import org.jetbrains.annotations.NotNull;, +, +public class NewArrayNode extends InsnNode {, +, +	private final ArgType arrType;, +, +	public NewArrayNode(@NotNull ArgType arrType, RegisterArg res, InsnArg size) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +//		if (lz), +//			return "(" + str + ")";, +//		else, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +//		if (lz), +//			return "(" + str + ")";, +//		else, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import java.util.LinkedHashMap;, +		EncValueParser parser = new EncValueParser(dex, s);, +		if (readVisibility) {, +		}, +		Map<String, Object> values = new LinkedHashMap<String, Object>(size);, +			values.put(name, parser.parseValue());, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +//		if (lz), +//			return "(" + str + ")";, +//		else, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import java.util.LinkedHashMap;, +		EncValueParser parser = new EncValueParser(dex, s);, +		if (readVisibility) {, +		}, +		Map<String, Object> values = new LinkedHashMap<String, Object>(size);, +			values.put(name, parser.parseValue());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +		int argAndType = in.readByte() & 0xFF;, +		int type = argAndType & 0x1F;, +		int arg = (argAndType & 0xE0) >> 5;, +				return arg == 1;, +				return in.readByte();, +, +				return (short) parseNumber(size, true);, +				return (char) parseNumber(size, false);, +				return (int) parseNumber(size, true);, +				return parseNumber(size, true);, +				return Float.intBitsToFloat((int) parseNumber(size, false));, +				return Double.longBitsToDouble(parseNumber(size, false));, +				return dex.getString((int) parseNumber(size, false));, +				return dex.getType((int) parseNumber(size, false));, +				return MethodInfo.fromDex(dex, (int) parseNumber(size, false));, +				return FieldInfo.fromDex(dex, (int) parseNumber(size, false));, +	private long parseNumber(int byteCount, boolean isSignExtended) {, +		int shift = 8;, +		int first = in.readByte() & 0xFF;, +		if (isSignExtended && (first & 0x80) != 0) {, +			result = ~result << shift;, +		}, +		result |= (long) first;, +		for (int i = 1; i < byteCount; i++) {, +			result |= (long) (in.readByte() & 0xFF) << shift;, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +//		if (lz), +//			return "(" + str + ")";, +//		else, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import java.util.LinkedHashMap;, +		EncValueParser parser = new EncValueParser(dex, s);, +		if (readVisibility) {, +		}, +		Map<String, Object> values = new LinkedHashMap<String, Object>(size);, +			values.put(name, parser.parseValue());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +		int argAndType = in.readByte() & 0xFF;, +		int type = argAndType & 0x1F;, +		int arg = (argAndType & 0xE0) >> 5;, +				return arg == 1;, +				return in.readByte();, +, +				return (short) parseNumber(size, true);, +				return (char) parseNumber(size, false);, +				return (int) parseNumber(size, true);, +				return parseNumber(size, true);, +				return Float.intBitsToFloat((int) parseNumber(size, false));, +				return Double.longBitsToDouble(parseNumber(size, false));, +				return dex.getString((int) parseNumber(size, false));, +				return dex.getType((int) parseNumber(size, false));, +				return MethodInfo.fromDex(dex, (int) parseNumber(size, false));, +				return FieldInfo.fromDex(dex, (int) parseNumber(size, false));, +	private long parseNumber(int byteCount, boolean isSignExtended) {, +		int shift = 8;, +		int first = in.readByte() & 0xFF;, +		if (isSignExtended && (first & 0x80) != 0) {, +			result = ~result << shift;, +		}, +		result |= (long) first;, +		for (int i = 1; i < byteCount; i++) {, +			result |= (long) (in.readByte() & 0xFF) << shift;, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestAnnotations.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		List<ClassNode> classes = root.getClasses(true);, +		for (ClassNode cls : classes) {, +		}, +			Set<String> clsFullPaths = new HashSet<>(classes.size());, +			for (ClassNode cls : classes) {, +				ClassInfo clsInfo = cls.getClassInfo();, +				ClassInfo aliasClsInfo = clsInfo.getAlias();, +				if (!clsFullPaths.add(aliasClsInfo.getFullPath().toLowerCase())) {, +					String newFullName = aliasClsInfo.makeFullClsName(newShortName, true);, +, +					clsInfo.rename(root, newFullName);, +					clsFullPaths.add(clsInfo.getAlias().getFullPath().toLowerCase());]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.HashSet;, +import java.util.Set;, +	private Set<String> nsMapGenerated;, +		nsMapGenerated = new HashSet<>();, +			if(!nsMap.containsValue(attrName) && !nsMapGenerated.contains(attrName)) {, +				nsMapGenerated.add(attrName);]
[+++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.RegionUtils;, +			if (cls.getSuperClass() != null && !cls.getSuperClass().isObject()) {, +			} else {, +			}, +			MethodNode defCtr = cls.getDefaultConstructor();, +			if (RegionUtils.notEmpty(defCtr.getRegion())) {, +				defCtr.getAttributes().add(AttributeFlag.ANONYMOUS_CONSTRUCTOR);, +			} else {, +				defCtr.getAttributes().add(AttributeFlag.DONT_GENERATE);, +			}, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.RegionUtils;, +			if (cls.getSuperClass() != null && !cls.getSuperClass().isObject()) {, +			} else {, +			}, +			MethodNode defCtr = cls.getDefaultConstructor();, +			if (RegionUtils.notEmpty(defCtr.getRegion())) {, +				defCtr.getAttributes().add(AttributeFlag.ANONYMOUS_CONSTRUCTOR);, +			} else {, +				defCtr.getAttributes().add(AttributeFlag.DONT_GENERATE);, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +, +			code.attachAnnotation(mth);, +			return;, +		}, +		if (mth.getAttributes().contains(AttributeFlag.ANONYMOUS_CONSTRUCTOR)) {, +			// don't add method name and arguments, +			code.startLine();, +			code.attachAnnotation(mth);, +			return;, +		}, +		if (classGen.makeGenericMap(code, mth.getGenericMap())) {, +		}, +			if (args.size() == 2) {, +			} else if (args.size() > 2) {, +			} else {, +		}, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.RegionUtils;, +			if (cls.getSuperClass() != null && !cls.getSuperClass().isObject()) {, +			} else {, +			}, +			MethodNode defCtr = cls.getDefaultConstructor();, +			if (RegionUtils.notEmpty(defCtr.getRegion())) {, +				defCtr.getAttributes().add(AttributeFlag.ANONYMOUS_CONSTRUCTOR);, +			} else {, +				defCtr.getAttributes().add(AttributeFlag.DONT_GENERATE);, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +, +			code.attachAnnotation(mth);, +			return;, +		}, +		if (mth.getAttributes().contains(AttributeFlag.ANONYMOUS_CONSTRUCTOR)) {, +			// don't add method name and arguments, +			code.startLine();, +			code.attachAnnotation(mth);, +			return;, +		}, +		if (classGen.makeGenericMap(code, mth.getGenericMap())) {, +		}, +			if (args.size() == 2) {, +			} else if (args.size() > 2) {, +			} else {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +	ANONYMOUS_CONSTRUCTOR,, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.RegionUtils;, +			if (cls.getSuperClass() != null && !cls.getSuperClass().isObject()) {, +			} else {, +			}, +			MethodNode defCtr = cls.getDefaultConstructor();, +			if (RegionUtils.notEmpty(defCtr.getRegion())) {]
[+++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +	public boolean canThrowException() {, +		switch (getType()) {, +			case RETURN:, +			case IF:, +			case GOTO:, +			case MOVE:, +			case MOVE_EXCEPTION:, +			case NEG:, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +			case CMP_L:, +			case CMP_G:, +				return false;, +, +			default:, +				return true;, +		}, +	}, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +	public boolean canThrowException() {, +		switch (getType()) {, +			case RETURN:, +			case IF:, +			case GOTO:, +			case MOVE:, +			case MOVE_EXCEPTION:, +			case NEG:, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +			case CMP_L:, +			case CMP_G:, +				return false;, +, +			default:, +				return true;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			boolean tryBlockStarted = false;, +			InsnNode insn = null;, +				if (insn != null) {, +					if (tryBlockStarted) {, +					} else if (insn.canThrowException()) {, +						insn.add(AFlag.TRY_ENTER);, +						catchBlock.addInsn(insn);, +						tryBlockStarted = true;, +					}, +				}, +			} else if (insn != null) {, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +	public boolean canThrowException() {, +		switch (getType()) {, +			case RETURN:, +			case IF:, +			case GOTO:, +			case MOVE:, +			case MOVE_EXCEPTION:, +			case NEG:, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +			case CMP_L:, +			case CMP_G:, +				return false;, +, +			default:, +				return true;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			boolean tryBlockStarted = false;, +			InsnNode insn = null;, +				if (insn != null) {, +					if (tryBlockStarted) {, +					} else if (insn.canThrowException()) {, +						insn.add(AFlag.TRY_ENTER);, +						catchBlock.addInsn(insn);, +						tryBlockStarted = true;, +					}, +				}, +			} else if (insn != null) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +, +			// process instructions from field init, +			FieldInitAttr fieldInitAttr = fieldNode.get(AType.FIELD_INIT);]
[+++ b/.travis.yml, +before_install:, +    - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/.travis.yml, +before_install:, +    - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/build.gradle, +    gradleVersion = '1.9', +++ b/.travis.yml, +before_install:, +    - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/build.gradle, +    gradleVersion = '1.9', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +before_install:, +    - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/build.gradle, +    gradleVersion = '1.9', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.9-bin.zip]
[+++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +			addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +			addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +				SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +			addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +				SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java, +			cancelButton.addActionListener(e -> mainWindow.cancelBackgroundJobs());, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +			addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +				SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java, +			cancelButton.addActionListener(e -> mainWindow.cancelBackgroundJobs());, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java, +import java.awt.Dimension;, +import java.awt.Point;, +import java.awt.Rectangle;, +import java.awt.event.MouseAdapter;, +import java.awt.event.MouseEvent;, +, +import javax.swing.JPopupMenu;, +import javax.swing.JViewport;, +import javax.swing.SwingUtilities;, +		FindUsageAction findUsage = new FindUsageAction(contentPanel, this, jCls);, +		popup.addPopupMenuListener(findUsage);, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +			addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +				SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java, +			cancelButton.addActionListener(e -> mainWindow.cancelBackgroundJobs());, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java, +import java.awt.Dimension;, +import java.awt.Point;, +import java.awt.Rectangle;, +import java.awt.event.MouseAdapter;, +import java.awt.event.MouseEvent;, +, +import javax.swing.JPopupMenu;, +import javax.swing.JViewport;, +import javax.swing.SwingUtilities;, +		FindUsageAction findUsage = new FindUsageAction(contentPanel, this, jCls);, +		popup.addPopupMenuListener(findUsage);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/SearchBar.java, +	private ActionListener forwardListener = e -> search(0);, +		searchField.addActionListener(e -> search(1));, +		prevButton.addActionListener(e -> search(-1));, +		nextButton.addActionListener(e -> search(1));, +		markAllCB.addActionListener(forwardListener);, +		regexCB.addActionListener(forwardListener);, +		matchCaseCB.addActionListener(forwardListener);, +		wholeWordCB.addActionListener(forwardListener);, +		closeButton.addActionListener(e -> toggle());]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			if (RegionUtils.hasExitEdge(c)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			if (RegionUtils.hasExitEdge(c)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		LoopInfo loop = mth.getLoopForBlock(block);, +		BitSet outs = new BitSet(mth.getBasicBlocks().size());, +		outs.or(block.getDomFrontier());, +		for (BlockNode s : block.getCleanSuccessors()) {, +			outs.or(s.getDomFrontier());, +		}, +		stack.push(sw);, +		stack.addExits(BlockUtils.bitSetToBlocks(mth, outs));, +, +		// filter 'out' block, +		if (outs.cardinality() > 1) {, +			BlockUtils.cleanBitSet(mth, outs);, +		if (outs.cardinality() > 1) {, +			// filter loop start and successors of other blocks, +			for (int i = outs.nextSetBit(0); i >= 0; i = outs.nextSetBit(i + 1)) {, +				if (b.contains(AFlag.LOOP_START)) {, +					outs.clear(b.getId());, +				} else {, +						outs.clear(s.getId());, +			}, +		if (loop != null && outs.cardinality() > 1) {, +			outs.clear(loop.getEnd().getId());, +		}, +		if (outs.cardinality() == 0) {, +					outs.set(maybeOut.getId());, +		BlockNode out = null;, +		if (outs.cardinality() == 1) {, +			out = mth.getBasicBlocks().get(outs.nextSetBit(0));, +		} else if (loop == null && outs.cardinality() > 1) {, +			LOG.warn("Can't detect out node for switch block: {} in {}", block, mth);, +		}, +		if (loop != null) {, +			// check if 'continue' must be inserted, +			BlockNode end = loop.getEnd();, +			if (out != end && out != null) {, +				insertContinueInSwitch(block, out, end);, +			}, +	private static void insertContinueInSwitch(BlockNode block, BlockNode out, BlockNode end) {, +		int endId = end.getId();, +		for (BlockNode s : block.getCleanSuccessors()) {, +			if (s.getDomFrontier().get(endId) && s != out) {, +				// search predecessor of loop end on path from this successor, +				List<BlockNode> list = BlockUtils.collectBlocksDominatedBy(s, s);, +				for (BlockNode p : end.getPredecessors()) {, +					if (list.contains(p)) {, +						if (p.isSynthetic()) {, +							p.getInstructions().add(new InsnNode(InsnType.CONTINUE, 0));, +						}, +						break;, +					}, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			if (RegionUtils.hasExitEdge(c)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		LoopInfo loop = mth.getLoopForBlock(block);, +		BitSet outs = new BitSet(mth.getBasicBlocks().size());, +		outs.or(block.getDomFrontier());, +		for (BlockNode s : block.getCleanSuccessors()) {, +			outs.or(s.getDomFrontier());, +		}, +		stack.push(sw);, +		stack.addExits(BlockUtils.bitSetToBlocks(mth, outs));, +, +		// filter 'out' block, +		if (outs.cardinality() > 1) {, +			BlockUtils.cleanBitSet(mth, outs);, +		if (outs.cardinality() > 1) {, +			// filter loop start and successors of other blocks, +			for (int i = outs.nextSetBit(0); i >= 0; i = outs.nextSetBit(i + 1)) {, +				if (b.contains(AFlag.LOOP_START)) {, +					outs.clear(b.getId());, +				} else {, +						outs.clear(s.getId());, +			}, +		if (loop != null && outs.cardinality() > 1) {, +			outs.clear(loop.getEnd().getId());, +		}, +		if (outs.cardinality() == 0) {, +					outs.set(maybeOut.getId());, +		BlockNode out = null;, +		if (outs.cardinality() == 1) {, +			out = mth.getBasicBlocks().get(outs.nextSetBit(0));, +		} else if (loop == null && outs.cardinality() > 1) {, +			LOG.warn("Can't detect out node for switch block: {} in {}", block, mth);, +		}, +		if (loop != null) {, +			// check if 'continue' must be inserted, +			BlockNode end = loop.getEnd();, +			if (out != end && out != null) {, +				insertContinueInSwitch(block, out, end);, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			warns.forEach(warn -> code.startLine("/* JADX WARNING: ").addMultiLine(warn.getWarn()).add(" */"));]
[+++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					|| innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					|| innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					|| innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ANONYMOUS_CLASS,, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					|| innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ANONYMOUS_CLASS,, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public ClassInfo getTopParentClass() {, +		if (parentClass != null) {, +			ClassInfo topCls = parentClass.getTopParentClass();, +			return topCls != null ? topCls : parentClass;, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					|| innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ANONYMOUS_CLASS,, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public ClassInfo getTopParentClass() {, +		if (parentClass != null) {, +			ClassInfo topCls = parentClass.getTopParentClass();, +			return topCls != null ? topCls : parentClass;, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			ClassInfo parentClass = clsInfo.getTopParentClass();, +			if (parentClass != null && fileName.equals(parentClass.getShortName())) {, +				return;, +			}, +				&& clsInfo.getAlias().getShortName().startsWith(Consts.ANONYMOUS_CLASS_PREFIX), +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					|| innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +			if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ANONYMOUS_CLASS,, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public ClassInfo getTopParentClass() {, +		if (parentClass != null) {, +			ClassInfo topCls = parentClass.getTopParentClass();, +			return topCls != null ? topCls : parentClass;, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			ClassInfo parentClass = clsInfo.getTopParentClass();, +			if (parentClass != null && fileName.equals(parentClass.getShortName())) {, +				return;, +			}, +				&& clsInfo.getAlias().getShortName().startsWith(Consts.ANONYMOUS_CLASS_PREFIX), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +, +		markAnonymousClass(cls);, +	private void markAnonymousClass(ClassNode cls) {, +		if (cls.isAnonymous()) {, +			cls.add(AFlag.ANONYMOUS_CLASS);, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EdgeInsnAttr;, +	public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<AttrList<EdgeInsnAttr>>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EdgeInsnAttr;, +	public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<AttrList<EdgeInsnAttr>>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EdgeInsnAttr.java, +package jadx.core.dex.attributes.nodes;, +, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttribute;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +, +public class EdgeInsnAttr implements IAttribute {, +, +	private final BlockNode start;, +	private final BlockNode end;, +	private final InsnNode insn;, +, +	public static void addEdgeInsn(BlockNode start, BlockNode end, InsnNode insn) {, +		EdgeInsnAttr edgeInsnAttr = new EdgeInsnAttr(start, end, insn);, +		start.addAttr(AType.EDGE_INSN, edgeInsnAttr);, +		end.addAttr(AType.EDGE_INSN, edgeInsnAttr);, +	}, +, +	public EdgeInsnAttr(BlockNode start, BlockNode end, InsnNode insn) {, +		this.start = start;, +		this.end = end;, +		this.insn = insn;, +	}, +, +	@Override, +	public AType<AttrList<EdgeInsnAttr>> getType() {, +		return AType.EDGE_INSN;, +	}, +, +	public BlockNode getStart() {, +		return start;, +	}, +, +	public BlockNode getEnd() {, +		return end;, +	}, +, +	public InsnNode getInsn() {, +		return insn;, +	}, +, +	@Override, +	public String toString() {, +		return "EDGE_INSN: " + start + "->" + end + " " + insn;, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EdgeInsnAttr;, +	public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<AttrList<EdgeInsnAttr>>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EdgeInsnAttr.java, +package jadx.core.dex.attributes.nodes;, +, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttribute;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +, +public class EdgeInsnAttr implements IAttribute {, +, +	private final BlockNode start;, +	private final BlockNode end;, +	private final InsnNode insn;, +, +	public static void addEdgeInsn(BlockNode start, BlockNode end, InsnNode insn) {, +		EdgeInsnAttr edgeInsnAttr = new EdgeInsnAttr(start, end, insn);, +		start.addAttr(AType.EDGE_INSN, edgeInsnAttr);, +		end.addAttr(AType.EDGE_INSN, edgeInsnAttr);, +	}, +, +	public EdgeInsnAttr(BlockNode start, BlockNode end, InsnNode insn) {, +		this.start = start;, +		this.end = end;, +		this.insn = insn;, +	}, +, +	@Override, +	public AType<AttrList<EdgeInsnAttr>> getType() {, +		return AType.EDGE_INSN;, +	}, +, +	public BlockNode getStart() {, +		return start;, +	}, +, +	public BlockNode getEnd() {, +		return end;, +	}, +, +	public InsnNode getInsn() {, +		return insn;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +			} else {, +				return currentIf;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +			} else {, +				return currentIf;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +			return removeRedundantElseBlock(mth, (IfRegion) region);, +	private static boolean removeRedundantElseBlock(MethodNode mth, IfRegion ifRegion) {, +		if (ifRegion.getElseRegion() == null, +				|| ifRegion.contains(AFlag.ELSE_IF_CHAIN), +				|| ifRegion.getElseRegion().contains(AFlag.ELSE_IF_CHAIN)) {, +			return false;, +		}, +		if (!hasBranchTerminator(ifRegion.getThenRegion())) {, +			return false;, +		}, +		// code style check:, +		// will remove 'return;' from 'then' and 'else' with one instruction, +		// see #jadx.tests.integration.conditions.TestConditions9, +		if (mth.getReturnType() == ArgType.VOID, +				&& insnsCount(ifRegion.getThenRegion()) == 2, +				&& insnsCount(ifRegion.getElseRegion()) == 2) {, +			return false;, +		}, +	private static boolean hasBranchTerminator(IContainer region) {, +		return RegionUtils.hasExitBlock(region), +				|| RegionUtils.hasBreakInsn(region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +			} else {, +				return currentIf;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +			return removeRedundantElseBlock(mth, (IfRegion) region);, +	private static boolean removeRedundantElseBlock(MethodNode mth, IfRegion ifRegion) {, +		if (ifRegion.getElseRegion() == null, +				|| ifRegion.contains(AFlag.ELSE_IF_CHAIN), +				|| ifRegion.getElseRegion().contains(AFlag.ELSE_IF_CHAIN)) {, +			return false;, +		}, +		if (!hasBranchTerminator(ifRegion.getThenRegion())) {, +			return false;, +		}, +		// code style check:, +		// will remove 'return;' from 'then' and 'else' with one instruction, +		// see #jadx.tests.integration.conditions.TestConditions9, +		if (mth.getReturnType() == ArgType.VOID, +				&& insnsCount(ifRegion.getThenRegion()) == 2, +				&& insnsCount(ifRegion.getElseRegion()) == 2) {, +			return false;, +		}, +	private static boolean hasBranchTerminator(IContainer region) {, +		return RegionUtils.hasExitBlock(region), +				|| RegionUtils.hasBreakInsn(region);, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestNestedIf2.java, +package jadx.tests.integration.conditions;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestNestedIf2 extends IntegrationTest {, +, +	public static class TestCls {, +		static int executedCount = 0;, +		static boolean finished = false;, +		static int repeatCount = 2;, +, +		static boolean test(float delta, Object object) {, +			if (executedCount != repeatCount && isRun(delta, object)) {, +				if (finished) {, +					return true;, +				}, +				if (repeatCount == -1) {, +					++executedCount;, +					action();, +					return false;, +				}, +				++executedCount;, +				if (executedCount >= repeatCount) {, +					return true;, +				}, +				action();, +			}, +			return false;, +		}, +, +		public static void action() {, +		}, +, +		public static boolean isRun(float delta, Object object) {, +			return delta == 0;, +		}, +	}, +]
[+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java, +package jadx.tests.integration.trycatch;, +, +import java.io.FileInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestTryAfterDeclaration extends IntegrationTest {, +, +	static class TestClass {, +		public static void consume() throws IOException {, +			InputStream bis = null;, +			try {, +				bis = new FileInputStream("1.txt");, +				while (bis != null) {, +					System.out.println("c");, +				}, +			} catch (final IOException e) {, +			}, +		}, +	}, +, +	/**, +	 * Issue #62., +	 */, +	@Test, +	@NotYetImplemented, +	public void test62() {, +		ClassNode cls = getClassNode(TestClass.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("try {"));, +	}, +}, +, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java, +package jadx.tests.integration.trycatch;, +, +import java.io.FileInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestTryAfterDeclaration extends IntegrationTest {, +, +	static class TestClass {, +		public static void consume() throws IOException {, +			InputStream bis = null;, +			try {, +				bis = new FileInputStream("1.txt");, +				while (bis != null) {, +					System.out.println("c");, +				}, +			} catch (final IOException e) {, +			}, +		}, +	}, +, +	/**, +	 * Issue #62., +	 */, +	@Test, +	@NotYetImplemented, +	public void test62() {, +		ClassNode cls = getClassNode(TestClass.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("try {"));, +	}, +}, +, +, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java, +package jadx.tests.integration.trycatch;, +, +import java.io.FileInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +import org.junit.jupiter.api.Test;, +]
[+++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, +	@Test, +++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, +	@Test, +++ b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +public class TypeMergeTest {, +	@Before, +	public void initClsp() throws IOException, DecodeException {, +	@Test, +++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, +	@Test, +++ b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +public class TypeMergeTest {, +	@Before, +	public void initClsp() throws IOException, DecodeException {, +	@Test, +++ b/jadx-samples/src/main/java/jadx/samples/TestEnum.java, +	}, +	}, +, +	public String testEnumSwitch(final Direction color) {, +		String d;, +		switch (color) {, +			case NORTH:, +				d = "N";, +				break;, +			case SOUTH:, +				d = "S";, +				break;, +			default:, +				d = "<>";, +				break;, +		}, +		return d;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, +	@Test, +++ b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +public class TypeMergeTest {, +	@Before, +	public void initClsp() throws IOException, DecodeException {, +	@Test, +++ b/jadx-samples/src/main/java/jadx/samples/TestEnum.java, +	}, +	}, +, +	public String testEnumSwitch(final Direction color) {, +		String d;, +		switch (color) {, +			case NORTH:, +				d = "N";, +				break;, +			case SOUTH:, +				d = "S";, +				break;, +			default:, +				d = "<>";, +				break;, +		}, +		return d;, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +				if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +				if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java, +		StringBuffer buf = new StringBuffer(bytes.length * 3);]
[+++ b/README.md, +    ./gradlew clean build, +    bin/jadx -d out lib/jadx-core-*.jar, +    #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/README.md, +    ./gradlew clean build, +    bin/jadx -d out lib/jadx-core-*.jar, +    #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, +        mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts (type: Sync, dependsOn: ['jadx-cli:installApp', 'jadx-gui:installApp']) {, +task build (dependsOn: pack) {, +    description = 'Build jadx distribution zip', +}, +, +++ b/README.md, +    ./gradlew clean build, +    bin/jadx -d out lib/jadx-core-*.jar, +    #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, +        mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts (type: Sync, dependsOn: ['jadx-cli:installApp', 'jadx-gui:installApp']) {, +task build (dependsOn: pack) {, +    description = 'Build jadx distribution zip', +}, +, +++ b/jadx-cli/build.gradle, +mainClassName = 'jadx.cli.JadxCLI', +applicationName = 'jadx', +    compile(project(':jadx-core')), +++ b/README.md, +    ./gradlew clean build, +    bin/jadx -d out lib/jadx-core-*.jar, +    #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, +        mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts (type: Sync, dependsOn: ['jadx-cli:installApp', 'jadx-gui:installApp']) {, +task build (dependsOn: pack) {, +    description = 'Build jadx distribution zip', +}, +, +++ b/jadx-cli/build.gradle, +mainClassName = 'jadx.cli.JadxCLI', +applicationName = 'jadx', +    compile(project(':jadx-core')), +++ b/jadx-cli/src/main/java/jadx/cli/JadxArgs.java, +			printUsage();, +				throw new JadxException("Please specify input file");, +		if (input.size() > 1) {, +			throw new JadxException("Only one input file is supported");, +		}, +		out.println();, +++ b/README.md, +    ./gradlew clean build, +    bin/jadx -d out lib/jadx-core-*.jar, +    #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, +        mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts (type: Sync, dependsOn: ['jadx-cli:installApp', 'jadx-gui:installApp']) {, +task build (dependsOn: pack) {, +    description = 'Build jadx distribution zip', +}, +, +++ b/jadx-cli/build.gradle, +mainClassName = 'jadx.cli.JadxCLI', +applicationName = 'jadx', +    compile(project(':jadx-core')), +++ b/jadx-cli/src/main/java/jadx/cli/JadxArgs.java, +			printUsage();, +				throw new JadxException("Please specify input file");, +		if (input.size() > 1) {, +			throw new JadxException("Only one input file is supported");, +		}, +		out.println();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/README.md, +    ./gradlew clean build, +    bin/jadx -d out lib/jadx-core-*.jar, +    #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, +        mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts (type: Sync, dependsOn: ['jadx-cli:installApp', 'jadx-gui:installApp']) {, +task build (dependsOn: pack) {, +    description = 'Build jadx distribution zip', +}, +, +++ b/jadx-cli/build.gradle, +mainClassName = 'jadx.cli.JadxCLI', +applicationName = 'jadx', +    compile(project(':jadx-core')), +++ b/jadx-cli/src/main/java/jadx/cli/JadxArgs.java, +			printUsage();, +				throw new JadxException("Please specify input file");, +		if (input.size() > 1) {]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +		if (!isLastEnd) {, +			isLastEnd = true;, +			writer.add(">");, +		}, +		String escapedStr = StringUtils.escapeXML(str);, +		writer.add(escapedStr);, +//			if (elementNS != -1) {, +//				writer.add(getString(elementNS)).add(':');, +//			}]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +			long size;, +			ZipRef zipRef = rf.getZipRef();, +			if (zipRef == null) {, +				File file = new File(rf.getName());, +				inputStream = new BufferedInputStream(new FileInputStream(file));, +				size = file.length();, +			} else {, +				size = entry.getSize();, +			}, +			result = decoder.decode(size, inputStream);, +			throw new JadxException("Error decode: " + rf.getName(), e);, +				LOG.error("Error close zip file: {}", rf.getName(), e);, +			addResourceFile(list, file);, +	private void addResourceFile(List<ResourceFile> list, File file) {, +		String name = file.getAbsolutePath();, +		ResourceType type = ResourceType.getFileType(name);, +		ResourceFile rf = new ResourceFile(jadxRef, name, type);, +		list.add(rf);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +			long size;, +			ZipRef zipRef = rf.getZipRef();, +			if (zipRef == null) {, +				File file = new File(rf.getName());, +				inputStream = new BufferedInputStream(new FileInputStream(file));, +				size = file.length();, +			} else {, +				size = entry.getSize();, +			}, +			result = decoder.decode(size, inputStream);, +			throw new JadxException("Error decode: " + rf.getName(), e);, +				LOG.error("Error close zip file: {}", rf.getName(), e);, +			addResourceFile(list, file);, +	private void addResourceFile(List<ResourceFile> list, File file) {, +		String name = file.getAbsolutePath();, +		ResourceType type = ResourceType.getFileType(name);, +		ResourceFile rf = new ResourceFile(jadxRef, name, type);, +		list.add(rf);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import jadx.core.dex.nodes.DexNode;, +import java.util.List;, +		List<DexNode> dexNodes = root.getDexNodes();, +		if (dexNodes.size() == 0) {, +			return;, +		}, +		InputFile firstInputFile = dexNodes.get(0).getDexFile().getInputFile();, +		deobfuscator = new Deobfuscator(args, dexNodes, deobfMapFile);, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, +	public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +			long size;, +			ZipRef zipRef = rf.getZipRef();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +				&& Objects.equals(result, other.result)]
[+++ b/.travis.yml, +cache:, +    directories:, +        - $HOME/.gradle, +, +++ b/.travis.yml, +cache:, +    directories:, +        - $HOME/.gradle, +, +++ b/settings.gradle, +include 'jadx-core', +include 'jadx-cli', +include 'jadx-gui', +include 'jadx-samples']
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +		if (!(obj instanceof LineAttrNode)) {, +			return null;, +		}, +		clsNode = clsNode.getTopParentClass();, +		if (defLine == 0) {, +		return new CodePosition(jCls, defLine, 0);, +	}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +		if (!(obj instanceof LineAttrNode)) {, +			return null;, +		}, +		clsNode = clsNode.getTopParentClass();, +		if (defLine == 0) {, +		return new CodePosition(jCls, defLine, 0);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +	public ClassNode getTopParentClass() {, +		ClassNode parent = getParentClass();, +		return parent == this ? this : parent.getParentClass();, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java, +		@SuppressWarnings("null"), +		public int test() {, +		public int test2(int a) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java, +		@SuppressWarnings("null"), +		public int test() {, +		public int test2(int a) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java, +		public int vp;, +		public void test(byte[] buffer) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java, +		@SuppressWarnings("null"), +		public int test() {, +		public int test2(int a) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java, +		public int vp;, +		public void test(byte[] buffer) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java, +		@SuppressWarnings("null"), +		public int test() {, +		public int test2(int a) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java, +		public int vp;, +		public void test(byte[] buffer) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestLineNumbers2.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics2.java, +		public static class ItemReference<V> extends WeakReference<V> {, +			public Object id;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +	 * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +	@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import java.util.Objects;, +				if (callMth.getArgsCount() != mth.getMethodInfo().getArgsCount()) {, +					return false;, +				}, +				if (Objects.equals(wrappedMth.getAlias(), alias)) {, +					return true;, +				if (!wrappedMth.isVirtual()) {, +					return false;, +				}, +				wrappedMth.getMethodInfo().setAlias(alias);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dex.Code;, +import com.android.dx.io.OpcodeInfo;, +import com.android.dx.io.Opcodes;, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.android.dx.io.instructions.FillArrayDataPayloadDecodedInstruction;, +import com.android.dx.io.instructions.PackedSwitchPayloadDecodedInstruction;, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +import com.android.dx.io.instructions.SparseSwitchPayloadDecodedInstruction;, +import org.jetbrains.annotations.NotNull;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(InsnDecoder.class);, +				decoded[in.cursor()] = decodeRawInsn(in);, +			throw new DecodeException(method, e.getMessage(), e);, +	private DecodedInstruction decodeRawInsn(ShortArrayCodeInput in) throws EOFException {, +		int opcodeUnit = in.read();, +		int opcode = Opcodes.extractOpcodeFromUnit(opcodeUnit);, +		OpcodeInfo.Info opcodeInfo;, +		try {, +			opcodeInfo = OpcodeInfo.get(opcode);, +		} catch (IllegalArgumentException e) {, +			LOG.warn("Ignore decode error: '{}', replace with NOP instruction", e.getMessage());, +			opcodeInfo = OpcodeInfo.NOP;, +		}, +		return opcodeInfo.getFormat().decode(opcodeUnit, in);, +	}, +, +	@NotNull, +				return new InsnNode(InsnType.NOP, 0);, +			default:, +	}]
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +		CodeWriter code = cls.getCode();, +		if (code == null) {, +			return Collections.emptyMap();, +		}, +		return code.getAnnotations();]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import java.net.URL;, +import jadx.gui.utils.Utils;, +		URL logoURL = getClass().getResource("/logos/jadx-logo-48px.png");, +		Icon logo = new ImageIcon(logoURL, "jadx logo");, +, +		JLabel name = new JLabel("jadx", logo, SwingConstants.CENTER);, +		JLabel version = new JLabel("jadx version: " + JadxDecompiler.getVersion());, +		String javaVm = System.getProperty("java.vm.name");, +		String javaVer = System.getProperty("java.vm.version");, +, +		javaVm = javaVm == null ? "" : javaVm;, +, +		JLabel javaVmLabel = new JLabel("Java VM: " + javaVm);, +		javaVmLabel.setFont(font);, +		javaVmLabel.setAlignmentX(0.5f);, +, +		javaVer = javaVer == null ? "" : javaVer;, +		JLabel javaVerLabel = new JLabel("Java version: " + javaVer);, +		javaVerLabel.setFont(font);, +		javaVerLabel.setAlignmentX(0.5f);, +, +		textPane.add(javaVmLabel);, +		textPane.add(javaVerLabel);, +		textPane.add(Box.createRigidArea(new Dimension(0, 20)));, +		Utils.setWindowIcons(this);, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import java.net.URL;, +import jadx.gui.utils.Utils;, +		URL logoURL = getClass().getResource("/logos/jadx-logo-48px.png");, +		Icon logo = new ImageIcon(logoURL, "jadx logo");, +, +		JLabel name = new JLabel("jadx", logo, SwingConstants.CENTER);, +		JLabel version = new JLabel("jadx version: " + JadxDecompiler.getVersion());, +		String javaVm = System.getProperty("java.vm.name");, +		String javaVer = System.getProperty("java.vm.version");, +, +		javaVm = javaVm == null ? "" : javaVm;, +, +		JLabel javaVmLabel = new JLabel("Java VM: " + javaVm);, +		javaVmLabel.setFont(font);, +		javaVmLabel.setAlignmentX(0.5f);, +, +		javaVer = javaVer == null ? "" : javaVer;, +		JLabel javaVerLabel = new JLabel("Java version: " + javaVer);, +		javaVerLabel.setFont(font);, +		javaVerLabel.setAlignmentX(0.5f);, +, +		textPane.add(javaVmLabel);, +		textPane.add(javaVerLabel);, +		textPane.add(Box.createRigidArea(new Dimension(0, 20)));, +		Utils.setWindowIcons(this);, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +	private static final ImageIcon ICON_JADX = Utils.openIcon("jadx-logo");, +		Utils.setWindowIcons(this);, +		Action aboutAction = new AbstractAction(NLS.str("menu.about"), ICON_JADX) {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import java.net.URL;, +import jadx.gui.utils.Utils;, +		URL logoURL = getClass().getResource("/logos/jadx-logo-48px.png");, +		Icon logo = new ImageIcon(logoURL, "jadx logo");, +, +		JLabel name = new JLabel("jadx", logo, SwingConstants.CENTER);, +		JLabel version = new JLabel("jadx version: " + JadxDecompiler.getVersion());, +		String javaVm = System.getProperty("java.vm.name");, +		String javaVer = System.getProperty("java.vm.version");, +, +		javaVm = javaVm == null ? "" : javaVm;, +, +		JLabel javaVmLabel = new JLabel("Java VM: " + javaVm);, +		javaVmLabel.setFont(font);, +		javaVmLabel.setAlignmentX(0.5f);, +, +		javaVer = javaVer == null ? "" : javaVer;, +		JLabel javaVerLabel = new JLabel("Java version: " + javaVer);, +		javaVerLabel.setFont(font);, +		javaVerLabel.setAlignmentX(0.5f);, +, +		textPane.add(javaVmLabel);, +		textPane.add(javaVerLabel);, +		textPane.add(Box.createRigidArea(new Dimension(0, 20)));, +		Utils.setWindowIcons(this);, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +	private static final ImageIcon ICON_JADX = Utils.openIcon("jadx-logo");, +		Utils.setWindowIcons(this);, +		Action aboutAction = new AbstractAction(NLS.str("menu.about"), ICON_JADX) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +import java.util.ArrayList;, +import java.util.List;, +, +	public static void setWindowIcons(Window window) {, +		List<Image> icons = new ArrayList<>();, +		icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo.png"));, +		window.setIconImages(icons);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +@JadxVisitor(, +		name = "ClassModifier",, +		desc = "Remove synthetic classes, methods and fields",, +		runAfter = ModVisitor.class, +), +				continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +@JadxVisitor(, +		name = "ClassModifier",, +		desc = "Remove synthetic classes, methods and fields",, +		runAfter = ModVisitor.class, +), +				continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/JadxVisitor.java, +package jadx.core.dex.visitors;, +, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +, +/**, + * Annotation for describe dependencies of jadx visitors, + */, +@Retention(RetentionPolicy.RUNTIME), +@Target(ElementType.TYPE), +public @interface JadxVisitor {, +	/**, +	 * Visitor short name (identifier), +	 */, +	String name();, +, +	/**, +	 * Detailed visitor description, +	 */, +	String desc() default "";, +, +	/**, +	 * This visitor must be run <b>after</b> listed visitors, +	 */, +	Class<? extends IDexTreeVisitor>[] runAfter() default {};, +, +	/**, +	 * This visitor must be run <b>before</b> listed visitors, +	 */, +	Class<? extends IDexTreeVisitor>[] runBefore() default {};, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +@JadxVisitor(, +		name = "ClassModifier",, +		desc = "Remove synthetic classes, methods and fields",, +		runAfter = ModVisitor.class, +), +				continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/JadxVisitor.java, +package jadx.core.dex.visitors;, +, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +, +/**, + * Annotation for describe dependencies of jadx visitors, + */, +@Retention(RetentionPolicy.RUNTIME), +@Target(ElementType.TYPE), +public @interface JadxVisitor {, +	/**, +	 * Visitor short name (identifier), +	 */, +	String name();, +, +	/**, +	 * Detailed visitor description, +	 */, +	String desc() default "";, +, +	/**, +	 * This visitor must be run <b>after</b> listed visitors, +	 */, +	Class<? extends IDexTreeVisitor>[] runAfter() default {};, +, +	/**, +	 * This visitor must be run <b>before</b> listed visitors, +	 */, +	Class<? extends IDexTreeVisitor>[] runBefore() default {};, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +@JadxVisitor(, +		name = "ReSugarCode",, +		desc = "Simplify synthetic or verbose code",, +		runAfter = CodeShrinker.class, +), +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +@JadxVisitor(, +		name = "ClassModifier",, +		desc = "Remove synthetic classes, methods and fields",]
[+++ b/README.md, +     --deobf-use-sourcename - use source file name as class name alias, +     --escape-unicode       - escape non latin characters in strings (with \u), +++ b/README.md, +     --deobf-use-sourcename - use source file name as class name alias, +     --escape-unicode       - escape non latin characters in strings (with \u), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +	@Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), +	protected boolean escapeUnicode = false;, +, +				Appender<ILoggingEvent> appender = rootLogger.getAppender("STDOUT");, +				if (appender != null) {, +					appender.clearAllFilters();, +				}, +, +	@Override, +	public boolean escapeUnicode() {, +		return escapeUnicode;, +	}, +++ b/README.md, +     --deobf-use-sourcename - use source file name as class name alias, +     --escape-unicode       - escape non latin characters in strings (with \u), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +	@Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), +	protected boolean escapeUnicode = false;, +, +				Appender<ILoggingEvent> appender = rootLogger.getAppender("STDOUT");, +				if (appender != null) {, +					appender.clearAllFilters();, +				}, +, +	@Override, +	public boolean escapeUnicode() {, +		return escapeUnicode;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean escapeUnicode();, +++ b/README.md, +     --deobf-use-sourcename - use source file name as class name alias, +     --escape-unicode       - escape non latin characters in strings (with \u), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +	@Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), +	protected boolean escapeUnicode = false;, +, +				Appender<ILoggingEvent> appender = rootLogger.getAppender("STDOUT");, +				if (appender != null) {, +					appender.clearAllFilters();, +				}, +, +	@Override, +	public boolean escapeUnicode() {, +		return escapeUnicode;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean escapeUnicode();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean escapeUnicode = false;, +, +, +	@Override, +	public boolean escapeUnicode() {, +		return escapeUnicode;, +	}, +, +	public void setEscapeUnicode(boolean escapeUnicode) {, +		this.escapeUnicode = escapeUnicode;, +	}, +++ b/README.md, +     --deobf-use-sourcename - use source file name as class name alias, +     --escape-unicode       - escape non latin characters in strings (with \u), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +	@Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), +	protected boolean escapeUnicode = false;, +, +				Appender<ILoggingEvent> appender = rootLogger.getAppender("STDOUT");, +				if (appender != null) {, +					appender.clearAllFilters();, +				}, +, +	@Override, +	public boolean escapeUnicode() {, +		return escapeUnicode;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean escapeUnicode();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean escapeUnicode = false;, +, +]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments == null || arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		if (deobfMapFile.exists() && !args.isDeobfuscationForceSave()) {, +		LOG.info("Loading obfuscation map from: {}", deobfMapFile.getAbsoluteFile());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		if (deobfMapFile.exists() && !args.isDeobfuscationForceSave()) {, +		LOG.info("Loading obfuscation map from: {}", deobfMapFile.getAbsoluteFile());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.settings.JadxSettings;, +import jadx.gui.settings.JadxSettingsAdapter;, +			final JadxSettings jadxArgs = JadxSettingsAdapter.load();, +			// overwrite loaded settings by command line arguments, +					MainWindow window = new MainWindow(jadxArgs);, +					window.open();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		if (deobfMapFile.exists() && !args.isDeobfuscationForceSave()) {, +		LOG.info("Loading obfuscation map from: {}", deobfMapFile.getAbsoluteFile());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.settings.JadxSettings;, +import jadx.gui.settings.JadxSettingsAdapter;, +			final JadxSettings jadxArgs = JadxSettingsAdapter.load();, +			// overwrite loaded settings by command line arguments, +					MainWindow window = new MainWindow(jadxArgs);, +					window.open();, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +package jadx.gui.settings;, +, +import jadx.cli.JadxCLIArgs;, +, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +public class JadxSettings extends JadxCLIArgs {, +, +	private static final String USER_HOME = System.getProperty("user.home");, +	private static final int RECENT_FILES_COUNT = 15;, +, +	static final Set<String> SKIP_FIELDS = new HashSet<String>(Arrays.asList(, +			"files", "input", "outputDir", "printHelp", +	));, +, +	private String lastOpenFilePath = USER_HOME;, +	private String lastSaveFilePath = USER_HOME;, +	private boolean flattenPackage = false;, +	private boolean checkForUpdates = true;, +	private List<String> recentFiles = new ArrayList<String>();, +, +	public void sync() {, +		JadxSettingsAdapter.store(this);, +	}, +, +	public String getLastOpenFilePath() {, +		return lastOpenFilePath;, +	}, +, +	public void setLastOpenFilePath(String lastOpenFilePath) {, +		this.lastOpenFilePath = lastOpenFilePath;, +		sync();, +	}, +, +	public String getLastSaveFilePath() {, +		return lastSaveFilePath;, +	}, +, +	public void setLastSaveFilePath(String lastSaveFilePath) {, +		this.lastSaveFilePath = lastSaveFilePath;, +		sync();, +	}, +, +	public boolean isFlattenPackage() {, +		return flattenPackage;, +	}, +, +	public void setFlattenPackage(boolean flattenPackage) {, +		this.flattenPackage = flattenPackage;, +		sync();, +	}, +, +	public boolean isCheckForUpdates() {, +		return checkForUpdates;, +	}, +, +	public void setCheckForUpdates(boolean checkForUpdates) {, +		this.checkForUpdates = checkForUpdates;, +		sync();, +	}, +, +	public Iterable<String> getRecentFiles() {, +		return recentFiles;, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return name.equals(fieldInfo.name), +				&& type.equals(fieldInfo.type), +				&& declClass.equals(fieldInfo.declClass);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return name.equals(fieldInfo.name), +				&& type.equals(fieldInfo.type), +				&& declClass.equals(fieldInfo.declClass);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import org.jetbrains.annotations.TestOnly;, +		return searchField(FieldInfo.fromDex(dex, id));, +	}, +, +	public FieldNode searchField(FieldInfo field) {, +			if (f.getFieldInfo().equals(field)) {, +	@TestOnly]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java, +		if(ext.equals("arsc")) {, +			return SyntaxConstants.SYNTAX_STYLE_XML;, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		HashSet<BlockNode> visited = new HashSet<BlockNode>();, +		collectWhileDominates(dominator, start, result, visited);, +	private static void collectWhileDominates(BlockNode dominator, BlockNode child, List<BlockNode> result, HashSet<BlockNode> visited) {, +		if (visited.contains(child)) return;, +		visited.add(child);, +				collectWhileDominates(dominator, node, result, visited);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +					BlockNode source = edge.getSource();, +					if (!target.contains(AFlag.SYNTHETIC) && !source.contains(AFlag.SYNTHETIC)) {, +						BlockSplitter.insertBlockBetween(mth, source, target);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +					BlockNode source = edge.getSource();, +					if (!target.contains(AFlag.SYNTHETIC) && !source.contains(AFlag.SYNTHETIC)) {, +						BlockSplitter.insertBlockBetween(mth, source, target);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +							|| insn.contains(AType.EXC_HANDLER)]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			if (mth.isDefaultConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			if (mth.isDefaultConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	, +	public boolean isDefaultConstructor() {, +		boolean result = false;, +, +		if (accFlags.isConstructor() && mthInfo.isConstructor()) {, +			int defaultArgCount = 0;, +, +			/** workaround for non-static inner class constructor, that has, +			 * synthetic argument */, +			if ((parentClass != null) && parentClass.getClassInfo().isInner()) {, +				if (!parentClass.getAccessFlags().isStatic()) {, +					ClassNode outerCls = parentClass.getParentClass();, +					if ((argsList != null) && (argsList.size() >= 1)) {, +						if (argsList.get(0).getType().equals(outerCls.getClassInfo().getType())) {, +							defaultArgCount = 1;, +						}, +					}, +				}, +			}, +, +			result = (argsList == null) || (argsList.size() == defaultArgCount);, +		}, +, +		return result;, +	} , +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			if (mth.isDefaultConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	, +	public boolean isDefaultConstructor() {, +		boolean result = false;, +, +		if (accFlags.isConstructor() && mthInfo.isConstructor()) {, +			int defaultArgCount = 0;, +, +			/** workaround for non-static inner class constructor, that has, +			 * synthetic argument */, +			if ((parentClass != null) && parentClass.getClassInfo().isInner()) {, +				if (!parentClass.getAccessFlags().isStatic()) {, +					ClassNode outerCls = parentClass.getParentClass();, +					if ((argsList != null) && (argsList.size() >= 1)) {, +						if (argsList.get(0).getType().equals(outerCls.getClassInfo().getType())) {, +							defaultArgCount = 1;, +						}, +					}, +				}, +			}, +, +			result = (argsList == null) || (argsList.size() == defaultArgCount);, +		}, +, +		return result;, +	} , +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +, +							// remove super() call in instance initializer, +							if (parentClass.isAnonymous() && mth.isDefaultConstructor() && co.isSuper()) {, +								remove = true;, +							} , +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			if (mth.isDefaultConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	, +	public boolean isDefaultConstructor() {, +		boolean result = false;, +, +		if (accFlags.isConstructor() && mthInfo.isConstructor()) {, +			int defaultArgCount = 0;, +, +			/** workaround for non-static inner class constructor, that has, +			 * synthetic argument */, +			if ((parentClass != null) && parentClass.getClassInfo().isInner()) {, +				if (!parentClass.getAccessFlags().isStatic()) {, +					ClassNode outerCls = parentClass.getParentClass();, +					if ((argsList != null) && (argsList.size() >= 1)) {, +						if (argsList.get(0).getType().equals(outerCls.getClassInfo().getType())) {, +							defaultArgCount = 1;, +						}, +					}, +				}, +			}, +, +			result = (argsList == null) || (argsList.size() == defaultArgCount);, +		}, +, +		return result;, +	} , +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +, +							// remove super() call in instance initializer, +							if (parentClass.isAnonymous() && mth.isDefaultConstructor() && co.isSuper()) {, +								remove = true;, +							} , +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, +					// don't follow back edge, +					if (loop.getStart() == b) {, +						continue;, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, +					// don't follow back edge, +					if (loop.getStart() == b) {, +						continue;, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +					if (pred != otherPred) {, +						// merge, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, +					// don't follow back edge, +					if (loop.getStart() == b) {, +						continue;, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +					if (pred != otherPred) {, +						// merge, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			IfInfo mergedIf = mergeNestedIfNodes(condBlock, ifnode, merged);, +			// block already included in other 'if' region, +			return ifnode.getThenBlock();, +		final BlockNode thenBlock;, +		final BlockNode elseBlock;, +		IfInfo mergedIf = mergeNestedIfNodes(block, ifnode, null);, +			final BlockNode bThen = ifnode.getThenBlock();, +			final BlockNode bElse = ifnode.getElseBlock();, +			// select 'then', 'else' and 'exit' blocks, +			if (bElse.getPredecessors().size() != 1, +					&& BlockUtils.isPathExists(bThen, bElse)) {, +				elseBlock = null;, +				out = bElse;, +			} else if (bThen.getPredecessors().size() != 1, +					&& BlockUtils.isPathExists(bElse, bThen)) {, +				ifnode.invertCondition();, +				thenBlock = ifnode.getThenBlock();, +				elseBlock = null;, +				out = ifnode.getElseBlock();, +			} else if (block.getDominatesOn().size() == 2) {, +				thenBlock = bThen;, +				out = BlockUtils.getPathCrossBlockFor(mth, bThen, bElse);, +			} else if (bElse.getPredecessors().size() != 1) {, +				thenBlock = bThen;, +				elseBlock = null;, +				thenBlock = bThen;, +		if (elseBlock == null || stack.containsExit(elseBlock)) {, +			ifRegion.setElseRegion(null);, +		} else {, +			ifRegion.setElseRegion(makeRegion(elseBlock, stack));, +		}, +	private IfInfo mergeNestedIfNodes(BlockNode block, IfNode ifnode, List<BlockNode> merged) {, +		info.setThenBlock(ifnode.getThenBlock());, +		info.setElseBlock(ifnode.getElseBlock());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, +					// don't follow back edge, +					if (loop.getStart() == b) {, +						continue;, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +					if (pred != otherPred) {, +						// merge, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			IfInfo mergedIf = mergeNestedIfNodes(condBlock, ifnode, merged);, +			// block already included in other 'if' region, +			return ifnode.getThenBlock();, +		final BlockNode thenBlock;, +		final BlockNode elseBlock;, +		IfInfo mergedIf = mergeNestedIfNodes(block, ifnode, null);, +			final BlockNode bThen = ifnode.getThenBlock();, +			final BlockNode bElse = ifnode.getElseBlock();, +			// select 'then', 'else' and 'exit' blocks, +			if (bElse.getPredecessors().size() != 1, +					&& BlockUtils.isPathExists(bThen, bElse)) {, +				elseBlock = null;, +				out = bElse;, +			} else if (bThen.getPredecessors().size() != 1, +					&& BlockUtils.isPathExists(bElse, bThen)) {, +				ifnode.invertCondition();, +				thenBlock = ifnode.getThenBlock();, +				elseBlock = null;, +				out = ifnode.getElseBlock();, +			} else if (block.getDominatesOn().size() == 2) {, +				thenBlock = bThen;, +				out = BlockUtils.getPathCrossBlockFor(mth, bThen, bElse);, +			} else if (bElse.getPredecessors().size() != 1) {, +				thenBlock = bThen;, +				elseBlock = null;, +				thenBlock = bThen;, +		if (elseBlock == null || stack.containsExit(elseBlock)) {, +			ifRegion.setElseRegion(null);]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		return Collections.unmodifiableList(classes);, +		return Collections.unmodifiableList(packages);, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		return Collections.unmodifiableList(classes);, +		return Collections.unmodifiableList(packages);, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +	private final List<JavaClass> innerClasses;, +	private final List<JavaField> fields;, +	private final List<JavaMethod> methods;, +, +		int inClsCount = cls.getInnerClasses().size();, +		if (inClsCount == 0) {, +			this.innerClasses = Collections.emptyList();, +		} else {, +			List<JavaClass> list = new ArrayList<JavaClass>(inClsCount);, +			for (ClassNode inner : cls.getInnerClasses()) {, +				list.add(new JavaClass(decompiler, inner));, +			}, +			this.innerClasses = Collections.unmodifiableList(list);, +		}, +, +		int fieldsCount = cls.getFields().size();, +		if (fieldsCount == 0) {, +			this.fields = Collections.emptyList();, +		} else {, +			List<JavaField> flds = new ArrayList<JavaField>(fieldsCount);, +			for (FieldNode f : cls.getFields()) {, +				flds.add(new JavaField(f));, +			}, +			this.fields = Collections.unmodifiableList(flds);, +		}, +, +		int methodsCount = cls.getMethods().size();, +		if (methodsCount == 0) {, +			this.methods = Collections.emptyList();, +		} else {, +			List<JavaMethod> mths = new ArrayList<JavaMethod>(methodsCount);, +			for (MethodNode m : cls.getMethods()) {, +				if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					mths.add(new JavaMethod(m));, +				}, +			}, +			this.methods = Collections.unmodifiableList(mths);, +		}, +	public AccessInfo getAccessInfo() {, +		return cls.getAccessFlags();, +	}, +, +	public List<JavaClass> getInnerClasses() {, +		return innerClasses;, +	}, +, +	public List<JavaField> getFields() {, +		return fields;, +	}, +, +	public List<JavaMethod> getMethods() {, +		return methods;, +	}, +, +, +	public int getDecompiledLine() {, +		return cls.getDecompiledLine();, +	}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		return Collections.unmodifiableList(classes);, +		return Collections.unmodifiableList(packages);, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +	private final List<JavaClass> innerClasses;, +	private final List<JavaField> fields;, +	private final List<JavaMethod> methods;, +, +		int inClsCount = cls.getInnerClasses().size();, +		if (inClsCount == 0) {, +			this.innerClasses = Collections.emptyList();, +		} else {, +			List<JavaClass> list = new ArrayList<JavaClass>(inClsCount);, +			for (ClassNode inner : cls.getInnerClasses()) {, +				list.add(new JavaClass(decompiler, inner));, +			}, +			this.innerClasses = Collections.unmodifiableList(list);, +		}, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static String escapeXML(String str) {, +		int len = str.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			char c = str.charAt(i);, +			switch (c) {, +				case '&': sb.append("&amp;"); break;, +				case '<': sb.append("&lt;"); break;, +				case '>': sb.append("&gt;"); break;, +				case '"': sb.append("&quot;"); break;, +				case '\'': sb.append("&apos;"); break;, +				default:, +					sb.append(c);, +					break;, +			}, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static String escapeXML(String str) {, +		int len = str.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			char c = str.charAt(i);, +			switch (c) {, +				case '&': sb.append("&amp;"); break;, +				case '<': sb.append("&lt;"); break;, +				case '>': sb.append("&gt;"); break;, +				case '"': sb.append("&quot;"); break;, +				case '\'': sb.append("&apos;"); break;, +				default:, +					sb.append(c);, +					break;, +			}, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.core.utils.StringUtils;, +				case RES_XML_CDATA_TYPE:, +					parseCData();, +					break;, +	private void parseCData() throws IOException {, +		if (is.readInt16() != 0x10) {, +			die("CDATA header is not 0x10");, +		}, +		if (is.readInt32() != 0x1C) {, +			die("CDATA header chunk is not 0x1C");, +		}, +		int lineNumber = is.readInt32();, +		is.skip(4);, +, +		int strIndex = is.readInt32();, +		String str = strings[strIndex];, +, +		writer.startLine().addIndent();, +		writer.attachSourceLine(lineNumber);, +		writer.add(StringUtils.escapeXML(str.trim())); // TODO: wrap into CDATA for easier reading, +, +		int size = is.readInt16();, +		is.skip(size - 2);, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	// 'dumb' guard to prevent endless loop in regions processing, +	private static final int REGIONS_LIMIT = 1000 * 1000;, +, +	private int regionsCount;, +		regionsCount++;, +		if (regionsCount > REGIONS_LIMIT) {, +			throw new JadxOverflowException("Regions count limit reached");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	// 'dumb' guard to prevent endless loop in regions processing, +	private static final int REGIONS_LIMIT = 1000 * 1000;, +, +	private int regionsCount;, +		regionsCount++;, +		if (regionsCount > REGIONS_LIMIT) {, +			throw new JadxOverflowException("Regions count limit reached");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionStack.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static final int REGIONS_STACK_LIMIT = 1000;, +, +		if (stack.size() > REGIONS_STACK_LIMIT) {, +			throw new JadxOverflowException("Regions stack size limit reached");, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	// 'dumb' guard to prevent endless loop in regions processing, +	private static final int REGIONS_LIMIT = 1000 * 1000;, +, +	private int regionsCount;, +		regionsCount++;, +		if (regionsCount > REGIONS_LIMIT) {, +			throw new JadxOverflowException("Regions count limit reached");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionStack.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static final int REGIONS_STACK_LIMIT = 1000;, +, +		if (stack.size() > REGIONS_STACK_LIMIT) {, +			throw new JadxOverflowException("Regions stack size limit reached");, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +			if (e.getClass() == JadxOverflowException.class) {, +				e = new JadxOverflowException(e.getMessage());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	// 'dumb' guard to prevent endless loop in regions processing, +	private static final int REGIONS_LIMIT = 1000 * 1000;, +, +	private int regionsCount;, +		regionsCount++;, +		if (regionsCount > REGIONS_LIMIT) {, +			throw new JadxOverflowException("Regions count limit reached");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionStack.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static final int REGIONS_STACK_LIMIT = 1000;, +, +		if (stack.size() > REGIONS_STACK_LIMIT) {, +			throw new JadxOverflowException("Regions stack size limit reached");, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +			if (e.getClass() == JadxOverflowException.class) {, +				e = new JadxOverflowException(e.getMessage());, +++ b/jadx-core/src/main/java/jadx/core/utils/exceptions/JadxOverflowException.java, +package jadx.core.utils.exceptions;, +, +public class JadxOverflowException extends JadxRuntimeException {, +	public JadxOverflowException(String message) {, +		super(message);, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +				assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +				assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +						if (accFlags.isPublic()), +						else, +	public FieldNode getConstField(Object o) {, +            field = cn.constFields.get(o);, +		if (field == null), +			field = dex.getConstFields().get(o);, +		ArgType type = arg.getType();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +				assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +						if (accFlags.isPublic()), +						else, +	public FieldNode getConstField(Object o) {, +            field = cn.constFields.get(o);, +		if (field == null), +			field = dex.getConstFields().get(o);, +		ArgType type = arg.getType();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +				assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +						if (accFlags.isPublic()), +						else, +	public FieldNode getConstField(Object o) {, +            field = cn.constFields.get(o);, +		if (field == null), +			field = dex.getConstFields().get(o);, +		ArgType type = arg.getType();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +						} else {, +							if (inv.getArgsCount() > 0) {, +								for (int j = 0; j < inv.getArgsCount(); j++) {, +									InsnArg arg = inv.getArg(j);, +									if (arg.isLiteral()) {, +										f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +										if (f != null) {, +											arg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, +										}, +									}, +								}, +							}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, +			return  field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +				assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +						if (accFlags.isPublic()), +						else, +	public FieldNode getConstField(Object o) {, +            field = cn.constFields.get(o);, +		if (field == null), +			field = dex.getConstFields().get(o);, +		ArgType type = arg.getType();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +			if (recentFiles.getItemCount() == 0) {, +				recentFiles.add(new JMenuItem(NLS.str("menu.no_recent_files")));, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +			if (recentFiles.getItemCount() == 0) {, +				recentFiles.add(new JMenuItem(NLS.str("menu.no_recent_files")));, +			}, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +menu.no_recent_files=No recent files]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +	public static String literalToString(long lit, ArgType type, StringUtils stringUtils) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +	public static String literalToString(long lit, ArgType type, StringUtils stringUtils) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +import jadx.api.JadxArgs;, +import jadx.core.utils.StringUtils;, +	private static final StringUtils DEF_STRING_UTILS = new StringUtils(new JadxArgs());, +, +			String value = TypeGen.literalToString(literal, getType(), DEF_STRING_UTILS);]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +	private final int id;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +	private final int id;, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +	private final int id;, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.Consts;, +				ClassInfo superCallCls = getClassForSuperCall(code, callMth);, +				if (superCallCls != null) {, +					useClass(code, superCallCls);, +					code.add('.');, +				}, +	@Nullable, +	private ClassInfo getClassForSuperCall(CodeWriter code, MethodInfo callMth) {, +		ClassNode useCls = mth.getParentClass();, +		ClassInfo insnCls = useCls.getAlias();, +		ClassInfo declClass = callMth.getDeclClass();, +		if (insnCls.equals(declClass)) {, +			return null;, +		}, +		ClassNode topClass = useCls.getTopParentClass();, +		if (topClass.getClassInfo().equals(declClass)) {, +			return declClass;, +		}, +		// search call class, +		ClassNode nextParent = useCls;, +		do {, +			ClassInfo nextClsInfo = nextParent.getClassInfo();, +			if (nextClsInfo.equals(declClass), +					|| ArgType.isInstanceOf(mth.dex(), nextClsInfo.getType(), declClass.getType())) {, +				if (nextParent == useCls) {, +					return null;, +				}, +				return nextClsInfo;, +			}, +			nextParent = nextParent.getParentClass();, +		} while (nextParent != null && nextParent != topClass);, +, +		// search failed, just return parent class, +		return useCls.getParentClass().getClassInfo();, +	}, +, +		if (Consts.DEBUG) {, +			code.add("/* inline method: ").add(callMthNode.toString()).add("*/").startLine();, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		NClass cls = names.get(fullName);, +		if (cls == null) {, +		return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +	private final int id;, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.Consts;, +				ClassInfo superCallCls = getClassForSuperCall(code, callMth);, +				if (superCallCls != null) {, +					useClass(code, superCallCls);, +					code.add('.');, +				}, +	@Nullable, +	private ClassInfo getClassForSuperCall(CodeWriter code, MethodInfo callMth) {, +		ClassNode useCls = mth.getParentClass();, +		ClassInfo insnCls = useCls.getAlias();, +		ClassInfo declClass = callMth.getDeclClass();, +		if (insnCls.equals(declClass)) {, +			return null;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode body = getNextBlock(block);, +		if (body == null) {, +			mth.add(AFlag.INCONSISTENT_CODE);, +			LOG.warn("Unexpected end of synchronized block");, +			return null;, +		}, +			exit = traverseMonitorExitsCross(body, exits, cacheSet);, +		synchRegion.getSubBlocks().add(makeRegion(body, stack));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode body = getNextBlock(block);, +		if (body == null) {, +			mth.add(AFlag.INCONSISTENT_CODE);, +			LOG.warn("Unexpected end of synchronized block");, +			return null;, +		}, +			exit = traverseMonitorExitsCross(body, exits, cacheSet);, +		synchRegion.getSubBlocks().add(makeRegion(body, stack));, +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +		String className = null;, +		FileInputStream in = null;, +		try {, +			in = new FileInputStream(file);, +			className = classReader.getClassName();, +		} finally {, +			if (in != null) {, +				in.close();, +			}, +		}, +		return className;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode body = getNextBlock(block);, +		if (body == null) {, +			mth.add(AFlag.INCONSISTENT_CODE);, +			LOG.warn("Unexpected end of synchronized block");, +			return null;, +		}, +			exit = traverseMonitorExitsCross(body, exits, cacheSet);, +		synchRegion.getSubBlocks().add(makeRegion(body, stack));, +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +		String className = null;, +		FileInputStream in = null;, +		try {, +			in = new FileInputStream(file);, +			className = classReader.getClassName();, +		} finally {, +			if (in != null) {, +				in.close();, +			}, +		}, +		return className;, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		FileOutputStream out = null;, +		JarOutputStream jo = null;, +		try {, +			out = new FileOutputStream(outFile);, +			jo = new JarOutputStream(out);, +			if (clsName == null) {, +				throw new IOException("Can't read class name from file: " + file);, +			}, +		} finally {, +			if (jo != null) {, +			}, +			if (out != null) {, +			}, +		}]
[+++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, +			passes.add(new ClassModifier());, +, +, +			passes.add(new CleanRegions());, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, +			passes.add(new ClassModifier());, +, +, +			passes.add(new CleanRegions());, +++ b/src/main/java/jadx/codegen/MethodGen.java, +				LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, +			passes.add(new ClassModifier());, +, +, +			passes.add(new CleanRegions());, +++ b/src/main/java/jadx/codegen/MethodGen.java, +				LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +++ b/src/main/java/jadx/codegen/RegionGen.java, +				code.startLine();, +		code.add("if ").add(makeCondition(insn)).add(" {");, +			code.add(" else ");, +, +			// connect if-else-if block, +			if (els instanceof Region) {, +				Region re = (Region) els;, +				if (re.getSubBlocks().size() == 1, +						&& re.getSubBlocks().get(0) instanceof IfRegion) {, +					makeIf((IfRegion) re.getSubBlocks().get(0), code);, +					return;, +				}, +			}, +, +			code.add("{");, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, +			passes.add(new ClassModifier());, +, +, +			passes.add(new CleanRegions());, +++ b/src/main/java/jadx/codegen/MethodGen.java, +				LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +++ b/src/main/java/jadx/codegen/RegionGen.java, +				code.startLine();, +		code.add("if ").add(makeCondition(insn)).add(" {");, +			code.add(" else ");, +, +			// connect if-else-if block, +			if (els instanceof Region) {, +				Region re = (Region) els;, +				if (re.getSubBlocks().size() == 1, +						&& re.getSubBlocks().get(0) instanceof IfRegion) {, +					makeIf((IfRegion) re.getSubBlocks().get(0), code);, +					return;, +				}, +			}, +, +			code.add("{");, +++ b/src/main/java/jadx/dex/regions/IfRegion.java, +import java.util.Collections;, +		return Collections.unmodifiableList(all);, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, +			passes.add(new ClassModifier());, +, +, +			passes.add(new CleanRegions());, +++ b/src/main/java/jadx/codegen/MethodGen.java, +				LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +++ b/src/main/java/jadx/codegen/RegionGen.java, +				code.startLine();, +		code.add("if ").add(makeCondition(insn)).add(" {");, +			code.add(" else ");, +, +			// connect if-else-if block, +			if (els instanceof Region) {, +				Region re = (Region) els;, +				if (re.getSubBlocks().size() == 1, +						&& re.getSubBlocks().get(0) instanceof IfRegion) {, +					makeIf((IfRegion) re.getSubBlocks().get(0), code);, +					return;, +				}, +			}, +, +			code.add("{");, +++ b/src/main/java/jadx/dex/regions/IfRegion.java, +import java.util.Collections;, +		return Collections.unmodifiableList(all);, +++ b/src/main/java/jadx/dex/regions/LoopRegion.java, +import java.util.Collections;, +		return Collections.unmodifiableList(all);]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoVisitor());, +			}, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoVisitor());, +			}, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +import java.util.LinkedList;, +import java.util.List;, +	private final Set<BlockNode> mergedBlocks;, +	private final List<BlockNode> skipBlocks;, +		this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new LinkedList<BlockNode>());, +		this(condition, info.getThenBlock(), info.getElseBlock(), info.getMergedBlocks(), info.getSkipBlocks());, +	}, +, +	public IfInfo(IfInfo info, BlockNode thenBlock, BlockNode elseBlock) {, +		this(info.getCondition(), thenBlock, elseBlock, info.getMergedBlocks(), info.getSkipBlocks());, +	}, +, +	private IfInfo(IfCondition condition, BlockNode thenBlock, BlockNode elseBlock,, +	              Set<BlockNode> mergedBlocks, List<BlockNode> skipBlocks) {, +		this.thenBlock = thenBlock;, +		this.elseBlock = elseBlock;, +		this.mergedBlocks = mergedBlocks;, +		this.skipBlocks = skipBlocks;, +		IfCondition invertedCondition = IfCondition.invert(info.getCondition());, +		IfInfo tmpIf = new IfInfo(invertedCondition,, +				info.getElseBlock(), info.getThenBlock(),, +				info.getMergedBlocks(), info.getSkipBlocks());, +	public List<BlockNode> getSkipBlocks() {, +		return skipBlocks;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +import java.util.LinkedList;, +import java.util.List;, +	private final Set<BlockNode> mergedBlocks;, +	private final List<BlockNode> skipBlocks;, +		this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new LinkedList<BlockNode>());, +		this(condition, info.getThenBlock(), info.getElseBlock(), info.getMergedBlocks(), info.getSkipBlocks());, +	}, +, +	public IfInfo(IfInfo info, BlockNode thenBlock, BlockNode elseBlock) {, +		this(info.getCondition(), thenBlock, elseBlock, info.getMergedBlocks(), info.getSkipBlocks());, +	}, +, +	private IfInfo(IfCondition condition, BlockNode thenBlock, BlockNode elseBlock,, +	              Set<BlockNode> mergedBlocks, List<BlockNode> skipBlocks) {, +		this.thenBlock = thenBlock;, +		this.elseBlock = elseBlock;, +		this.mergedBlocks = mergedBlocks;, +		this.skipBlocks = skipBlocks;, +		IfCondition invertedCondition = IfCondition.invert(info.getCondition());, +		IfInfo tmpIf = new IfInfo(invertedCondition,, +				info.getElseBlock(), info.getThenBlock(),, +				info.getMergedBlocks(), info.getSkipBlocks());, +	public List<BlockNode> getSkipBlocks() {, +		return skipBlocks;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import static jadx.core.utils.BlockUtils.getNextBlock;, +	static IfInfo searchNestedIf(IfInfo info) {, +		IfInfo tmp = mergeNestedIfNodes(info);, +		return tmp != null ? tmp : info;, +	}, +, +			info = new IfInfo(info, thenBlock, null);, +			info = new IfInfo(info, elseBlock, null);, +		result.getSkipBlocks().addAll(currentIf.getSkipBlocks());, +		result.getSkipBlocks().addAll(nextThen.getSkipBlocks());, +		result.getSkipBlocks().addAll(nextElse.getSkipBlocks());, +		confirmMerge(result);, +		result.getSkipBlocks().addAll(first.getSkipBlocks());, +		result.getSkipBlocks().addAll(second.getSkipBlocks());, +, +		BlockNode otherPathBlock = followThenBranch ? first.getElseBlock() : first.getThenBlock();, +		skipSimplePath(otherPathBlock, result.getSkipBlocks());, +	static void confirmMerge(IfInfo info) {, +		for (BlockNode block : info.getMergedBlocks()) {, +			block.add(AFlag.SKIP);, +		}, +		for (BlockNode block : info.getSkipBlocks()) {, +			block.add(AFlag.SKIP);, +		}, +		info.getSkipBlocks().clear();, +	}, +, +, +	private static void skipSimplePath(BlockNode block, List<BlockNode> skipped) {, +		while (block != null, +				&& block.getCleanSuccessors().size() < 2, +				&& block.getPredecessors().size() == 1) {, +			skipped.add(block);, +			block = getNextBlock(block);, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +import java.util.LinkedList;, +import java.util.List;, +	private final Set<BlockNode> mergedBlocks;, +	private final List<BlockNode> skipBlocks;, +		this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new LinkedList<BlockNode>());, +		this(condition, info.getThenBlock(), info.getElseBlock(), info.getMergedBlocks(), info.getSkipBlocks());, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +package jadx.api;, +, +public final class CodePosition {, +, +	private final JavaClass cls;, +	private final int line;, +	private final int offset;, +, +	public CodePosition(JavaClass cls, int line, int offset) {, +		this.cls = cls;, +		this.line = line;, +		this.offset = offset;, +	}, +, +	public CodePosition(int line, int offset) {, +		this.cls = null;, +		this.line = line;, +		this.offset = offset;, +	}, +, +	public JavaClass getJavaClass() {, +		return cls;, +	}, +, +	public int getLine() {, +		return line;, +	}, +, +	public int getOffset() {, +		return offset;, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		CodePosition that = (CodePosition) o;, +		return line == that.line && offset == that.offset;, +	}, +, +	@Override, +	public int hashCode() {, +		return line + 31 * offset;, +	}, +, +	@Override, +	public String toString() {, +		return line + ":" + offset + (cls != null ? " " + cls : "");, +	}, +}, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +package jadx.api;, +, +public final class CodePosition {, +, +	private final JavaClass cls;, +	private final int line;, +	private final int offset;, +, +	public CodePosition(JavaClass cls, int line, int offset) {, +		this.cls = cls;, +		this.line = line;, +		this.offset = offset;, +	}, +, +	public CodePosition(int line, int offset) {, +		this.cls = null;, +		this.line = line;, +		this.offset = offset;, +	}, +, +	public JavaClass getJavaClass() {, +		return cls;, +	}, +, +	public int getLine() {, +		return line;, +	}, +, +	public int getOffset() {, +		return offset;, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		CodePosition that = (CodePosition) o;, +		return line == that.line && offset == that.offset;, +	}, +]
[+++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +package jadx.api;, +, +import java.io.File;, +, +public class JadxArgs implements IJadxArgs {, +, +	private File outDir = new File("jadx-output");, +	private int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() - 1);, +, +	private boolean cfgOutput = false;, +	private boolean rawCFGOutput = false;, +, +	private boolean isVerbose = false;, +	private boolean fallbackMode = false;, +	private boolean showInconsistentCode = false;, +, +	private boolean isSkipResources = false;, +	private boolean isSkipSources = false;, +, +	private boolean isDeobfuscationOn = false;, +	private boolean isDeobfuscationForceSave = false;, +	private boolean useSourceNameAsClassAlias = false;, +, +	private int deobfuscationMinLength = 0;, +	private int deobfuscationMaxLength = Integer.MAX_VALUE;, +, +	@Override, +	public File getOutDir() {, +		return outDir;, +	}, +, +	public void setOutDir(File outDir) {, +		this.outDir = outDir;, +	}, +, +	@Override, +	public int getThreadsCount() {, +		return threadsCount;, +	}, +, +	public void setThreadsCount(int threadsCount) {, +		this.threadsCount = threadsCount;, +	}, +, +	@Override, +	public boolean isCFGOutput() {, +		return cfgOutput;, +	}, +, +	public void setCfgOutput(boolean cfgOutput) {, +		this.cfgOutput = cfgOutput;, +	}, +, +	@Override, +	public boolean isRawCFGOutput() {, +		return rawCFGOutput;, +	}, +, +	public void setRawCFGOutput(boolean rawCFGOutput) {, +		this.rawCFGOutput = rawCFGOutput;, +	}, +, +	@Override, +	public boolean isFallbackMode() {, +		return fallbackMode;, +	}, +, +	public void setFallbackMode(boolean fallbackMode) {, +		this.fallbackMode = fallbackMode;, +	}, +, +	@Override, +	public boolean isShowInconsistentCode() {, +		return showInconsistentCode;, +	}, +, +	public void setShowInconsistentCode(boolean showInconsistentCode) {, +		this.showInconsistentCode = showInconsistentCode;, +	}, +, +	@Override, +	public boolean isVerbose() {, +		return isVerbose;, +	}, +, +	public void setVerbose(boolean verbose) {, +		isVerbose = verbose;, +	}, +, +	@Override, +	public boolean isSkipResources() {, +		return isSkipResources;, +	}, +, +	public void setSkipResources(boolean skipResources) {, +		isSkipResources = skipResources;, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		if (s == Short.MAX_VALUE) {, +			return "Short.MAX_VALUE";, +		}, +		if (s == Short.MIN_VALUE) {, +			return "Short.MIN_VALUE";, +		}, +		return "(short) " + Short.toString(s);, +		if (b == Byte.MAX_VALUE) {, +			return "Byte.MAX_VALUE";, +		}, +		if (b == Byte.MIN_VALUE) {, +			return "Byte.MIN_VALUE";, +		}, +		return "(byte) " + Byte.toString(b);, +		if (i == Integer.MAX_VALUE) {, +			return "Integer.MAX_VALUE";, +		}, +		if (i == Integer.MIN_VALUE) {, +			return "Integer.MIN_VALUE";, +		}, +		return Integer.toString(i);, +	}, +, +	public static String formatLong(long l) {, +		if (l == Long.MAX_VALUE) {, +			return "Long.MAX_VALUE";, +		}, +		if (l == Long.MIN_VALUE) {, +			return "Long.MIN_VALUE";, +		}, +		String str = Long.toString(l);, +		if (Math.abs(l) >= Integer.MAX_VALUE) {, +			str += "L";, +		}, +		return str;, +		if (Double.isNaN(d)) {, +			return "Double.NaN";, +		}, +		if (d == Double.NEGATIVE_INFINITY) {, +			return "Double.NEGATIVE_INFINITY";, +		}, +		if (d == Double.POSITIVE_INFINITY) {, +			return "Double.POSITIVE_INFINITY";, +		}, +		if (d == Double.MIN_VALUE) {, +			return "Double.MIN_VALUE";, +		}, +		if (d == Double.MAX_VALUE) {, +			return "Double.MAX_VALUE";, +		}, +		if (d == Double.MIN_NORMAL) {, +			return "Double.MIN_NORMAL";, +		}, +		return Double.toString(d) + "d";, +		if (Float.isNaN(f)) {, +			return "Float.NaN";, +		}, +		if (f == Float.NEGATIVE_INFINITY) {, +			return "Float.NEGATIVE_INFINITY";, +		}, +		if (f == Float.POSITIVE_INFINITY) {, +			return "Float.POSITIVE_INFINITY";, +		}, +		if (f == Float.MIN_VALUE) {, +			return "Float.MIN_VALUE";, +		}, +		if (f == Float.MAX_VALUE) {, +			return "Float.MAX_VALUE";, +		}, +		if (f == Float.MIN_NORMAL) {, +			return "Float.MIN_NORMAL";, +		}, +		return Float.toString(f) + "f";, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		if (s == Short.MAX_VALUE) {, +			return "Short.MAX_VALUE";, +		}, +		if (s == Short.MIN_VALUE) {, +			return "Short.MIN_VALUE";, +		}, +		return "(short) " + Short.toString(s);, +		if (b == Byte.MAX_VALUE) {, +			return "Byte.MAX_VALUE";, +		}, +		if (b == Byte.MIN_VALUE) {, +			return "Byte.MIN_VALUE";, +		}, +		return "(byte) " + Byte.toString(b);, +		if (i == Integer.MAX_VALUE) {, +			return "Integer.MAX_VALUE";, +		}, +		if (i == Integer.MIN_VALUE) {, +			return "Integer.MIN_VALUE";, +		}, +		return Integer.toString(i);, +	}, +, +	public static String formatLong(long l) {, +		if (l == Long.MAX_VALUE) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +//			removeParenthesis(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +//			removeParenthesis(block);, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java, +	//	@Test]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, +				LOG.error("Error close zip file: {}", zipRef, e);, +			close(inputStream);, +		copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, +				LOG.error("Error close zip file: {}", zipRef, e);, +			close(inputStream);, +		copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import static jadx.core.utils.files.FileUtils.close;, +, +					close(out);, +			close(outputStream);, +			close(out);, +			close(input);, +					close(in);, +			close(inputStream);, +			close(in);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, +				LOG.error("Error close zip file: {}", zipRef, e);, +			close(inputStream);, +		copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import static jadx.core.utils.files.FileUtils.close;, +, +					close(out);, +			close(outputStream);, +			close(out);, +			close(input);, +					close(in);, +			close(inputStream);, +			close(in);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import static jadx.core.utils.files.FileUtils.close;, +, +			close(out);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, +				LOG.error("Error close zip file: {}", zipRef, e);, +			close(inputStream);, +		copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import static jadx.core.utils.files.FileUtils.close;, +, +					close(out);, +			close(outputStream);, +			close(out);, +			close(input);, +					close(in);, +			close(inputStream);, +			close(in);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import static jadx.core.utils.files.FileUtils.close;, +, +			close(out);, +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +import static jadx.core.utils.files.FileUtils.close;, +, +			close(in);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, +				LOG.error("Error close zip file: {}", zipRef, e);, +			close(inputStream);, +		copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import static jadx.core.utils.files.FileUtils.close;, +, +					close(out);, +			close(outputStream);, +			close(out);, +			close(input);, +					close(in);, +			close(inputStream);, +			close(in);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import static jadx.core.utils.files.FileUtils.close;, +, +			close(out);, +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +import static jadx.core.utils.files.FileUtils.close;, +, +			close(in);]
[+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase2.java]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					boolean badCode = mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE);, +					if (badCode) {, +						code.startLine("/* JADX WARNING: inconsistent code. */");, +						code.startLine("/* Code decompiled incorrectly, please refer to instructions dump. */");, +					code.incIndent();, +					mthGen.addInstructions(code);, +					code.decIndent();, +		addEnumFields(cls, code);, +	private void addEnumFields(ClassNode cls, CodeWriter code) throws CodegenException {, +		EnumClassAttr enumFields = (EnumClassAttr) cls.getAttributes().get(AttributeType.ENUM_CLASS);, +		if (enumFields != null) {, +			InsnGen igen = null;, +			for (Iterator<EnumField> it = enumFields.getFields().iterator(); it.hasNext(); ) {, +				EnumField f = it.next();, +				code.startLine(f.getName());, +				if (f.getArgs().size() != 0) {, +					code.add('(');, +					for (Iterator<InsnArg> aIt = f.getArgs().iterator(); aIt.hasNext(); ) {, +						InsnArg arg = aIt.next();, +						if (igen == null) {, +							// don't init mth gen if this is simple enum, +							MethodGen mthGen = new MethodGen(this, enumFields.getStaticMethod());, +							igen = new InsnGen(mthGen, enumFields.getStaticMethod(), false);, +						}, +						igen.addArg(code, arg);, +						if (aIt.hasNext()) {, +							code.add(", ");, +						}, +					}, +					code.add(')');, +				}, +				if (f.getCls() != null) {, +					new ClassGen(f.getCls(), this, fallback).makeClassBody(code);, +				}, +				if (it.hasNext()) {, +					code.add(',');, +				}, +			}, +			if (enumFields.getFields().isEmpty()) {, +				code.startLine();, +			}, +			code.add(';');, +			code.newLine();, +		}, +	}, +, +		String fullName = classInfo.getFullName();, +			return fullName;, +				fullName = classInfo.getNameWithoutPackage();, +				return fullName;, +					return fullName;, +		SourceFileAttr sourceFileAttr = (SourceFileAttr) node.getAttributes().get(AttributeType.SOURCE_FILE);, +			code.startLine("// compiled from: ").add(sourceFileAttr.getFileName());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					boolean badCode = mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE);, +					if (badCode) {, +						code.startLine("/* JADX WARNING: inconsistent code. */");, +						code.startLine("/* Code decompiled incorrectly, please refer to instructions dump. */");, +					code.incIndent();, +					mthGen.addInstructions(code);, +					code.decIndent();, +		addEnumFields(cls, code);, +	private void addEnumFields(ClassNode cls, CodeWriter code) throws CodegenException {, +		EnumClassAttr enumFields = (EnumClassAttr) cls.getAttributes().get(AttributeType.ENUM_CLASS);, +		if (enumFields != null) {, +			InsnGen igen = null;, +			for (Iterator<EnumField> it = enumFields.getFields().iterator(); it.hasNext(); ) {, +				EnumField f = it.next();, +				code.startLine(f.getName());, +				if (f.getArgs().size() != 0) {, +					code.add('(');, +					for (Iterator<InsnArg> aIt = f.getArgs().iterator(); aIt.hasNext(); ) {, +						InsnArg arg = aIt.next();, +						if (igen == null) {, +							// don't init mth gen if this is simple enum, +							MethodGen mthGen = new MethodGen(this, enumFields.getStaticMethod());, +							igen = new InsnGen(mthGen, enumFields.getStaticMethod(), false);, +						}, +						igen.addArg(code, arg);, +						if (aIt.hasNext()) {, +							code.add(", ");, +						}, +					}, +					code.add(')');, +				}, +				if (f.getCls() != null) {, +					new ClassGen(f.getCls(), this, fallback).makeClassBody(code);, +				}, +				if (it.hasNext()) {, +					code.add(',');, +				}, +			}, +			if (enumFields.getFields().isEmpty()) {, +				code.startLine();, +			}, +			code.add(';');, +			code.newLine();, +		}, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	public boolean canReorderRecursive() {, +		if (!canReorder()) {, +			return false;, +		}, +		for (InsnArg arg : this.getArguments()) {, +			if (arg.isInsnWrap()) {, +				InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +				if (!wrapInsn.canReorderRecursive()) {, +					return false;, +				}, +			}, +		}, +		return true;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	public boolean canReorderRecursive() {, +		if (!canReorder()) {, +			return false;, +		}, +		for (InsnArg arg : this.getArguments()) {, +			if (arg.isInsnWrap()) {, +				InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +				if (!wrapInsn.canReorderRecursive()) {, +					return false;, +				}, +			}, +		}, +		return true;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		InsnArg arg = insn.getArg(0);, +		if (arg.isInsnWrap()) {, +			InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +			if (!wrapInsn.canReorderRecursive() && insn.contains(AType.CATCH_BLOCK)) {, +				return false;, +			}, +		} else {, +			return arg.isLiteral() || arg.isThis();, +		}, +		if (!regs.isEmpty()) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	public boolean canReorderRecursive() {, +		if (!canReorder()) {, +			return false;, +		}, +		for (InsnArg arg : this.getArguments()) {, +			if (arg.isInsnWrap()) {, +				InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +				if (!wrapInsn.canReorderRecursive()) {, +					return false;, +				}, +			}, +		}, +		return true;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ExtractFieldInit.java, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		InsnArg arg = insn.getArg(0);, +		if (arg.isInsnWrap()) {, +			InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +			if (!wrapInsn.canReorderRecursive() && insn.contains(AType.CATCH_BLOCK)) {, +				return false;, +			}, +		} else {, +			return arg.isLiteral() || arg.isThis();, +		}, +		if (!regs.isEmpty()) {, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestFieldInitInTryCatch.java, +package jadx.tests.integration.others;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.net.MalformedURLException;, +import java.net.URL;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsLines;, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestFieldInitInTryCatch extends IntegrationTest {, +, +	public static class TestCls {, +		private static final URL a;, +, +		static {, +			try {, +				a = new URL("http://www.example.com/");, +			} catch (MalformedURLException e) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JList resultsList;, +	private static class ResultsModel extends DefaultListModel {, +	private static class ResultsCellRenderer implements ListCellRenderer {, +		public Component getListCellRendererComponent(JList list,, +		resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JList resultsList;, +	private static class ResultsModel extends DefaultListModel {, +	private static class ResultsCellRenderer implements ListCellRenderer {, +		public Component getListCellRendererComponent(JList list,, +		resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		LoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);, +	private static LoopType checkArrayForEach(MethodNode mth, LoopRegion loopRegion, InsnNode initInsn, InsnNode incrInsn,, +		if (!usedOnlyInLoop(mth, loopRegion, iterVar)) {, +			return null;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		LoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);, +	private static LoopType checkArrayForEach(MethodNode mth, LoopRegion loopRegion, InsnNode initInsn, InsnNode incrInsn,, +		if (!usedOnlyInLoop(mth, loopRegion, iterVar)) {, +			return null;, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexedLoop.java, +package jadx.tests.integration.loops;, +, +import java.io.File;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.nullValue;, +import static org.junit.Assert.assertThat;, +, +public class TestIndexedLoop extends IntegrationTest {, +, +	public static class TestCls {, +, +		public File test(File[] files) {, +			File file = null;, +			if (files != null) {, +				int length = files.length;, +				if (length == 0) {, +					file = null;, +				} else {, +					for (int i = 0; i < length; i++) {, +						file = files[i];, +						if (file.getName().equals("f")) {, +							break;, +						}, +					}, +				}, +			} else {, +				file = null;, +			}, +			if (file != null) {, +				file.deleteOnExit();, +			}, +			return file;, +		}, +, +		public void check() {, +			assertThat(test(null), nullValue());, +			assertThat(test(new File[]{}), nullValue());, +, +			File file = new File("f");, +			assertThat(test(new File[]{new File("a"), file}), is(file));, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, not(containsString("for (File file :")));, +		assertThat(code, containsOne("for (int i = 0; i < length; i++) {"));, +	}, +, +	@Test, +	public void testNoDebug() {, +		noDebugInfo();, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, not(containsString("for (File file :")));, +		assertThat(code, containsOne("for (int i = 0; i < length; i++) {"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.utils.exceptions.DecodeException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import jadx.core.utils.files.FileUtils;, +import jadx.core.utils.files.ZipSecurity;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.utils.exceptions.DecodeException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import jadx.core.utils.files.FileUtils;, +import jadx.core.utils.files.ZipSecurity;, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.utils.exceptions.DecodeException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +				limitExecTime(() -> checkMth.invoke(origCls.getConstructor().newInstance()));, +			} catch (Exception e) {, +				rethrow("Original check failed", e);, +					limitExecTime(() -> invoke("check"));, +				} catch (Exception e) {, +					rethrow("Decompiled check failed", e);, +	private <T> T limitExecTime(Callable<T> call) {, +		ExecutorService executor = Executors.newSingleThreadExecutor();, +		Future<T> future = executor.submit(call);, +		try {, +			return future.get(5, TimeUnit.SECONDS);, +		} catch (TimeoutException ex) {, +			future.cancel(true);, +			rethrow("Execution timeout", ex);, +		} catch (Exception ex) {, +			rethrow(ex.getMessage(), ex);, +		} finally {, +			executor.shutdownNow();, +		}, +		return null;, +	}, +, +	private void rethrow(String msg, Throwable e) {, +		if (e instanceof InvocationTargetException) {, +			Throwable cause = e.getCause();, +				fail(cause);, +			}, +		} else if (e instanceof ExecutionException) {, +			rethrow(e.getMessage(), e.getCause());, +		} else {, +			fail(msg, e);, +			fail(e);, +	protected void outputCFG() {, +	}, +	// Use only for debug purpose, +	protected void outputRawCFG() {]
[+++ b/.travis.yml, +env:, +    - TERM=dumb, +, +    - sed -i " 1 s/.*/&-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)/" version, +    - cat version, +    - sed -i "s/BUILD_VERSION/$(head -c -1 version)/g" bintray.json, +    - ./gradlew clean build, +    - ./gradlew clean build jacocoTestReport, +    - ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew clean dist, +, +deploy:, +    provider: bintray, +    file: bintray.json, +    user: skylot, +    key:, +      secure: bBzfhraRwT5w+FkAcQnWJQgt4i894k595g4gNFf8dGpBsvPUvGzoa/SUaokrmlj5UCFc12k7j6aZswNITGjBuAf2fDVRwMQCH9ORiqIcJWuemQPHB7iAQjITGXKwef6zWKcZSkVuMtUMmGymYSsqpya+pSqwdP5rLbWPgGixEaQ=, +    skip_cleanup: true, +    on:, +      branch: master, +      tags: false, +++ b/.travis.yml, +env:, +    - TERM=dumb, +, +    - sed -i " 1 s/.*/&-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)/" version, +    - cat version, +    - sed -i "s/BUILD_VERSION/$(head -c -1 version)/g" bintray.json, +    - ./gradlew clean build, +    - ./gradlew clean build jacocoTestReport, +    - ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew clean dist, +, +deploy:, +    provider: bintray, +    file: bintray.json, +    user: skylot, +    key:, +      secure: bBzfhraRwT5w+FkAcQnWJQgt4i894k595g4gNFf8dGpBsvPUvGzoa/SUaokrmlj5UCFc12k7j6aZswNITGjBuAf2fDVRwMQCH9ORiqIcJWuemQPHB7iAQjITGXKwef6zWKcZSkVuMtUMmGymYSsqpya+pSqwdP5rLbWPgGixEaQ=, +    skip_cleanup: true, +    on:, +      branch: master, +      tags: false, +++ b/README.md, +- [unstable](https://bintray.com/skylot/jadx/unstable#files), +- from [bintray](https://bintray.com/skylot/jadx/releases#files), +++ b/.travis.yml, +env:, +    - TERM=dumb, +, +    - sed -i " 1 s/.*/&-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)/" version, +    - cat version, +    - sed -i "s/BUILD_VERSION/$(head -c -1 version)/g" bintray.json, +    - ./gradlew clean build, +    - ./gradlew clean build jacocoTestReport, +    - ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew clean dist, +, +deploy:, +    provider: bintray, +    file: bintray.json, +    user: skylot, +    key:, +      secure: bBzfhraRwT5w+FkAcQnWJQgt4i894k595g4gNFf8dGpBsvPUvGzoa/SUaokrmlj5UCFc12k7j6aZswNITGjBuAf2fDVRwMQCH9ORiqIcJWuemQPHB7iAQjITGXKwef6zWKcZSkVuMtUMmGymYSsqpya+pSqwdP5rLbWPgGixEaQ=, +    skip_cleanup: true, +    on:, +      branch: master, +      tags: false, +++ b/README.md, +- [unstable](https://bintray.com/skylot/jadx/unstable#files), +- from [bintray](https://bintray.com/skylot/jadx/releases#files), +++ b/bintray.json, +{, +  "package": {, +    "name": "unstable",, +    "repo": "jadx",, +    "subject": "skylot",, +    "desc": "Unstable",, +    "website_url": "https://github.com/skylot/jadx",, +    "issue_tracker_url": "https://github.com/skylot/jadx",, +    "vcs_url": "https://github.com/skylot/jadx",, +    "licenses": ["Apache-2.0"],, +    "labels": ["unstable"],, +    "public_download_numbers": false,, +    "public_stats": false, +  },, +, +  "version": {, +    "name": "BUILD_VERSION", +  },, +, +  "files":, +  [, +    {"includePattern": "build/(jadx.*\.zip)", "uploadPattern": "$1"}, +  ],, +  "publish": true, +}]
[+++ b/.travis.yml, +    edge:, +      branch: v1.8.47, +    key: $BINTRAY_KEY]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, +			stack.push(loopRegion);, +			stack.pop();, +					&& outAttrs.get(AttributeType.LOOP) != loop, +					&& stack.peekRegion() instanceof LoopRegion, +					&& RegionUtils.isRegionContainsBlock(stack.peekRegion(), out)) {, +, +			stack.push(loopRegion);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, +			stack.push(loopRegion);, +			stack.pop();, +					&& outAttrs.get(AttributeType.LOOP) != loop, +					&& stack.peekRegion() instanceof LoopRegion, +					&& RegionUtils.isRegionContainsBlock(stack.peekRegion(), out)) {, +, +			stack.push(loopRegion);, +		}, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, +			stack.push(loopRegion);, +			stack.pop();, +					&& outAttrs.get(AttributeType.LOOP) != loop, +					&& stack.peekRegion() instanceof LoopRegion, +					&& RegionUtils.isRegionContainsBlock(stack.peekRegion(), out)) {, +, +			stack.push(loopRegion);, +		}, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopCondition.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopCondition extends InternalJadxTest {, +, +	@SuppressWarnings("serial"), +	public static class TestCls extends Exception {, +		public String f;, +, +		private void setEnabled(boolean r1z) {, +		}, +, +		private void testIfInLoop() {, +			int j = 0;, +			for (int i = 0; i < f.length(); i++) {, +				char ch = f.charAt(i);, +				if (ch == '/') {, +					j++;, +					if (j == 2) {, +						setEnabled(true);, +						return;, +					}, +				}, +			}, +			setEnabled(false);, +		}, +, +		public int testComplexIfInLoop(boolean a) {, +			int i = 0;, +			while (a && i < 10) {, +				i++;, +			}, +			return i;, +		}, +, +		private void testMoreComplexIfInLoop(java.util.ArrayList<String> list) throws Exception {, +			for (int i = 0; i != 16 && i < 255; i++) {, +				list.set(i, "ABC");, +				if (i == 128) {, +					return;, +				}, +				list.set(i, "DEF");, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("i < this.f.length()"));, +		assertThat(code, containsString("while (a && i < 10) {"));, +		assertThat(code, containsString("list.set(i, \"ABC\")"));, +		assertThat(code, containsString("list.set(i, \"DEF\")"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, +			stack.push(loopRegion);]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, +		logCollector.registerListener(new ILogListener() {, +				SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, +		logCollector.registerListener(new ILogListener() {, +				SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, +		logCollector.registerListener(new ILogListener() {, +				SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/utils/logs/ILogListener.java, +package jadx.gui.utils.logs;, +, +import ch.qos.logback.classic.Level;, +, +public interface ILogListener {, +	Level getFilterLevel();, +, +	void onAppend(String logStr);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, +		logCollector.registerListener(new ILogListener() {, +				SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/utils/logs/ILogListener.java, +package jadx.gui.utils.logs;, +, +import ch.qos.logback.classic.Level;, +, +public interface ILogListener {, +	Level getFilterLevel();, +, +	void onAppend(String logStr);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/utils/logs/LogCollector.java, +package jadx.gui.utils.logs;, +, +import java.util.Deque;, +import java.util.LinkedList;, +, +import ch.qos.logback.classic.Level;, +import ch.qos.logback.classic.Logger;, +import ch.qos.logback.classic.LoggerContext;, +import ch.qos.logback.classic.PatternLayout;, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.AppenderBase;, +import ch.qos.logback.core.Layout;, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.LoggerFactory;, +, +public class LogCollector extends AppenderBase<ILoggingEvent> {, +	public static final int BUFFER_SIZE = 5000;, +, +	private static final LogCollector INSTANCE = new LogCollector();, +	public static LogCollector getInstance() {, +		return INSTANCE;, +	}, +, +	public static void register() {, +		Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);, +		LoggerContext loggerContext = rootLogger.getLoggerContext();, +, +		PatternLayout layout = new PatternLayout();, +		layout.setContext(loggerContext);, +		layout.setPattern("%-5level: %msg%n");, +		layout.start();, +, +		INSTANCE.setContext(loggerContext);, +		INSTANCE.setLayout(layout);, +		INSTANCE.start();, +, +		rootLogger.addAppender(INSTANCE);, +	}, +, +	private Layout<ILoggingEvent> layout;, +, +	@Nullable, +	private ILogListener listener;, +, +	private final Deque<LogEvent> buffer = new LinkedList<>();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +						if (accFlags.isPublic()) {, +						}, +	public FieldNode getConstField(Object obj) {, +		return getConstField(obj, true);, +	}, +, +	public FieldNode getConstField(Object obj, boolean searchGlobal) {, +			field = cn.constFields.get(obj);, +		if (field == null && searchGlobal) {, +			field = dex.getConstFields().get(obj);, +		}, +		PrimitiveType type = arg.getType().getPrimitiveType();, +		if (type == null) {, +			return null;, +		}, +		switch (type) {, +			case BOOLEAN:, +				return getConstField(literal == 1, false);, +			case CHAR:, +				return getConstField((char) literal, Math.abs(literal) > 1);, +			case BYTE:, +				return getConstField((byte) literal, Math.abs(literal) > 1);, +			case SHORT:, +				return getConstField((short) literal, Math.abs(literal) > 1);, +			case INT:, +				return getConstField((int) literal, Math.abs(literal) > 1);, +			case LONG:, +				return getConstField(literal, Math.abs(literal) > 1);, +			case FLOAT:, +				return getConstField(Float.intBitsToFloat((int) literal), true);, +			case DOUBLE:, +				return getConstField(Double.longBitsToDouble(literal), true);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +						if (accFlags.isPublic()) {, +						}, +	public FieldNode getConstField(Object obj) {, +		return getConstField(obj, true);, +	}, +, +	public FieldNode getConstField(Object obj, boolean searchGlobal) {, +			field = cn.constFields.get(obj);, +		if (field == null && searchGlobal) {, +			field = dex.getConstFields().get(obj);, +		}, +		PrimitiveType type = arg.getType().getPrimitiveType();, +		if (type == null) {, +			return null;, +		}, +		switch (type) {, +			case BOOLEAN:, +				return getConstField(literal == 1, false);, +			case CHAR:, +				return getConstField((char) literal, Math.abs(literal) > 1);, +			case BYTE:, +				return getConstField((byte) literal, Math.abs(literal) > 1);, +			case SHORT:, +				return getConstField((short) literal, Math.abs(literal) > 1);, +			case INT:, +				return getConstField((int) literal, Math.abs(literal) > 1);, +			case LONG:, +				return getConstField(literal, Math.abs(literal) > 1);, +			case FLOAT:, +				return getConstField(Float.intBitsToFloat((int) literal), true);, +			case DOUBLE:, +				return getConstField(Double.longBitsToDouble(literal), true);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +						if (accFlags.isPublic()) {, +						}, +	public FieldNode getConstField(Object obj) {, +		return getConstField(obj, true);, +	}, +, +	public FieldNode getConstField(Object obj, boolean searchGlobal) {, +			field = cn.constFields.get(obj);, +		if (field == null && searchGlobal) {, +			field = dex.getConstFields().get(obj);, +		}, +		PrimitiveType type = arg.getType().getPrimitiveType();, +		if (type == null) {, +			return null;, +		}, +		switch (type) {, +			case BOOLEAN:, +				return getConstField(literal == 1, false);, +			case CHAR:, +				return getConstField((char) literal, Math.abs(literal) > 1);, +			case BYTE:]
[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	private final JavaNode node;, +	public CodePosition(JavaNode node, int line, int offset) {, +		this.node = node;, +		this.node = null;, +	public JavaNode getNode() {, +		return node;, +	}, +, +		JavaClass parent = node.getDeclaringClass();, +		if (parent == null && node instanceof JavaClass) {, +			return (JavaClass) node;, +		}, +		return parent;, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	private final JavaNode node;, +	public CodePosition(JavaNode node, int line, int offset) {, +		this.node = node;, +		this.node = null;, +	public JavaNode getNode() {, +		return node;, +	}, +, +		JavaClass parent = node.getDeclaringClass();, +		if (parent == null && node instanceof JavaClass) {, +			return (JavaClass) node;, +		}, +		return parent;, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +, +			classesMap.clear();, +				JavaClass javaClass = new JavaClass(classNode, this);, +				clsList.add(javaClass);, +				classesMap.put(classNode, javaClass);, +	Map<ClassNode, JavaClass> getClassesMap() {, +		return classesMap;, +, +	Map<MethodNode, JavaMethod> getMethodsMap() {, +		return methodsMap;, +, +	Map<FieldNode, JavaField> getFieldsMap() {, +		return fieldsMap;, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	private final JavaNode node;, +	public CodePosition(JavaNode node, int line, int offset) {, +		this.node = node;, +		this.node = null;, +	public JavaNode getNode() {, +		return node;, +	}, +, +		JavaClass parent = node.getDeclaringClass();, +		if (parent == null && node instanceof JavaClass) {, +			return (JavaClass) node;, +		}, +		return parent;, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +, +			classesMap.clear();, +				JavaClass javaClass = new JavaClass(classNode, this);, +				clsList.add(javaClass);, +				classesMap.put(classNode, javaClass);, +	Map<ClassNode, JavaClass> getClassesMap() {, +		return classesMap;, +, +	Map<MethodNode, JavaMethod> getMethodsMap() {, +		return methodsMap;, +, +	Map<FieldNode, JavaField> getFieldsMap() {, +		return fieldsMap;, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import java.util.HashMap;, +import org.jetbrains.annotations.Nullable;, +, +		}, +		return code.getCodeStr();, +	public synchronized void decompile() {, +		JadxDecompiler rootDecompiler = getRootDecompiler();, +					rootDecompiler.getClassesMap().put(inner, javaClass);, +					JavaField javaField = new JavaField(f, this);, +					flds.add(javaField);, +					rootDecompiler.getFieldsMap().put(f, javaField);, +					JavaMethod javaMethod = new JavaMethod(this, m);, +					mths.add(javaMethod);, +					rootDecompiler.getMethodsMap().put(m, javaMethod);, +	private JadxDecompiler getRootDecompiler() {, +		if (parent != null) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +			recentFiles.subList(RECENT_FILES_COUNT, count).clear();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;, +import jadx.core.dex.nodes.MethodNode;, +, +	public String getDetailedVarInfo(MethodNode mth) {, +		Set<ArgType> types = new HashSet<>();, +		Set<String> names = Collections.emptySet();, +, +		List<RegisterArg> useArgs = new ArrayList<>(1 + useList.size());, +		useArgs.add(assign);, +		useArgs.addAll(useList);, +, +		if (mth.contains(AType.LOCAL_VARS_DEBUG_INFO)) {, +			names = new HashSet<>();, +			for (RegisterArg arg : useArgs) {, +				RegDebugInfoAttr debugInfoAttr = arg.get(AType.REG_DEBUG_INFO);, +				if (debugInfoAttr != null) {, +					names.add(debugInfoAttr.getName());, +					types.add(debugInfoAttr.getRegType());, +				}, +			}, +		}, +, +		for (RegisterArg arg : useArgs) {, +			ArgType initType = arg.getInitType();, +			if (initType.isTypeKnown()) {, +				types.add(initType);, +			}, +			ArgType type = arg.getType();, +			if (type.isTypeKnown()) {, +				types.add(type);, +			}, +		}, +		StringBuilder sb = new StringBuilder();, +		sb.append('r').append(regNum).append('v').append(version);, +		if (!names.isEmpty()) {, +			sb.append(", names: ").append(names);, +		}, +		if (!types.isEmpty()) {, +			sb.append(", types: ").append(types);, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;, +import jadx.core.dex.nodes.MethodNode;, +, +	public String getDetailedVarInfo(MethodNode mth) {, +		Set<ArgType> types = new HashSet<>();, +		Set<String> names = Collections.emptySet();, +, +		List<RegisterArg> useArgs = new ArrayList<>(1 + useList.size());, +		useArgs.add(assign);, +		useArgs.addAll(useList);, +, +		if (mth.contains(AType.LOCAL_VARS_DEBUG_INFO)) {, +			names = new HashSet<>();, +			for (RegisterArg arg : useArgs) {, +				RegDebugInfoAttr debugInfoAttr = arg.get(AType.REG_DEBUG_INFO);, +				if (debugInfoAttr != null) {, +					names.add(debugInfoAttr.getName());, +					types.add(debugInfoAttr.getRegType());, +				}, +			}, +		}, +, +		for (RegisterArg arg : useArgs) {, +			ArgType initType = arg.getInitType();, +			if (initType.isTypeKnown()) {, +				types.add(initType);, +			}, +			ArgType type = arg.getType();, +			if (type.isTypeKnown()) {, +				types.add(type);, +			}, +		}, +		StringBuilder sb = new StringBuilder();, +		sb.append('r').append(regNum).append('v').append(version);, +		if (!names.isEmpty()) {, +			sb.append(", names: ").append(names);, +		}, +		if (!types.isEmpty()) {, +			sb.append(", types: ").append(types);, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +					mth.addComment("JADX WARNING: type inference failed for: " + var.getDetailedVarInfo(mth));]
[+++ b/build.gradle, +    compile 'org.slf4j:slf4j-api:1.7.5', +    compile 'ch.qos.logback:logback-classic:1.0.11', +    testCompile 'junit:junit:4.11', +    gradleVersion = '1.5', +++ b/build.gradle, +    compile 'org.slf4j:slf4j-api:1.7.5', +    compile 'ch.qos.logback:logback-classic:1.0.11', +    testCompile 'junit:junit:4.11', +    gradleVersion = '1.5', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    compile 'org.slf4j:slf4j-api:1.7.5', +    compile 'ch.qos.logback:logback-classic:1.0.11', +    testCompile 'junit:junit:4.11', +    gradleVersion = '1.5', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.5-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +		, +		String nsValue = getString(beginPrefix);, +		if(!nsMap.containsValue(nsValue)) {, +			nsMap.putIfAbsent(getString(beginURI), nsValue);, +		}, +		, +		String nsValue = getString(endPrefix);, +		if(!nsMap.containsValue(nsValue)) {, +			nsMap.putIfAbsent(getString(endURI), nsValue);, +		}]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +		String javaVer = System.getProperty("java.version");]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName);, +, +	public String makeFullClsName(String shortName) {, +		if (parentClass != null) {, +			return parentClass.fullName + "." + shortName;, +		}, +		return pkg.isEmpty() ? shortName : pkg + "." + shortName;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName);, +, +	public String makeFullClsName(String shortName) {, +		if (parentClass != null) {, +			return parentClass.fullName + "." + shortName;, +		}, +		return pkg.isEmpty() ? shortName : pkg + "." + shortName;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				addSourceFilenameAttr(fileName);, +	private void addSourceFilenameAttr(String fileName) {, +		if (fileName == null) {, +			return;, +		}, +		if (fileName.endsWith(".java")) {, +			fileName = fileName.substring(0, fileName.length() - 5);, +		}, +		if (fileName.isEmpty(), +				|| fileName.equals("SourceFile"), +				|| fileName.equals("\"")) {, +			return;, +		}, +		if (clsInfo != null) {, +			String name = clsInfo.getShortName();, +			if (fileName.equals(name)) {, +				return;, +			}, +			if (fileName.contains("$"), +					&& fileName.endsWith("$" + name)) {, +				return;, +			}, +		}, +		this.addAttr(new SourceFileAttr(fileName));, +		LOG.debug("Class '{}' compiled from '{}'", this, fileName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName);, +, +	public String makeFullClsName(String shortName) {, +		if (parentClass != null) {, +			return parentClass.fullName + "." + shortName;, +		}, +		return pkg.isEmpty() ? shortName : pkg + "." + shortName;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				addSourceFilenameAttr(fileName);, +	private void addSourceFilenameAttr(String fileName) {, +		if (fileName == null) {, +			return;, +		}, +		if (fileName.endsWith(".java")) {, +			fileName = fileName.substring(0, fileName.length() - 5);, +		}, +		if (fileName.isEmpty(), +				|| fileName.equals("SourceFile"), +				|| fileName.equals("\"")) {, +			return;, +		}, +		if (clsInfo != null) {, +			String name = clsInfo.getShortName();, +			if (fileName.equals(name)) {, +				return;, +			}, +			if (fileName.contains("$"), +					&& fileName.endsWith("$" + name)) {, +				return;, +			}, +		}, +		this.addAttr(new SourceFileAttr(fileName));, +		LOG.debug("Class '{}' compiled from '{}'", this, fileName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +		for (DexNode dex : dexNodes) {, +				classes.addAll(dex.getClasses());, +				for (ClassNode cls : dex.getClasses()) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName);, +, +	public String makeFullClsName(String shortName) {, +		if (parentClass != null) {, +			return parentClass.fullName + "." + shortName;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +			writer.print(strings[attributeName] + "=\"");, +			if(attrValDataType==0x3) writer.print(strings[attrValData]);, +			else if(attrValDataType==0x10) writer.print(attrValData);, +				if(attrValData==0) writer.print("false");, +				else if(attrValData==1 || attrValData==-1) writer.print("true");, +				else writer.print("UNKNOWN_BOOLEAN_TYPE");, +			} else if(attrValDataType==0x1) writer.print("0x" + Integer.toHexString(attrValData));, +			else writer.print("UNKNOWN_DATA_TYPE_" + attrValDataType);, +			writer.print("\"");]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf"}, description = "activate deobfuscation"), +	protected boolean deobfuscationOn = false;, +, +	@Parameter(names = {"--deobf-min"}, description = "min length of name"), +	protected int deobfuscationMinLength = 2;, +, +	@Parameter(names = {"--deobf-max"}, description = "max length of name"), +	protected int deobfuscationMaxLength = 40;, +, +	@Parameter(names = {"--deobf-rewrite-cfg"}, description = "force to save deobfuscation map"), +	protected boolean deobfuscationForceSave = false;, +, +, +	@Override, +	public boolean isDeobfuscationOn() {, +		return deobfuscationOn;, +	}, +, +	@Override, +	public int getDeobfuscationMinLength() {, +		return deobfuscationMinLength;, +	}, +, +	@Override, +	public int getDeobfuscationMaxLength() {, +		return deobfuscationMaxLength;, +	}, +, +	@Override, +	public boolean isDeobfuscationForceSave() {, +		return deobfuscationForceSave;, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf"}, description = "activate deobfuscation"), +	protected boolean deobfuscationOn = false;, +, +	@Parameter(names = {"--deobf-min"}, description = "min length of name"), +	protected int deobfuscationMinLength = 2;, +, +	@Parameter(names = {"--deobf-max"}, description = "max length of name"), +	protected int deobfuscationMaxLength = 40;, +, +	@Parameter(names = {"--deobf-rewrite-cfg"}, description = "force to save deobfuscation map"), +	protected boolean deobfuscationForceSave = false;, +, +, +	@Override, +	public boolean isDeobfuscationOn() {, +		return deobfuscationOn;, +	}, +, +	@Override, +	public int getDeobfuscationMinLength() {, +		return deobfuscationMinLength;, +	}, +, +	@Override, +	public int getDeobfuscationMaxLength() {, +		return deobfuscationMaxLength;, +	}, +, +	@Override, +	public boolean isDeobfuscationForceSave() {, +		return deobfuscationForceSave;, +	}, +++ b/jadx-core/build.gradle, +    compile 'commons-io:commons-io:2.4', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf"}, description = "activate deobfuscation"), +	protected boolean deobfuscationOn = false;, +, +	@Parameter(names = {"--deobf-min"}, description = "min length of name"), +	protected int deobfuscationMinLength = 2;, +, +	@Parameter(names = {"--deobf-max"}, description = "max length of name"), +	protected int deobfuscationMaxLength = 40;, +, +	@Parameter(names = {"--deobf-rewrite-cfg"}, description = "force to save deobfuscation map"), +	protected boolean deobfuscationForceSave = false;, +, +, +	@Override, +	public boolean isDeobfuscationOn() {, +		return deobfuscationOn;, +	}, +, +	@Override, +	public int getDeobfuscationMinLength() {, +		return deobfuscationMinLength;, +	}, +, +	@Override, +	public int getDeobfuscationMaxLength() {, +		return deobfuscationMaxLength;, +	}, +, +	@Override, +	public boolean isDeobfuscationForceSave() {, +		return deobfuscationForceSave;]
[+++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_KEY) IS present]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if(f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if(f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +		FieldNode fieldNode = mth.getParentClass().searchField(field);, +		if(fieldNode != null && fieldNode.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			return "";, +		}, +		// TODO: add jadx argument "add this", +		String argStr = arg(arg);, +		return argStr.isEmpty() ? name : argStr + "." + name;, +		ClassNode cls = mth.dex().resolveClass(insn.getClassType());, +			return;, +		}, +		if (insn.isSelf()) {, +			return;, +		}, +		if (insn.isSuper()) {, +			code.add("super");, +		} else if (insn.isThis()) {, +			code.add("this");, +		generateArguments(code, insn, 0, mth.dex().resolveMethod(insn.getCallMth()));, +				// FIXME: add 'this' for equals methods in scope, +				if (!arg.isThis()) {, +					String argStr = arg(arg);, +					if(!argStr.isEmpty()) {, +						code.add(argStr).add('.');, +					}, +		generateArguments(code, insn, k, callMthNode);, +	}, +	private void generateArguments(CodeWriter code, InsnNode insn, int k, MethodNode callMth) throws CodegenException {, +		if (callMth != null && callMth.getAttributes().contains(AttributeFlag.SKIP_FIRST_ARG)) {, +			k++;, +		}, +		int argsCount = insn.getArgsCount();, +		if (callMth != null && callMth.isArgsOverload()) {, +			// add additional argument casts for overloaded methods, +			List<ArgType> originalType = callMth.getMethodInfo().getArgumentsTypes();, +			int origPos = 0;, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if(f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +		FieldNode fieldNode = mth.getParentClass().searchField(field);, +		if(fieldNode != null && fieldNode.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			return "";, +		}, +		// TODO: add jadx argument "add this", +		String argStr = arg(arg);, +		return argStr.isEmpty() ? name : argStr + "." + name;, +		ClassNode cls = mth.dex().resolveClass(insn.getClassType());, +			return;, +		}, +		if (insn.isSelf()) {, +			return;, +		}, +		if (insn.isSuper()) {, +			code.add("super");, +		} else if (insn.isThis()) {, +			code.add("this");, +		generateArguments(code, insn, 0, mth.dex().resolveMethod(insn.getCallMth()));, +				// FIXME: add 'this' for equals methods in scope, +				if (!arg.isThis()) {, +					String argStr = arg(arg);, +					if(!argStr.isEmpty()) {, +						code.add(argStr).add('.');, +					}, +		generateArguments(code, insn, k, callMthNode);, +	}, +	private void generateArguments(CodeWriter code, InsnNode insn, int k, MethodNode callMth) throws CodegenException {, +		if (callMth != null && callMth.getAttributes().contains(AttributeFlag.SKIP_FIRST_ARG)) {, +			k++;, +		}, +		int argsCount = insn.getArgsCount();, +		if (callMth != null && callMth.isArgsOverload()) {, +			// add additional argument casts for overloaded methods, +			List<ArgType> originalType = callMth.getMethodInfo().getArgumentsTypes();, +			int origPos = 0;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +	SKIP_FIRST_ARG,, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if(f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +		FieldNode fieldNode = mth.getParentClass().searchField(field);, +		if(fieldNode != null && fieldNode.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			return "";]
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public Integer getSourceLine(int decompiledLine) {, +		decompile();, +		return cls.getCode().getLineMapping().get(decompiledLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public Integer getSourceLine(int decompiledLine) {, +		decompile();, +		return cls.getCode().getLineMapping().get(decompiledLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public Integer getSourceLine(int decompiledLine) {, +		decompile();, +		return cls.getCode().getLineMapping().get(decompiledLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private Map<Integer, Integer> lineMap = Collections.emptyMap();, +		for (Map.Entry<Integer, Integer> entry : code.lineMap.entrySet()) {, +			attachSourceLine(line + entry.getKey(), entry.getValue());, +		}, +	public CodeWriter addIndent() {, +		add(INDENT);, +		return this;, +	}, +, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new HashMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +	public Map<CodePosition, Object> getAnnotations() {, +		return annotations;, +	}, +, +	public void attachSourceLine(int sourceLine) {, +		attachSourceLine(line, sourceLine);, +	}, +, +	public Map<Integer, Integer> getLineMapping() {, +		return lineMap;, +	}, +, +		return str;, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public Integer getSourceLine(int decompiledLine) {, +		decompile();, +		return cls.getCode().getLineMapping().get(decompiledLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private Map<Integer, Integer> lineMap = Collections.emptyMap();, +		for (Map.Entry<Integer, Integer> entry : code.lineMap.entrySet()) {, +			attachSourceLine(line + entry.getKey(), entry.getValue());, +		}, +	public CodeWriter addIndent() {, +		add(INDENT);, +		return this;, +	}, +, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new HashMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +	public Map<CodePosition, Object> getAnnotations() {, +		return annotations;, +	}, +, +	public void attachSourceLine(int sourceLine) {, +		attachSourceLine(line, sourceLine);, +	}, +, +	public Map<Integer, Integer> getLineMapping() {, +		return lineMap;, +	}, +, +		return str;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.attachSourceLine(insn.getSourceLine());, +					String key = sw.getKeys()[i].toString();, +					code.startLine("case ").add(key).add(": goto ");, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +	public Integer getSourceLine(int decompiledLine) {, +		decompile();, +		return cls.getCode().getLineMapping().get(decompiledLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private Map<Integer, Integer> lineMap = Collections.emptyMap();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			code.startLineWithNum(region.getConditionSourceLine());, +			code.add("} while (");, +			code.startLineWithNum(region.getConditionSourceLine());, +			code.add("while (");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			code.startLineWithNum(region.getConditionSourceLine());, +			code.add("} while (");, +			code.startLineWithNum(region.getConditionSourceLine());, +			code.add("while (");, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +	/**, +	 * loop header contains one 'if' insn, equals null for infinite loop, +	 */, +	@Nullable, +	public LoopRegion(IRegion parent, LoopInfo info, @Nullable BlockNode header, boolean reversed) {, +	public int getConditionSourceLine() {, +		if (conditionBlock != null) {, +			List<InsnNode> condInsns = conditionBlock.getInstructions();, +			if (!condInsns.isEmpty()) {, +				return condInsns.get(0).getSourceLine();, +			}, +		}, +		return 0;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			code.add(f.getAlias());, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			code.add(f.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		code.add(field.getAlias());, +		code.add(field.getAlias());, +		code.add(callMth.getAlias());, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			code.add(f.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		code.add(field.getAlias());, +		code.add(field.getAlias());, +		code.add(callMth.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			code.add(mth.getAlias());, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			code.add(f.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		code.add(field.getAlias());, +		code.add(field.getAlias());, +		code.add(callMth.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			code.add(mth.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +						code.add(fn.getAlias());, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return field.getAlias();, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +		return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			code.add(f.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		code.add(field.getAlias());, +		code.add(field.getAlias());, +		code.add(callMth.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			code.add(mth.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +						code.add(fn.getAlias());, +++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfClsInfo.java, +package jadx.core.deobf;, +, +import jadx.core.dex.nodes.ClassNode;, +, +class DeobfClsInfo {, +	private final Deobfuscator deobfuscator;, +	private final ClassNode cls;]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java]
[+++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.AbstractAction;, +import javax.swing.KeyStroke;, +import java.awt.event.InputEvent;, +	private static final ImageIcon ICON_SEARCH = Utils.openIcon("magnifier");, +	private JToolBar searchToolBar;, +	private SearchBar searchBar;, +	private void toggleSearch() {, +		searchBar.toggle();, +	}, +, +		final JToggleButton flatPkgButton = new JToggleButton(ICON_FLAT_PKG);, +		toolbar.addSeparator();, +, +		final JButton searchButton = new JButton(ICON_SEARCH);, +		searchButton.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				toggleSearch();, +			}, +		});, +		searchButton.setToolTipText(NLS.str("search"));, +		toolbar.add(searchButton);, +, +		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_MASK);, +		Utils.addKeyBinding(textArea, key, "SearchAction", new AbstractAction() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				toggleSearch();, +			}, +		});, +		mainPanel.add(toolbar, BorderLayout.NORTH);, +		splitPane.setDividerLocation(200);, +		textArea = new RSyntaxTextArea();, +, +, +		JPanel textPanel = new JPanel(new BorderLayout());, +		searchBar = new SearchBar(textArea);, +		textPanel.add(searchBar.getToolBar(), BorderLayout.NORTH);, +		textPanel.add(scrollPane);, +		splitPane.setRightComponent(textPanel);, +			fileChooser.addChoosableFileFilter(new FileNameExtensionFilter("dex files", "dex", "apk", "jar"));, +				openFile(fileChooser.getSelectedFile());, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.AbstractAction;, +import javax.swing.KeyStroke;, +import java.awt.event.InputEvent;, +	private static final ImageIcon ICON_SEARCH = Utils.openIcon("magnifier");, +	private JToolBar searchToolBar;, +	private SearchBar searchBar;, +	private void toggleSearch() {, +		searchBar.toggle();, +	}, +, +		final JToggleButton flatPkgButton = new JToggleButton(ICON_FLAT_PKG);, +		toolbar.addSeparator();, +, +		final JButton searchButton = new JButton(ICON_SEARCH);, +		searchButton.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				toggleSearch();, +			}, +		});, +		searchButton.setToolTipText(NLS.str("search"));, +		toolbar.add(searchButton);, +, +		KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_MASK);, +		Utils.addKeyBinding(textArea, key, "SearchAction", new AbstractAction() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				toggleSearch();, +			}, +		});, +		mainPanel.add(toolbar, BorderLayout.NORTH);, +		splitPane.setDividerLocation(200);, +		textArea = new RSyntaxTextArea();, +, +, +		JPanel textPanel = new JPanel(new BorderLayout());, +		searchBar = new SearchBar(textArea);, +		textPanel.add(searchBar.getToolBar(), BorderLayout.NORTH);, +		textPanel.add(scrollPane);, +		splitPane.setRightComponent(textPanel);, +			fileChooser.addChoosableFileFilter(new FileNameExtensionFilter("dex files", "dex", "apk", "jar"));, +				openFile(fileChooser.getSelectedFile());, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.AbstractAction;, +import javax.swing.KeyStroke;, +import java.awt.event.InputEvent;, +	private static final ImageIcon ICON_SEARCH = Utils.openIcon("magnifier");, +	private JToolBar searchToolBar;, +	private SearchBar searchBar;]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				if (!this.getFullName().contains(fileName.replace(".java", "")), +						&& !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				if (!this.getFullName().contains(fileName.replace(".java", "")), +						&& !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			BlockNode loopExit = BlockUtils.selectOtherSafe(loopBody, condBlock.getCleanSuccessors());, +			if (loopExit != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				if (!this.getFullName().contains(fileName.replace(".java", "")), +						&& !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			BlockNode loopExit = BlockUtils.selectOtherSafe(loopBody, condBlock.getCleanSuccessors());, +			if (loopExit != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static BlockNode selectOtherSafe(BlockNode node, List<BlockNode> blocks) {, +		int size = blocks.size();, +		if (size == 1) {, +			BlockNode first = blocks.get(0);, +			return first != node ? first : null;, +		} else if (size == 2) {, +			BlockNode first = blocks.get(0);, +			return first != node ? first : blocks.get(1);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				if (!this.getFullName().contains(fileName.replace(".java", "")), +						&& !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			BlockNode loopExit = BlockUtils.selectOtherSafe(loopBody, condBlock.getCleanSuccessors());, +			if (loopExit != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static BlockNode selectOtherSafe(BlockNode node, List<BlockNode> blocks) {, +		int size = blocks.size();, +		if (size == 1) {, +			BlockNode first = blocks.get(0);, +			return first != node ? first : null;, +		} else if (size == 2) {, +			BlockNode first = blocks.get(0);, +			return first != node ? first : blocks.get(1);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopDetection3.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopDetection3 extends InternalJadxTest {, +, +	public static class TestCls {, +, +		private void test(TestCls parent, int pos) {, +			Object item;, +			while (--pos >= 0) {, +				item = parent.get(pos);, +				if (item instanceof String) {, +					func((String) item);, +					return;, +				}, +			}, +		}, +, +		private Object get(int pos) {, +			return null;, +		}, +, +		private void func(String item) {, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsString("while"));, +		// TODO, +		// assertThat(code, containsString("while (--pos >= 0) {"));, +	}, +}]
[+++ /dev/null, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-cli/src/main/resources/logback.xml, +, +, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-cli/src/main/resources/logback.xml, +, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-cli/src/main/resources/logback.xml, +, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +				passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoApplyVisitor());, +			}, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-cli/src/main/resources/logback.xml, +, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo alias = getAlias();, +		return alias.getPackage().replace('.', File.separatorChar), +				+ alias.getNameWithoutPackage().replace('.', '_');]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Font;, +import java.awt.GraphicsDevice;, +import java.awt.GraphicsEnvironment;, +import java.awt.Window;, +		if (pos == null || !isContainedInAnyScreen(pos)) {, +, +	private static boolean isContainedInAnyScreen(WindowLocation pos) {, +		for (GraphicsDevice gd : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {, +			if (gd.getDefaultConfiguration().getBounds().contains(, +					pos.getX(), pos.getY(), pos.getWidth(), pos.getHeight())) {, +				return true;, +			}, +		}, +		return false;, +	}, +]
[+++ b/src/main/java/jadx/codegen/RegionGen.java, +import jadx.dex.regions.IfCondition;, +		code.add("if (").add(makeCondition(region.getCondition())).add(") {");, +				List<IContainer> subBlocks = re.getSubBlocks();, +				if (subBlocks.size() == 1 && subBlocks.get(0) instanceof IfRegion) {, +					makeIf((IfRegion) subBlocks.get(0), code);, +		IfCondition condition = region.getCondition();, +		if (condition == null) {, +		if (region.isConditionAtEnd()) {, +			code.startLine("} while (").add(makeCondition(condition)).add(");");, +		} else {, +			code.startLine("while (").add(makeCondition(condition)).add(") {");, +			makeRegionIndent(code, region.getBody());, +			code.startLine('}');, +	private String makeCondition(IfCondition condition) throws CodegenException {, +		switch (condition.getMode()) {, +			case COMPARE:, +				return makeCompare(condition.getCompare());, +			case NOT:, +				return "!" + makeCondition(condition.getArgs().get(0));, +			case AND:, +			case OR:, +				String mode = condition.getMode() == IfCondition.MODE.AND ? " && " : " || ";, +				CodeWriter cw = new CodeWriter();, +				for (IfCondition arg : condition.getArgs()) {, +					if (cw.notEmpty()) {, +						cw.add(mode);, +					cw.add('(').add(makeCondition(arg)).add(')');, +				}, +				return cw.toString();, +			default:, +				return "??" + condition.toString();, +		}, +	private String makeCompare(IfCondition.Compare compare) throws CodegenException {, +		IfOp op = compare.getOp();, +		InsnArg firstArg = compare.getA();, +		InsnArg secondArg = compare.getB();, +		if (firstArg.getType().equals(ArgType.BOOLEAN), +				&& secondArg.isLiteral(), +				&& secondArg.getType().equals(ArgType.BOOLEAN)) {, +				return arg(firstArg); // == true, +				return "!" + arg(firstArg); // != true, +		return arg(firstArg) + " " + op.getSymbol() + " " + arg(secondArg);, +++ b/src/main/java/jadx/codegen/RegionGen.java, +import jadx.dex.regions.IfCondition;, +		code.add("if (").add(makeCondition(region.getCondition())).add(") {");, +				List<IContainer> subBlocks = re.getSubBlocks();, +				if (subBlocks.size() == 1 && subBlocks.get(0) instanceof IfRegion) {, +					makeIf((IfRegion) subBlocks.get(0), code);, +		IfCondition condition = region.getCondition();, +		if (condition == null) {, +		if (region.isConditionAtEnd()) {, +			code.startLine("} while (").add(makeCondition(condition)).add(");");, +		} else {, +			code.startLine("while (").add(makeCondition(condition)).add(") {");, +			makeRegionIndent(code, region.getBody());, +			code.startLine('}');, +	private String makeCondition(IfCondition condition) throws CodegenException {, +		switch (condition.getMode()) {, +			case COMPARE:, +				return makeCompare(condition.getCompare());, +			case NOT:, +				return "!" + makeCondition(condition.getArgs().get(0));, +			case AND:, +			case OR:, +				String mode = condition.getMode() == IfCondition.MODE.AND ? " && " : " || ";, +				CodeWriter cw = new CodeWriter();, +				for (IfCondition arg : condition.getArgs()) {, +					if (cw.notEmpty()) {, +						cw.add(mode);, +					cw.add('(').add(makeCondition(arg)).add(')');, +				}, +				return cw.toString();, +			default:, +				return "??" + condition.toString();, +		}, +	private String makeCompare(IfCondition.Compare compare) throws CodegenException {, +		IfOp op = compare.getOp();, +		InsnArg firstArg = compare.getA();, +		InsnArg secondArg = compare.getB();, +		if (firstArg.getType().equals(ArgType.BOOLEAN), +				&& secondArg.isLiteral(), +				&& secondArg.getType().equals(ArgType.BOOLEAN)) {, +				return arg(firstArg); // == true, +				return "!" + arg(firstArg); // != true, +		return arg(firstArg) + " " + op.getSymbol() + " " + arg(secondArg);, +++ b/src/main/java/jadx/dex/attributes/AttributeFlag.java, +	SKIP,, +++ b/src/main/java/jadx/codegen/RegionGen.java, +import jadx.dex.regions.IfCondition;, +		code.add("if (").add(makeCondition(region.getCondition())).add(") {");, +				List<IContainer> subBlocks = re.getSubBlocks();, +				if (subBlocks.size() == 1 && subBlocks.get(0) instanceof IfRegion) {, +					makeIf((IfRegion) subBlocks.get(0), code);, +		IfCondition condition = region.getCondition();, +		if (condition == null) {, +		if (region.isConditionAtEnd()) {, +			code.startLine("} while (").add(makeCondition(condition)).add(");");, +		} else {, +			code.startLine("while (").add(makeCondition(condition)).add(") {");]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}]
[+++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import javax.swing.ImageIcon;, +import javax.swing.JButton;, +import javax.swing.JToggleButton;, +import javax.swing.JToolBar;, +import javax.swing.tree.TreePath;, +	private static final String DEFAULT_TITLE = "jadx-gui";, +	private static final Color BACKGROUND = new Color(0xf7f7f7);, +, +	private static final ImageIcon ICON_OPEN = Utils.openIcon("folder");, +	private static final ImageIcon ICON_CLOSE = Utils.openIcon("cross");, +	private static final ImageIcon ICON_FLAT_PKG = Utils.openIcon("empty_logical_package_obj");, +		initMenuAndToolbar();, +//		expandTree();, +	}, +, +	private void toggleFlattenPackage() {, +		Object root = treeModel.getRoot();, +		if (root instanceof JRoot) {, +			JRoot treeRoot = (JRoot) root;, +			treeRoot.setFlatPackages(!treeRoot.isFlatPackages());, +			treeModel.reload();, +			tree.expandRow(0);, +		}, +	}, +, +	private void expandTree() {, +		DefaultMutableTreeNode currentNode = ((DefaultMutableTreeNode) tree.getModel().getRoot()).getNextNode();, +		do {, +			if (currentNode.getLevel() == 1) {, +				tree.expandPath(new TreePath(currentNode.getPath()));, +			}, +			currentNode = currentNode.getNextNode();, +		}, +		while (currentNode != null);, +	}, +, +	private void initMenuAndToolbar() {, +		JMenuBar menuBar = new JMenuBar();, +, +		JMenu file = new JMenu("File");, +		file.setMnemonic(KeyEvent.VK_F);, +, +		JMenuItem exit = new JMenuItem("Exit", ICON_CLOSE);, +		exit.setMnemonic(KeyEvent.VK_E);, +		exit.setToolTipText("Exit application");, +		exit.addActionListener(new ActionListener() {, +			public void actionPerformed(ActionEvent event) {, +				System.exit(0);, +			}, +		});, +, +		JMenuItem open = new JMenuItem("Open", ICON_OPEN);, +		open.setMnemonic(KeyEvent.VK_E);, +		open.setToolTipText("Open file");, +		open.addActionListener(new OpenListener());, +, +		file.add(open);, +		file.addSeparator();, +		file.add(exit);, +, +		menuBar.add(file);, +		setJMenuBar(menuBar);, +, +		JToolBar toolbar = new JToolBar();, +		toolbar.setFloatable(false);, +, +		JButton openButton = new JButton(ICON_OPEN);, +		openButton.addActionListener(new OpenListener());, +		openButton.setToolTipText(NLS.str("file.open"));, +, +		toolbar.add(openButton);, +		toolbar.addSeparator();, +, +		JToggleButton flatPkgButton = new JToggleButton(ICON_FLAT_PKG);, +		flatPkgButton.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				toggleFlattenPackage();, +			}, +		});, +		flatPkgButton.setToolTipText(NLS.str("tree.flatten"));, +		toolbar.add(flatPkgButton);, +, +		toolbar.addSeparator();, +, +		add(toolbar, BorderLayout.NORTH);, +, +	private class OpenListener implements ActionListener {, +		public void actionPerformed(ActionEvent event) {, +			JFileChooser fileChooser = new JFileChooser();, +			FileFilter filter = new FileNameExtensionFilter("dex files", "dex", "apk", "jar");, +			fileChooser.addChoosableFileFilter(filter);, +			int ret = fileChooser.showDialog(mainPanel, "Open file");, +			if (ret == JFileChooser.APPROVE_OPTION) {, +				File file = fileChooser.getSelectedFile();, +				openFile(file);, +			}, +		}, +	}]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-r", "--no-res"}, description = "do not decode resources"), +	protected boolean skipResources = false;, +, +	@Parameter(names = {"-s", "--no-src"}, description = "do not decompile source code"), +	protected boolean skipSources = false;, +, +	public boolean isSkipResources() {, +		return skipResources;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +		return skipSources;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-r", "--no-res"}, description = "do not decode resources"), +	protected boolean skipResources = false;, +, +	@Parameter(names = {"-s", "--no-src"}, description = "do not decompile source code"), +	protected boolean skipSources = false;, +, +	public boolean isSkipResources() {, +		return skipResources;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +		return skipSources;, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isSkipResources() {, +		return false;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-r", "--no-res"}, description = "do not decode resources"), +	protected boolean skipResources = false;, +, +	@Parameter(names = {"-s", "--no-src"}, description = "do not decompile source code"), +	protected boolean skipSources = false;, +, +	public boolean isSkipResources() {, +		return skipResources;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +		return skipSources;, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isSkipResources() {, +		return false;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	boolean isSkipResources();, +, +	boolean isSkipSources();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-r", "--no-res"}, description = "do not decode resources"), +	protected boolean skipResources = false;, +, +	@Parameter(names = {"-s", "--no-src"}, description = "do not decompile source code"), +	protected boolean skipSources = false;, +, +	public boolean isSkipResources() {, +		return skipResources;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +		return skipSources;, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +	public boolean isSkipResources() {, +		return false;, +	}, +, +	@Override, +	public boolean isSkipSources() {, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	boolean isSkipResources();, +, +	boolean isSkipSources();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeWriter;, +	private List<ResourceFile> resources;, +, +	private BinaryXMLParser xmlParser;, +		resources = null;, +		xmlParser = null;, +		save(!args.isSkipSources(), !args.isSkipResources());, +	}, +	public void saveSources() {, +		save(true, false);, +	}, +, +	public void saveResources() {, +		save(false, true);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public boolean canBeObject() {, +		return isObject() || (!isTypeKnown() && contains(PrimitiveType.OBJECT));, +	}, +, +	public boolean canBeArray() {, +		return isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public boolean canBeObject() {, +		return isObject() || (!isTypeKnown() && contains(PrimitiveType.OBJECT));, +	}, +, +	public boolean canBeArray() {, +		return isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +		TypeUpdateResult result = updateTypeChecked(updateInfo, updateArg, candidateType);, +		if (result == REJECT) {, +			// soft checks for objects and array - exact type not compared, +			ArgType updateArgType = updateArg.getType();, +			if (candidateType.isObject() && updateArgType.canBeObject()) {, +				return SAME;, +			}, +			if (candidateType.isArray() && updateArgType.canBeArray()) {, +				return SAME;, +			}, +		}, +		return result;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public boolean canBeObject() {, +		return isObject() || (!isTypeKnown() && contains(PrimitiveType.OBJECT));, +	}, +, +	public boolean canBeArray() {, +		return isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +		TypeUpdateResult result = updateTypeChecked(updateInfo, updateArg, candidateType);, +		if (result == REJECT) {, +			// soft checks for objects and array - exact type not compared, +			ArgType updateArgType = updateArg.getType();, +			if (candidateType.isObject() && updateArgType.canBeObject()) {, +				return SAME;, +			}, +			if (candidateType.isArray() && updateArgType.canBeArray()) {, +				return SAME;, +			}, +		}, +		return result;, +++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestConstTypeInference.java, +package jadx.tests.integration.types;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.anyOf;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotEquals;, +import static org.junit.Assert.assertThat;, +, +public class TestConstTypeInference extends IntegrationTest {, +, +	public static class TestCls {, +		private final int a;, +, +		public TestCls() {, +			this(0);, +		}, +, +		public TestCls(int a) {, +			this.a = a;, +		}, +, +		public boolean equals(Object obj) {, +			if (obj == this) {, +				return true;, +			}, +			if (obj != null) {, +				if (getClass() == obj.getClass()) {, +					TestCls other = (TestCls) obj;, +					return this.a == other.a;, +				}, +			}, +			return false;, +		}, +, +		public void check() {, +			TestCls seven = new TestCls(7);, +			assertEquals(seven, seven);, +			assertNotEquals(seven, null);, +, +			TestCls six = new TestCls(6);, +			assertNotEquals(seven, six);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		if (iterVar == null) {, +			return false;, +		}, +					if (!fixIterableType(mth, iterableArg, iterVar)) {, +						return false;, +					}, +					if (iterVar == null || !fixIterableType(mth, iterableArg, iterVar)) {, +						return false;, +					}, +	private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, RegisterArg iterVar) {, +			if (ArgType.isInstanceOf(mth.dex(), gType, varType)) {, +			ArgType wildcardType = gType.getWildcardType();, +			if (wildcardType != null, +					&& gType.getWildcardBounds() == 1, +					&& ArgType.isInstanceOf(mth.dex(), wildcardType, varType)) {, +				return true;, +			}, +			LOG.warn("Generic type differs: '{}' and '{}' in {}", gType, varType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		if (iterVar == null) {, +			return false;, +		}, +					if (!fixIterableType(mth, iterableArg, iterVar)) {, +						return false;, +					}, +					if (iterVar == null || !fixIterableType(mth, iterableArg, iterVar)) {, +						return false;, +					}, +	private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, RegisterArg iterVar) {, +			if (ArgType.isInstanceOf(mth.dex(), gType, varType)) {, +			ArgType wildcardType = gType.getWildcardType();, +			if (wildcardType != null, +					&& gType.getWildcardBounds() == 1, +					&& ArgType.isInstanceOf(mth.dex(), wildcardType, varType)) {, +				return true;, +			}, +			LOG.warn("Generic type differs: '{}' and '{}' in {}", gType, varType, mth);, +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestGenerics6.java, +package jadx.tests.integration.generics;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.Collection;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestGenerics6 extends IntegrationTest {, +, +	public static class TestCls {, +		public void test1(Collection<? extends A> as) {, +			for (A a : as) {, +				a.f();, +			}, +		}, +, +		public void test2(Collection<? extends A> is) {, +			for (I i : is) {, +				i.f();, +			}, +		}, +, +		private interface  I {, +			void f();, +		}, +, +		private class A implements I {, +			public void f() {, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("for (A a : as) {"));, +		// TODO: fix iterable arg type (unexpected cast to A in bytecode), +//		assertThat(code, containsOne("for (I i : is) {"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		domsOn.xor(succ); // filter 'out' block, +			List<BlockNode> blocks = mth.getBasicBlocks();, +				BlockNode b = blocks.get(i);, +					domsOn.clear(s.getId());, +			// one or several case blocks are empty,, +			// run expensive algorithm for find 'out' block, +			for (BlockNode maybeOut : block.getSuccessors()) {, +				boolean allReached = true;, +				for (BlockNode s : block.getSuccessors()) {, +					if (!BlockUtils.isPathExists(s, maybeOut)) {, +						allReached = false;, +						break;, +					}, +				}, +				if (allReached) {, +					out = maybeOut;, +					break;, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		domsOn.xor(succ); // filter 'out' block, +			List<BlockNode> blocks = mth.getBasicBlocks();, +				BlockNode b = blocks.get(i);, +					domsOn.clear(s.getId());, +			// one or several case blocks are empty,, +			// run expensive algorithm for find 'out' block, +			for (BlockNode maybeOut : block.getSuccessors()) {, +				boolean allReached = true;, +				for (BlockNode s : block.getSuccessors()) {, +					if (!BlockUtils.isPathExists(s, maybeOut)) {, +						allReached = false;, +						break;, +					}, +				}, +				if (allReached) {, +					out = maybeOut;, +					break;, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		if (start == end || end.isDominator(start)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		domsOn.xor(succ); // filter 'out' block, +			List<BlockNode> blocks = mth.getBasicBlocks();, +				BlockNode b = blocks.get(i);, +					domsOn.clear(s.getId());, +			// one or several case blocks are empty,, +			// run expensive algorithm for find 'out' block, +			for (BlockNode maybeOut : block.getSuccessors()) {, +				boolean allReached = true;, +				for (BlockNode s : block.getSuccessors()) {, +					if (!BlockUtils.isPathExists(s, maybeOut)) {, +						allReached = false;, +						break;, +					}, +				}, +				if (allReached) {, +					out = maybeOut;, +					break;, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		if (start == end || end.isDominator(start)) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		domsOn.xor(succ); // filter 'out' block, +			List<BlockNode> blocks = mth.getBasicBlocks();, +				BlockNode b = blocks.get(i);, +					domsOn.clear(s.getId());, +			// one or several case blocks are empty,, +			// run expensive algorithm for find 'out' block, +			for (BlockNode maybeOut : block.getSuccessors()) {, +				boolean allReached = true;, +				for (BlockNode s : block.getSuccessors()) {, +					if (!BlockUtils.isPathExists(s, maybeOut)) {, +						allReached = false;, +						break;, +					}, +				}, +				if (allReached) {, +					out = maybeOut;, +					break;, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		if (start == end || end.isDominator(start)) {, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java]
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, +		synchronized (getSyncObj(cls)) {, +	public static Object getSyncObj(ClassNode cls) {, +		return cls.getClassInfo();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, +		synchronized (getSyncObj(cls)) {, +	public static Object getSyncObj(ClassNode cls) {, +		return cls.getClassInfo();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		int len = NL.length();, +		if (buf.substring(0, len).equals(NL)) {, +			buf.delete(0, len);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, +		synchronized (getSyncObj(cls)) {, +	public static Object getSyncObj(ClassNode cls) {, +		return cls.getClassInfo();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		int len = NL.length();, +		if (buf.substring(0, len).equals(NL)) {, +			buf.delete(0, len);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import java.util.LinkedHashSet;, +	private final Set<String> varNames = new LinkedHashSet<>();, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, +		synchronized (getSyncObj(cls)) {, +	public static Object getSyncObj(ClassNode cls) {, +		return cls.getClassInfo();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		int len = NL.length();, +		if (buf.substring(0, len).equals(NL)) {, +			buf.delete(0, len);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import java.util.LinkedHashSet;, +	private final Set<String> varNames = new LinkedHashSet<>();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import java.util.LinkedHashMap;, +		this.blockBinds = new LinkedHashMap<>(predecessors);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, +		synchronized (getSyncObj(cls)) {, +	public static Object getSyncObj(ClassNode cls) {, +		return cls.getClassInfo();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		int len = NL.length();, +		if (buf.substring(0, len).equals(NL)) {, +			buf.delete(0, len);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import java.util.LinkedHashSet;, +	private final Set<String> varNames = new LinkedHashSet<>();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import java.util.LinkedHashMap;, +		this.blockBinds = new LinkedHashMap<>(predecessors);, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +		this(condition, thenBlock, elseBlock, new HashSet<>(), new HashSet<>());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, +		synchronized (getSyncObj(cls)) {, +	public static Object getSyncObj(ClassNode cls) {, +		return cls.getClassInfo();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		int len = NL.length();, +		if (buf.substring(0, len).equals(NL)) {, +			buf.delete(0, len);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import java.util.LinkedHashSet;, +	private final Set<String> varNames = new LinkedHashSet<>();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import java.util.Comparator;, +	public static final Comparator<MethodNode> METHOD_LINE_COMPARATOR = new Comparator<MethodNode>() {, +		@Override, +		public int compare(MethodNode a, MethodNode b) {, +			return Utils.compare(a.getSourceLine(), b.getSourceLine());, +		}, +	};, +, +		List<MethodNode> methods = sortMethodsByLine(cls.getMethods());, +		for (MethodNode mth : methods) {, +	private static List<MethodNode> sortMethodsByLine(List<MethodNode> methods) {, +		List<MethodNode> out = new ArrayList<MethodNode>(methods);, +		Collections.sort(out, METHOD_LINE_COMPARATOR);, +		return out;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import java.util.Comparator;, +	public static final Comparator<MethodNode> METHOD_LINE_COMPARATOR = new Comparator<MethodNode>() {, +		@Override, +		public int compare(MethodNode a, MethodNode b) {, +			return Utils.compare(a.getSourceLine(), b.getSourceLine());, +		}, +	};, +, +		List<MethodNode> methods = sortMethodsByLine(cls.getMethods());, +		for (MethodNode mth : methods) {, +	private static List<MethodNode> sortMethodsByLine(List<MethodNode> methods) {, +		List<MethodNode> out = new ArrayList<MethodNode>(methods);, +		Collections.sort(out, METHOD_LINE_COMPARATOR);, +		return out;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +, +	public static int compare(int x, int y) {, +		return (x < y) ? -1 : ((x == y) ? 0 : 1);, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return getConstField((char) literal, Math.abs(literal) > 10);, +				return getConstField((byte) literal, Math.abs(literal) > 10);, +				return getConstField((short) literal, Math.abs(literal) > 100);, +				return getConstField((int) literal, Math.abs(literal) > 100);, +				return getConstField(literal, Math.abs(literal) > 1000);, +				float f = Float.intBitsToFloat((int) literal);, +				return getConstField(f, f != 0.0);, +				double d = Double.longBitsToDouble(literal);, +				return getConstField(d, d != 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return getConstField((char) literal, Math.abs(literal) > 10);, +				return getConstField((byte) literal, Math.abs(literal) > 10);, +				return getConstField((short) literal, Math.abs(literal) > 100);, +				return getConstField((int) literal, Math.abs(literal) > 100);, +				return getConstField(literal, Math.abs(literal) > 1000);, +				float f = Float.intBitsToFloat((int) literal);, +				return getConstField(f, f != 0.0);, +				double d = Double.longBitsToDouble(literal);, +				return getConstField(d, d != 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.nodes.FieldNode;, +			if (useInsn == null || useInsn.getType() == InsnType.PHI) {, +, +				FieldNode f = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +				if (f != null) {, +					litArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return getConstField((char) literal, Math.abs(literal) > 10);, +				return getConstField((byte) literal, Math.abs(literal) > 10);, +				return getConstField((short) literal, Math.abs(literal) > 100);, +				return getConstField((int) literal, Math.abs(literal) > 100);, +				return getConstField(literal, Math.abs(literal) > 1000);, +				float f = Float.intBitsToFloat((int) literal);, +				return getConstField(f, f != 0.0);, +				double d = Double.longBitsToDouble(literal);, +				return getConstField(d, d != 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.nodes.FieldNode;, +			if (useInsn == null || useInsn.getType() == InsnType.PHI) {, +, +				FieldNode f = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +				if (f != null) {, +					litArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java]
[+++ b/.gitignore, +.attach_pid*, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, +		if (ai.isConstructor()) {, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, +		if (ai.isConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +						mth.setAlias(String.format("mo%d%s", id, prepareNamePart(mth.getName())));, +			alias = String.format("C%04d%s", clsIndex++, prepareNamePart(clsName));, +		String alias = String.format("f%d%s", fldIndex++, prepareNamePart(field.getName()));, +		String alias = String.format("m%d%s", mthIndex++, prepareNamePart(mth.getName()));, +			String pkgAlias = String.format("p%03d%s", pkgIndex++, prepareNamePart(pkgName));, +		int len = s.length();, +		return len < minLength || len > maxLength, +				|| !NameMapper.isValidIdentifier(s);, +	private String prepareNamePart(String name) {, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, +		if (ai.isConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +						mth.setAlias(String.format("mo%d%s", id, prepareNamePart(mth.getName())));, +			alias = String.format("C%04d%s", clsIndex++, prepareNamePart(clsName));, +		String alias = String.format("f%d%s", fldIndex++, prepareNamePart(field.getName()));, +		String alias = String.format("m%d%s", mthIndex++, prepareNamePart(mth.getName()));, +			String pkgAlias = String.format("p%03d%s", pkgIndex++, prepareNamePart(pkgName));, +		int len = s.length();, +		return len < minLength || len > maxLength, +				|| !NameMapper.isValidIdentifier(s);, +	private String prepareNamePart(String name) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +				&& !isReserved(str), +				&& !isReserved(str), +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, +		if (ai.isConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +						mth.setAlias(String.format("mo%d%s", id, prepareNamePart(mth.getName())));, +			alias = String.format("C%04d%s", clsIndex++, prepareNamePart(clsName));, +		String alias = String.format("f%d%s", fldIndex++, prepareNamePart(field.getName()));, +		String alias = String.format("m%d%s", mthIndex++, prepareNamePart(mth.getName()));, +			String pkgAlias = String.format("p%03d%s", pkgIndex++, prepareNamePart(pkgName));, +		int len = s.length();, +		return len < minLength || len > maxLength, +				|| !NameMapper.isValidIdentifier(s);, +	private String prepareNamePart(String name) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +				&& !isReserved(str), +				&& !isReserved(str), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import jadx.core.deobf.NameMapper;, +			String fieldName = fieldInfo.getAlias();, +			if (!names.add(fieldName) || !NameMapper.isValidIdentifier(fieldName)) {, +			if (mth.contains(AFlag.DONT_GENERATE) || mth.getAccessFlags().isConstructor()) {, +			if (!names.add(signature) || !NameMapper.isValidIdentifier(mth.getAlias())) {, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, +		if (ai.isConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +						mth.setAlias(String.format("mo%d%s", id, prepareNamePart(mth.getName())));, +			alias = String.format("C%04d%s", clsIndex++, prepareNamePart(clsName));, +		String alias = String.format("f%d%s", fldIndex++, prepareNamePart(field.getName()));, +		String alias = String.format("m%d%s", mthIndex++, prepareNamePart(mth.getName()));, +			String pkgAlias = String.format("p%03d%s", pkgIndex++, prepareNamePart(pkgName));, +		int len = s.length();, +		return len < minLength || len > maxLength, +				|| !NameMapper.isValidIdentifier(s);, +	private String prepareNamePart(String name) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +				&& !isReserved(str), +				&& !isReserved(str), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import jadx.core.deobf.NameMapper;, +			String fieldName = fieldInfo.getAlias();, +			if (!names.add(fieldName) || !NameMapper.isValidIdentifier(fieldName)) {, +			if (mth.contains(AFlag.DONT_GENERATE) || mth.getAccessFlags().isConstructor()) {, +			if (!names.add(signature) || !NameMapper.isValidIdentifier(mth.getAlias())) {, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.core.utils.exceptions.JadxException;, +		List<IDexTreeVisitor> passes = getPassesList(jadx);, +	protected void decompileWithoutUnload(JadxDecompiler jadx, ClassNode cls) {, +		List<IDexTreeVisitor> passes = getPassesList(jadx);, +	private List<IDexTreeVisitor> getPassesList(JadxDecompiler jadx) {, +		RootNode root = JadxInternalAccess.getRoot(jadx);, +		List<IDexTreeVisitor> passesList = Jadx.getPassesList(jadx.getArgs());, +		passesList.forEach(pass -> {, +			try {, +				pass.init(root);, +			} catch (JadxException e) {]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.LinkedHashSet;, +		Set<ClassNode> clsParents = new LinkedHashSet<>();, +		collectClassHierarchy(mth.getParentClass(), clsParents);, +, +		Set<MethodInfo> overrideSet = new LinkedHashSet<>();, +		for (ClassNode classNode : clsParents) {, +			MethodInfo methodInfo = getMthOverride(classNode.getMethods(), mthSignature);, +			if (methodInfo != null) {, +				overrideSet.add(methodInfo);, +		if (overrideSet.isEmpty()) {, +			return;, +		}, +		OverridedMethodsNode overrideNode = getOverrideMethodsNode(overrideSet);, +		for (MethodInfo overrideMth : overrideSet) {, +			if (!ovrdMap.containsKey(overrideMth)) {, +				ovrdMap.put(overrideMth, overrideNode);, +				overrideNode.add(overrideMth);, +, +	private OverridedMethodsNode getOverrideMethodsNode(Set<MethodInfo> overrideSet) {, +		for (MethodInfo overrideMth : overrideSet) {, +			OverridedMethodsNode node = ovrdMap.get(overrideMth);, +			if (node != null) {, +				return node;, +		}, +		return null;, +	}, +, +	private MethodInfo getMthOverride(List<MethodNode> methods, String mthSignature) {, +		for (MethodNode m : methods) {, +			MethodInfo mthInfo = m.getMethodInfo();, +			if (mthInfo.getShortId().startsWith(mthSignature)) {, +				return mthInfo;, +			}, +		}, +		return null;, +	}, +, +	private void collectClassHierarchy(ClassNode cls, Set<ClassNode> collected) {, +		boolean added = collected.add(cls);, +		if (added) {, +			ArgType superClass = cls.getSuperClass();, +			if (superClass != null) {, +				ClassNode superNode = cls.dex().resolveClass(superClass);, +				if (superNode != null) {, +					collectClassHierarchy(superNode, collected);, +				}, +			}, +, +			for (ArgType argType : cls.getInterfaces()) {, +				ClassNode interfaceNode = cls.dex().resolveClass(argType);, +				if (interfaceNode != null) {, +					collectClassHierarchy(interfaceNode, collected);, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.LinkedHashSet;, +		Set<ClassNode> clsParents = new LinkedHashSet<>();, +		collectClassHierarchy(mth.getParentClass(), clsParents);, +, +		Set<MethodInfo> overrideSet = new LinkedHashSet<>();, +		for (ClassNode classNode : clsParents) {, +			MethodInfo methodInfo = getMthOverride(classNode.getMethods(), mthSignature);, +			if (methodInfo != null) {, +				overrideSet.add(methodInfo);, +		if (overrideSet.isEmpty()) {, +			return;, +		}, +		OverridedMethodsNode overrideNode = getOverrideMethodsNode(overrideSet);, +		for (MethodInfo overrideMth : overrideSet) {, +			if (!ovrdMap.containsKey(overrideMth)) {, +				ovrdMap.put(overrideMth, overrideNode);, +				overrideNode.add(overrideMth);, +, +	private OverridedMethodsNode getOverrideMethodsNode(Set<MethodInfo> overrideSet) {, +		for (MethodInfo overrideMth : overrideSet) {, +			OverridedMethodsNode node = ovrdMap.get(overrideMth);, +			if (node != null) {, +				return node;, +		}, +		return null;, +	}, +, +	private MethodInfo getMthOverride(List<MethodNode> methods, String mthSignature) {, +		for (MethodNode m : methods) {, +			MethodInfo mthInfo = m.getMethodInfo();, +			if (mthInfo.getShortId().startsWith(mthSignature)) {, +				return mthInfo;, +			}, +		}, +		return null;, +	}, +, +	private void collectClassHierarchy(ClassNode cls, Set<ClassNode> collected) {, +		boolean added = collected.add(cls);, +		if (added) {, +			ArgType superClass = cls.getSuperClass();, +			if (superClass != null) {, +				ClassNode superNode = cls.dex().resolveClass(superClass);]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.searchField(field);, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.searchField(field);, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ArgType superClass = cls.getSuperClass();, +				ClassNode superNode = cls.dex().resolveClass(superClass);, +				if (superNode != null) {, +					collectClassHierarchy(superNode, collected);, +				}, +			for (ArgType argType : cls.getInterfaces()) {, +				ClassNode interfaceNode = cls.dex().resolveClass(argType);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.searchField(field);, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ArgType superClass = cls.getSuperClass();, +				ClassNode superNode = cls.dex().resolveClass(superClass);, +				if (superNode != null) {, +					collectClassHierarchy(superNode, collected);, +				}, +			for (ArgType argType : cls.getInterfaces()) {, +				ClassNode interfaceNode = cls.dex().resolveClass(argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.searchField(field);, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ArgType superClass = cls.getSuperClass();, +				ClassNode superNode = cls.dex().resolveClass(superClass);, +				if (superNode != null) {, +					collectClassHierarchy(superNode, collected);, +				}, +			for (ArgType argType : cls.getInterfaces()) {, +				ClassNode interfaceNode = cls.dex().resolveClass(argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.searchField(field);, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			pCls = pCls.getParentClass();, +			fieldNode = pCls.searchField(field);, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ArgType superClass = cls.getSuperClass();, +				ClassNode superNode = cls.dex().resolveClass(superClass);, +				if (superNode != null) {, +					collectClassHierarchy(superNode, collected);, +				}, +			for (ArgType argType : cls.getInterfaces()) {, +				ClassNode interfaceNode = cls.dex().resolveClass(argType);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				this.interfaces.add(dex.getType(interfaceIdx));, +	@TestOnly, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.Random;, +	private final Map<String, String> tagAttrDeobfNames = new HashMap<>();, +		currentTag = getValidTagAttributeName(getString(startNSName));, +		String attrName = getValidTagAttributeName(getAttributeName(attributeName));, +		String elemName = getValidTagAttributeName(getString(elementNameId));, +	, +	private String getValidTagAttributeName(String originalName) {, +		if(XMLChar.isValidName(originalName)) {, +			return originalName;, +		}, +		if(tagAttrDeobfNames.containsKey(originalName)) {, +			return tagAttrDeobfNames.get(originalName);, +		}, +		String generated;, +		do {, +			generated = generateTagAttrName();, +		}, +		while(tagAttrDeobfNames.containsValue(generated));, +		tagAttrDeobfNames.put(originalName, generated);, +		return generated;, +	}, +	, +	private static String generateTagAttrName() {, +		final int length = 6;, +		Random r = new Random();, +		StringBuilder sb = new StringBuilder();, +		for(int i = 1; i <= length; i++) {, +			sb.append((char)(r.nextInt(26) + 'a'));, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.Random;, +	private final Map<String, String> tagAttrDeobfNames = new HashMap<>();, +		currentTag = getValidTagAttributeName(getString(startNSName));, +		String attrName = getValidTagAttributeName(getAttributeName(attributeName));, +		String elemName = getValidTagAttributeName(getString(elementNameId));, +	, +	private String getValidTagAttributeName(String originalName) {, +		if(XMLChar.isValidName(originalName)) {, +			return originalName;, +		}, +		if(tagAttrDeobfNames.containsKey(originalName)) {, +			return tagAttrDeobfNames.get(originalName);, +		}, +		String generated;, +		do {, +			generated = generateTagAttrName();, +		}, +		while(tagAttrDeobfNames.containsValue(generated));, +		tagAttrDeobfNames.put(originalName, generated);, +		return generated;, +	}, +	, +	private static String generateTagAttrName() {, +		final int length = 6;, +		Random r = new Random();, +		StringBuilder sb = new StringBuilder();, +		for(int i = 1; i <= length; i++) {, +			sb.append((char)(r.nextInt(26) + 'a'));, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/XMLChar.java, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + * , + *      http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package jadx.core.xmlgen;, +, +import java.util.Arrays;, +, +/**, + * This class defines the basic XML character properties. The data, + * in this class can be used to verify that a character is a valid, + * XML character or if the character is a space, name start, or name, + * character., + * <p>, + * A series of convenience methods are supplied to ease the burden, + * of the developer. Because inlining the checks can improve per, + * character performance, the tables of character properties are, + * public. Using the character as an index into the <code>CHARS</code>, + * array and applying the appropriate mask flag (e.g., + * <code>MASK_VALID</code>), yields the same results as calling the, + * convenience methods. There is one exception: check the comments, + * for the <code>isValid</code> method for details.]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +		if(c >= 0 && c <= 0x1F) {, +			return "\\" + (int) c;, +		}, +			case '\\':, +				return "\\\\";]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, +			passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, +			passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			addArg(code, insn.getArg(i), false);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, +			passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			addArg(code, insn.getArg(i), false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +package jadx.core.dex.visitors;, +, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.utils.InstructionRemover;, +import jadx.core.utils.exceptions.JadxException;, +, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +public class ReSugarCode extends AbstractVisitor {, +	private static final Logger LOG = LoggerFactory.getLogger(ReSugarCode.class);, +, +	@Override, +	public void visit(MethodNode mth) throws JadxException {, +		if (mth.isNoCode()) {, +			return;, +		}, +		InstructionRemover remover = new InstructionRemover(mth);, +		for (BlockNode block : mth.getBasicBlocks()) {, +			remover.setBlock(block);, +			List<InsnNode> instructions = block.getInstructions();, +			int size = instructions.size();, +			for (int i = 0; i < size; i++) {, +				InsnNode replacedInsn = process(mth, instructions, i, remover);, +				if (replacedInsn != null) {, +					instructions.set(i, replacedInsn);, +				}, +			}, +			remover.perform();, +		}, +	}, +, +	private static InsnNode process(MethodNode mth, List<InsnNode> instructions, int i, InstructionRemover remover) {, +		InsnNode insn = instructions.get(i);, +		switch (insn.getType()) {, +			case NEW_ARRAY:, +				return processNewArray(mth, instructions, i, remover);, +, +			default:, +				return null;, +		}, +	}, +, +	/**, +	 * Replace new array and sequence of array-put to new filled-array instruction., +	 */, +	private static InsnNode processNewArray(MethodNode mth, List<InsnNode> instructions, int i, InstructionRemover remover) {, +		InsnNode insn = instructions.get(i);, +		InsnArg arg = insn.getArg(0);, +		if (!arg.isLiteral()) {, +			return null;, +		}, +		int len = (int) ((LiteralArg) arg).getLiteral();, +		int size = instructions.size();, +		if (len <= 0 || i + len >= size || instructions.get(i + len).getType() != InsnType.APUT) {, +			return null;, +		}, +		InsnNode filledArr = new InsnNode(InsnType.FILLED_NEW_ARRAY, len);, +		filledArr.setResult(insn.getResult());, +		for (int j = 0; j < len; j++) {, +			InsnNode put = instructions.get(i + 1 + j);, +			if (put.getType() != InsnType.APUT) {, +				LOG.debug("Not a APUT in expected new filled array: {}, method: {}", put, mth);, +				return null;, +			}, +			filledArr.addArg(put.getArg(2));, +			remover.add(put);, +		}, +		return filledArr;, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, +			passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			addArg(code, insn.getArg(i), false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +package jadx.core.dex.visitors;, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +				if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +				if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +		private final Map<String, JavaClassObject> clsMap = new HashMap<>();, +		private final Map<String, Class<?>> clsCache = new HashMap<>();]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +/*, +*/]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +			if (threadsCount <= 0) {, +			}, +					if (file.exists()) {, +					} else {, +			}, +			if (input.size() > 1) {, +			}, +			if (outDirName != null) {, +			}, +			if (len > maxNamesLen) {, +		}, +		for (int i = 0; i < count; i++) {, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +			if (threadsCount <= 0) {, +			}, +					if (file.exists()) {, +					} else {, +			}, +			if (input.size() > 1) {, +			}, +			if (outDirName != null) {, +			}, +			if (len > maxNamesLen) {, +		}, +		for (int i = 0; i < count; i++) {, +	}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		loadFiles(Collections.singletonList(file));, +		final List<IDexTreeVisitor> passList = new ArrayList<IDexTreeVisitor>(passes);, +		for (final ClassNode cls : root.getClasses(false)) {, +				Runnable job = new Runnable() {, +					@Override, +					public void run() {, +						ProcessClass.process(cls, passList);, +					}, +				};, +		ProcessClass.process(cls, passes);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +			if (threadsCount <= 0) {, +			}, +					if (file.exists()) {, +					} else {, +			}, +			if (input.size() > 1) {, +			}, +			if (outDirName != null) {, +			}, +			if (len > maxNamesLen) {, +		}, +		for (int i = 0; i < count; i++) {, +	}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		loadFiles(Collections.singletonList(file));, +		final List<IDexTreeVisitor> passList = new ArrayList<IDexTreeVisitor>(passes);, +		for (final ClassNode cls : root.getClasses(false)) {, +				Runnable job = new Runnable() {, +					@Override, +					public void run() {, +						ProcessClass.process(cls, passList);, +					}, +				};, +		ProcessClass.process(cls, passes);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.MethodInlineVisitor;, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +			if (threadsCount <= 0) {, +			}, +					if (file.exists()) {, +					} else {, +			}, +			if (input.size() > 1) {, +			}, +			if (outDirName != null) {, +			}, +			if (len > maxNamesLen) {, +		}, +		for (int i = 0; i < count; i++) {, +	}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		loadFiles(Collections.singletonList(file));, +		final List<IDexTreeVisitor> passList = new ArrayList<IDexTreeVisitor>(passes);, +		for (final ClassNode cls : root.getClasses(false)) {, +				Runnable job = new Runnable() {, +					@Override, +					public void run() {, +						ProcessClass.process(cls, passList);, +					}, +				};, +		ProcessClass.process(cls, passes);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.MethodInlineVisitor;, +			passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +public final class ProcessClass {, +	private ProcessClass() {, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes) {, +		} catch (Exception e) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		boolean wrap = state.contains(Flags.BODY_ONLY), +				&& !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, +		if (wrap) {, +		}, +		code.add(insn.getOp().getSymbol());, +		if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		boolean wrap = state.contains(Flags.BODY_ONLY), +				&& !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, +		if (wrap) {, +		}, +		code.add(insn.getOp().getSymbol());, +		if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +	DONT_WRAP,, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		boolean wrap = state.contains(Flags.BODY_ONLY), +				&& !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, +		if (wrap) {, +		}, +		code.add(insn.getOp().getSymbol());, +		if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +	DONT_WRAP,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +			removeBrackets(block);, +	private static void removeBrackets(BlockNode block) {, +		for (InsnNode insn : block.getInstructions()) {, +			checkInsn(insn);, +		}, +	}, +, +	private static void checkInsn(InsnNode insn) {, +		if (insn.getType() == InsnType.ARITH) {, +			ArithNode arith = (ArithNode) insn;, +			ArithOp op = arith.getOp();, +			if (op == ArithOp.ADD || op == ArithOp.SUB) {, +				for (int i = 0; i < 2; i++) {, +					InsnArg arg = arith.getArg(i);, +					if (arg.isInsnWrap()) {, +						InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +						wrapInsn.getAttributes().add(AttributeFlag.DONT_WRAP);, +						checkInsn(wrapInsn);, +					}, +				}, +			}, +		} else {, +			for (InsnArg arg : insn.getArguments()) {, +				if (arg.isInsnWrap()) {, +					InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +					checkInsn(wrapInsn);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		boolean wrap = state.contains(Flags.BODY_ONLY), +				&& !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, +		if (wrap) {, +		}, +		code.add(insn.getOp().getSymbol());, +		if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +	DONT_WRAP,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +			removeBrackets(block);, +	private static void removeBrackets(BlockNode block) {, +		for (InsnNode insn : block.getInstructions()) {, +			checkInsn(insn);, +		}, +	}, +, +	private static void checkInsn(InsnNode insn) {, +		if (insn.getType() == InsnType.ARITH) {, +			ArithNode arith = (ArithNode) insn;, +			ArithOp op = arith.getOp();, +			if (op == ArithOp.ADD || op == ArithOp.SUB) {, +				for (int i = 0; i < 2; i++) {, +					InsnArg arg = arith.getArg(i);, +					if (arg.isInsnWrap()) {, +						InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +						wrapInsn.getAttributes().add(AttributeFlag.DONT_WRAP);, +						checkInsn(wrapInsn);, +					}, +				}, +			}, +		} else {, +			for (InsnArg arg : insn.getArguments()) {, +				if (arg.isInsnWrap()) {, +					InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +					checkInsn(wrapInsn);, +				}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +			default:, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +			default:, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +/**, + * Prepare instructions for code generation pass,, + * most of this modification breaks register dependencies,, + * so this pass must be just before CodeGen., + */, +			checkInline(block);, +			removeParenthesis(block);, +	private static void checkInline(BlockNode block) {, +		List<InsnNode> list = block.getInstructions();, +		for (int i = 0; i < list.size(); i++) {, +			InsnNode insn = list.get(i);, +			// replace 'move' with inner wrapped instruction, +			if (insn.getType() == InsnType.MOVE, +					&& insn.getArg(0).isInsnWrap(), +					&& !insn.getAttributes().contains(AttributeFlag.DECLARE_VAR)) {, +				InsnNode wrapInsn = ((InsnWrapArg)insn.getArg(0)).getWrapInsn();, +				wrapInsn.setResult(insn.getResult());, +				list.set(i, wrapInsn);, +			}, +		}, +	}, +, +	private static void removeParenthesis(BlockNode block) {, +	/**, +	 * Remove parenthesis for wrapped insn  in arith '+' or '-', +	 * ('(a + b) +c' => 'a + b + c'), +	 */, +	/**, +	 * Replace arithmetic operation with short form, +	 * ('a = a + 2' => 'a += 2'), +	 */, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +			default:, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +/**, + * Prepare instructions for code generation pass,, + * most of this modification breaks register dependencies,, + * so this pass must be just before CodeGen., + */, +			checkInline(block);, +			removeParenthesis(block);, +	private static void checkInline(BlockNode block) {, +		List<InsnNode> list = block.getInstructions();, +		for (int i = 0; i < list.size(); i++) {, +			InsnNode insn = list.get(i);, +			// replace 'move' with inner wrapped instruction, +			if (insn.getType() == InsnType.MOVE, +					&& insn.getArg(0).isInsnWrap(), +					&& !insn.getAttributes().contains(AttributeFlag.DECLARE_VAR)) {, +				InsnNode wrapInsn = ((InsnWrapArg)insn.getArg(0)).getWrapInsn();, +				wrapInsn.setResult(insn.getResult());, +				list.set(i, wrapInsn);, +			}, +		}, +	}, +, +	private static void removeParenthesis(BlockNode block) {, +	/**, +	 * Remove parenthesis for wrapped insn  in arith '+' or '-', +	 * ('(a + b) +c' => 'a + b + c'), +	 */, +	/**, +	 * Replace arithmetic operation with short form, +	 * ('a = a + 2' => 'a += 2'), +	 */, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestArgInline.java, +import org.junit.Test;, +, +	@Test, +, +		assertThat(code, not(containsString("a = a + 1;")));]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, +		ArithNode other = (ArithNode) obj;, +		return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, +		ArithNode other = (ArithNode) obj;, +		return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstClassNode) || !super.isSame(obj)) {, +		ConstClassNode other = (ConstClassNode) obj;, +		return clsType.equals(other.clsType);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, +		ArithNode other = (ArithNode) obj;, +		return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstClassNode) || !super.isSame(obj)) {, +		ConstClassNode other = (ConstClassNode) obj;, +		return clsType.equals(other.clsType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstStringNode) || !super.isSame(obj)) {, +		ConstStringNode other = (ConstStringNode) obj;, +		return str.equals(other.str);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, +		ArithNode other = (ArithNode) obj;, +		return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstClassNode) || !super.isSame(obj)) {, +		ConstClassNode other = (ConstClassNode) obj;, +		return clsType.equals(other.clsType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstStringNode) || !super.isSame(obj)) {, +		ConstStringNode other = (ConstStringNode) obj;, +		return str.equals(other.str);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof FillArrayNode) || !super.isSame(obj)) {, +		FillArrayNode other = (FillArrayNode) obj;, +		return elemType.equals(other.elemType) && data == other.data;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, +		ArithNode other = (ArithNode) obj;, +		return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstClassNode) || !super.isSame(obj)) {, +		ConstClassNode other = (ConstClassNode) obj;, +		return clsType.equals(other.clsType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstStringNode) || !super.isSame(obj)) {, +		ConstStringNode other = (ConstStringNode) obj;, +		return str.equals(other.str);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof FillArrayNode) || !super.isSame(obj)) {, +		FillArrayNode other = (FillArrayNode) obj;, +		return elemType.equals(other.elemType) && data == other.data;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +	private static void addFilesFromDirectory(File dir,, +			List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, +		ArithNode other = (ArithNode) obj;, +		return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public boolean isSame(InsnNode obj) {, +		if (!(obj instanceof ConstClassNode) || !super.isSame(obj)) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, +	/**, +	 * RegisterArg attribute for method arguments, +	 */, +	METHOD_ARGUMENT,, +, +	/**, +	 * Type of RegisterArg or SSAVar can't be changed, +	 */, +	IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, +	/**, +	 * RegisterArg attribute for method arguments, +	 */, +	METHOD_ARGUMENT,, +, +	/**, +	 * Type of RegisterArg or SSAVar can't be changed, +	 */, +	IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getInitType());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, +	/**, +	 * RegisterArg attribute for method arguments, +	 */, +	METHOD_ARGUMENT,, +, +	/**, +	 * Type of RegisterArg or SSAVar can't be changed, +	 */, +	IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getInitType());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, +	private ArgType type; // before type inference can be null and set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, +	/**, +	 * RegisterArg attribute for method arguments, +	 */, +	METHOD_ARGUMENT,, +, +	/**, +	 * Type of RegisterArg or SSAVar can't be changed, +	 */, +	IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getInitType());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, +	private ArgType type; // before type inference can be null and set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		super(-1, field.getType());, +	public ArgType getType() {, +		return this.field.getType();, +	}, +, +	@Override, +	public ArgType getInitType() {, +		return this.field.getType();, +	}, +, +	@Override, +	public void setType(ArgType newType) {, +		throw new JadxRuntimeException("Can't set type for FieldArg");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, +	/**, +	 * RegisterArg attribute for method arguments, +	 */, +	METHOD_ARGUMENT,, +, +	/**, +	 * Type of RegisterArg or SSAVar can't be changed, +	 */, +	IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getInitType());]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.TernaryVisitor;, +			passes.add(new RegionMakerVisitor());, +			passes.add(new TernaryVisitor());, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.TernaryVisitor;, +			passes.add(new RegionMakerVisitor());, +			passes.add(new TernaryVisitor());, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +package jadx.core.codegen;, +, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.IfOp;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.regions.Compare;, +import jadx.core.dex.regions.IfCondition;, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.exceptions.CodegenException;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +public class ConditionGen {, +	private static final Logger LOG = LoggerFactory.getLogger(ConditionGen.class);, +, +	static String make(InsnGen insnGen, IfCondition condition) throws CodegenException {, +		switch (condition.getMode()) {, +			case COMPARE:, +				return makeCompare(insnGen, condition.getCompare());, +			case NOT:, +				return "!(" + make(insnGen, condition.getArgs().get(0)) + ")";, +			case AND:, +			case OR:, +				String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +				StringBuilder sb = new StringBuilder();, +				for (IfCondition arg : condition.getArgs()) {, +					if (sb.length() != 0) {, +						sb.append(mode);, +					}, +					String s = make(insnGen, arg);, +					if (arg.isCompare()) {, +						sb.append(s);, +					} else {, +						sb.append('(').append(s).append(')');, +					}, +				}, +				return sb.toString();, +			default:, +				return "??" + condition.toString();, +		}, +	}, +, +	private static String makeCompare(InsnGen insnGen, Compare compare) throws CodegenException {, +		IfOp op = compare.getOp();, +		InsnArg firstArg = compare.getA();, +		InsnArg secondArg = compare.getB();, +		if (firstArg.getType().equals(ArgType.BOOLEAN), +				&& secondArg.isLiteral(), +				&& secondArg.getType().equals(ArgType.BOOLEAN)) {, +			LiteralArg lit = (LiteralArg) secondArg;, +			if (lit.getLiteral() == 0) {, +				op = op.invert();, +			}, +			if (op == IfOp.EQ) {, +				// == true, +				return insnGen.arg(firstArg, false).toString();, +			} else if (op == IfOp.NE) {, +				// != true, +				if (isWrapNeeded(firstArg)) {, +					return "!(" + insnGen.arg(firstArg) + ")";, +				} else {, +					return "!" + insnGen.arg(firstArg);, +				}, +			}, +			LOG.warn(ErrorsCounter.formatErrorMsg(insnGen.mth, "Unsupported boolean condition " + op.getSymbol()));, +		}, +		return insnGen.arg(firstArg, isWrapNeeded(firstArg)), +				+ " " + op.getSymbol() + " ", +				+ insnGen.arg(secondArg, isWrapNeeded(secondArg));, +	}, +, +	private static boolean isWrapNeeded(InsnArg arg) {, +		if (!arg.isInsnWrap()) {, +			return false;, +		}, +		InsnNode insn = ((InsnWrapArg) arg).getWrapInsn();, +		if (insn.getType() == InsnType.ARITH) {, +			ArithNode arith = ((ArithNode) insn);, +			switch (arith.getOp()) {, +				case ADD:, +				case SUB:, +				case MUL:, +				case DIV:]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				if (arg.contains(AFlag.SKIP_ARG)) {, +				if (i != k) {, +					code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				if (arg.contains(AFlag.SKIP_ARG)) {, +				if (i != k) {, +					code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		AttributeStorage copyFrom = attrNode.storage;, +		if (!copyFrom.isEmpty()) {, +			initStorage().addAll(copyFrom);, +		}, +	private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				if (arg.contains(AFlag.SKIP_ARG)) {, +				if (i != k) {, +					code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		AttributeStorage copyFrom = attrNode.storage;, +		if (!copyFrom.isEmpty()) {, +			initStorage().addAll(copyFrom);, +		}, +	private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +	public boolean isEmpty() {, +		return flags.isEmpty() && attributes.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				if (arg.contains(AFlag.SKIP_ARG)) {, +				if (i != k) {, +					code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		AttributeStorage copyFrom = attrNode.storage;, +		if (!copyFrom.isEmpty()) {, +			initStorage().addAll(copyFrom);, +		}, +	private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +	public boolean isEmpty() {, +		return flags.isEmpty() && attributes.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +	public boolean isEmpty() {, +		return true;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				if (arg.contains(AFlag.SKIP_ARG)) {, +				if (i != k) {, +					code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		AttributeStorage copyFrom = attrNode.storage;, +		if (!copyFrom.isEmpty()) {, +			initStorage().addAll(copyFrom);, +		}, +	private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +	public boolean isEmpty() {, +		return flags.isEmpty() && attributes.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +	public boolean isEmpty() {, +		return true;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +		dup.copyAttributesFrom(this);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				if (arg.contains(AFlag.SKIP_ARG)) {, +				if (i != k) {, +					code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		AttributeStorage copyFrom = attrNode.storage;, +		if (!copyFrom.isEmpty()) {, +			initStorage().addAll(copyFrom);, +		}, +	private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +	public boolean isEmpty() {, +		return flags.isEmpty() && attributes.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +	public boolean isEmpty() {, +		return true;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +		dup.copyAttributesFrom(this);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/Typed.java, +import jadx.core.dex.attributes.AttrNode;, +public abstract class Typed extends AttrNode {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +				BlockNode handlerBlock = excHandler.getHandlerBlock();, +				if (handlerBlock != null) {, +					SplitterBlockAttr splitter = handlerBlock.get(AType.SPLITTER_BLOCK);, +			}, +			BlockNode handlerBlock = h.getHandlerBlock();, +			if (handlerBlock != null, +					&& RegionUtils.hasPathThroughBlock(handlerBlock, cont)) {]
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +				, +				if(!ZipSecurity.isValidZipEntry(entry)) {, +					return null;, +				}, +				, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +				, +				if(!ZipSecurity.isValidZipEntry(entry)) {, +					return null;, +				}, +				, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +				, +				if(!ZipSecurity.isValidZipEntry(entry)) {, +					return null;, +				}, +				, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +				// security check, +				if(!ZipSecurity.isValidZipEntry(entry)) {, +					continue;, +				}, +, +			if (clsName == null || ZipSecurity.isValidZipEntryName(clsName)) {, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +				, +				if(!ZipSecurity.isValidZipEntry(entry)) {, +					return null;, +				}, +				, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +				// security check, +				if(!ZipSecurity.isValidZipEntry(entry)) {, +					continue;, +				}, +, +			if (clsName == null || ZipSecurity.isValidZipEntryName(clsName)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +package jadx.core.utils.files;, +, +import java.io.File;, +import java.util.zip.ZipEntry;, +, +public class ZipSecurity {, +	// size of uncompressed zip entry shouldn't be bigger of compressed in MAX_SIZE_DIFF times, +	private static final int MAX_SIZE_DIFF = 5;, +	, +	private static boolean isInSubDirectory(File base, File file) {, +	    if (file == null) {, +	        return false;, +	    }, +	    if (file.equals(base)) {, +	        return true;, +	    }, +, +	    return isInSubDirectory(base, file.getParentFile());, +	}, +	, +	// checks that entry name contains no any traversals, +	// and prevents cases like "../classes.dex", to limit output only to the specified directory, +	public static boolean isValidZipEntryName(String entryName) {, +		try {, +			File currentPath = new File(".").getCanonicalFile();, +			File canonical = new File(currentPath, entryName).getCanonicalFile();, +			return isInSubDirectory(currentPath, canonical);, +		}, +		catch(Exception e) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, +		makeInsn(insn, code, null);, +	protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, +		makeInsn(insn, code, null);, +	protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.nodes.JumpInfo;, +import jadx.core.dex.instructions.IfNode;, +			ArgType argType = var.getType();, +				mth.unload();, +		InsnNode prevInsn = null;, +			if (addLabels && needLabel(insn, prevInsn)) {, +				code.startLine();, +				RegisterArg resArg = insn.getResult();, +				if (resArg != null) {, +					ArgType varType = resArg.getInitType();, +					if (varType.isTypeKnown()) {, +						code.add(varType.toString()).add(' ');, +					}, +				}, +				insnGen.makeInsn(insn, code, InsnGen.Flags.INLINE);, +					code.add("     // " + catchAttr);, +			prevInsn = insn;, +	private static boolean needLabel(InsnNode insn, InsnNode prevInsn) {, +		if (insn.contains(AType.EXC_HANDLER)) {, +			return true;, +		}, +		if (insn.contains(AType.JUMP)) {, +			// don't add label for ifs else branch, +			if (prevInsn != null && prevInsn.getType() == InsnType.IF) {, +				List<JumpInfo> jumps = insn.getAll(AType.JUMP);, +				if (jumps.size() == 1) {, +					JumpInfo jump = jumps.get(0);, +					if (jump.getSrc() == prevInsn.getOffset() && jump.getDest() == insn.getOffset()) {, +						int target = ((IfNode) prevInsn).getTarget();, +						return insn.getOffset() == target;, +					}, +				}, +			}, +			return true;, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, +		makeInsn(insn, code, null);, +	protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.nodes.JumpInfo;, +import jadx.core.dex.instructions.IfNode;, +			ArgType argType = var.getType();, +				mth.unload();, +		InsnNode prevInsn = null;, +			if (addLabels && needLabel(insn, prevInsn)) {, +				code.startLine();, +				RegisterArg resArg = insn.getResult();, +				if (resArg != null) {, +					ArgType varType = resArg.getInitType();, +					if (varType.isTypeKnown()) {, +						code.add(varType.toString()).add(' ');, +					}, +				}, +				insnGen.makeInsn(insn, code, InsnGen.Flags.INLINE);, +					code.add("     // " + catchAttr);, +			prevInsn = insn;, +	private static boolean needLabel(InsnNode insn, InsnNode prevInsn) {, +		if (insn.contains(AType.EXC_HANDLER)) {, +			return true;, +		}, +		if (insn.contains(AType.JUMP)) {, +			// don't add label for ifs else branch, +			if (prevInsn != null && prevInsn.getType() == InsnType.IF) {, +				List<JumpInfo> jumps = insn.getAll(AType.JUMP);, +				if (jumps.size() == 1) {, +					JumpInfo jump = jumps.get(0);, +					if (jump.getSrc() == prevInsn.getOffset() && jump.getDest() == insn.getOffset()) {, +						int target = ((IfNode) prevInsn).getTarget();, +						return insn.getOffset() == target;, +					}, +				}, +			}, +			return true;, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/fallback/TestFallbackMode.java, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +		assertThat(code, containsOne("r1 = this;"));, +		assertThat(code, containsOne("L_0x0000:"));, +		assertThat(code, containsOne("L_0x0007:"));, +		assertThat(code, containsOne("int r2 = r2 + 1"));]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +				Region newRegion = wrapBlocks(region, dominator);, +				if (newRegion != null) {, +					// dominator may be moved into new region, +					leaveRegion(mth, newRegion);, +				}, +	private Region wrapBlocks(IRegion region, BlockNode dominator) {, +			return null;, +		, +		return newRegion;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +				Region newRegion = wrapBlocks(region, dominator);, +				if (newRegion != null) {, +					// dominator may be moved into new region, +					leaveRegion(mth, newRegion);, +				}, +	private Region wrapBlocks(IRegion region, BlockNode dominator) {, +			return null;, +		, +		return newRegion;, +++ b/jadx-core/src/test/java/jadx/tests/internal/trycatch/TestNestedTryCatch.java, +package jadx.tests.internal.trycatch;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestNestedTryCatch extends InternalJadxTest {, +, +	public static class TestCls {, +		private void f() {, +			try {, +				Thread.sleep(1);, +				try {, +					Thread.sleep(2);, +				} catch (InterruptedException e) {, +				}, +			} catch (Exception e) {, +			}, +			, +			return;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("try {"));, +		assertThat(code, containsString("Thread.sleep(1);"));, +		assertThat(code, containsString("Thread.sleep(2);"));, +		assertThat(code, containsString("} catch (InterruptedException e) {"));, +		assertThat(code, containsString("} catch (Exception e2) {"));, +		assertThat(code, not(containsString("return")));, +	}, +}]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, +import static jadx.core.xmlgen.ParserConstants.PLURALS_MAP;, +, +		switch (typeName) {, +			case "attr":, +				if (nameStr != null), +				break;, +			case "style":, +				if (nameStr != null), +				break;, +			case "plurals":, +				final String quantity = PLURALS_MAP.get(value.getNameRef());, +				addSimpleValue(cw, typeName, itemTag, "quantity", quantity, valueStr);, +				break;, +			default:, +				break;]
[+++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, +            if (!"$it".contains(':jadx-samples:')) {, +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, +            if (!"$it".contains(':jadx-samples:')) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			JadxCLIArgs jadxArgs = new JadxCLIArgs();, +			if (processArgs(jadxArgs, args)) {, +			}, +		} catch (JadxException e) {, +	static void processAndSave(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("jadx error: " + e.getMessage(), e);, +		if (ErrorsCounter.getErrorCount() != 0) {, +			throw new JadxException("finished with errors");, +		LOG.info("done");, +, +	static boolean processArgs(JadxCLIArgs jadxArgs, String[] args) throws JadxException {, +		if (!jadxArgs.processArgs(args)) {, +			return false;, +		}, +			return false;, +		return true;, +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, +            if (!"$it".contains(':jadx-samples:')) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			JadxCLIArgs jadxArgs = new JadxCLIArgs();, +			if (processArgs(jadxArgs, args)) {, +			}, +		} catch (JadxException e) {, +	static void processAndSave(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("jadx error: " + e.getMessage(), e);, +		if (ErrorsCounter.getErrorCount() != 0) {, +			throw new JadxException("finished with errors");, +		LOG.info("done");, +, +	static boolean processArgs(JadxCLIArgs jadxArgs, String[] args) throws JadxException {, +		if (!jadxArgs.processArgs(args)) {, +			return false;, +		}, +			return false;, +		return true;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	public boolean processArgs(String[] args) {, +		return parse(args) && process();, +	private boolean parse(String[] args) {, +			return true;, +			return false;, +	private boolean process() {, +			return false;, +			return false;, +		return true;, +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, +            if (!"$it".contains(':jadx-samples:')) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			JadxCLIArgs jadxArgs = new JadxCLIArgs();, +			if (processArgs(jadxArgs, args)) {, +			}, +		} catch (JadxException e) {, +	static void processAndSave(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("jadx error: " + e.getMessage(), e);, +		if (ErrorsCounter.getErrorCount() != 0) {, +			throw new JadxException("finished with errors");, +		LOG.info("done");, +, +	static boolean processArgs(JadxCLIArgs jadxArgs, String[] args) throws JadxException {, +		if (!jadxArgs.processArgs(args)) {, +			return false;, +		}, +			return false;, +		return true;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	public boolean processArgs(String[] args) {, +		return parse(args) && process();, +	private boolean parse(String[] args) {, +			return true;, +			return false;, +	private boolean process() {, +			return false;, +			return false;, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Utils.class.getClassLoader();, +			if (classLoader != null) {, +				Enumeration<URL> resources = classLoader.getResources("META-INF/MANIFEST.MF");, +			}, +		} catch (Exception e) {, +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, +            if (!"$it".contains(':jadx-samples:')) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, +            <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, +            <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.search.TextSearchIndex;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, +            <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.search.TextSearchIndex;, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +import jadx.gui.utils.JNodeCache;, +import jadx.gui.utils.search.StringRef;, +import jadx.gui.utils.search.TextSearchIndex;, +, +import java.util.List;, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount, boolean useFastSearch) {, +		super(wrapper, threadsCount);, +		this.useFastSearch = useFastSearch;, +		JNodeCache nodeCache = cache.getNodeCache();, +		final TextSearchIndex index = new TextSearchIndex(nodeCache, useFastSearch);, +		final CodeUsageInfo usageInfo = new CodeUsageInfo(nodeCache);, +						List<StringRef> lines = splitLines(cls);, +						if (Utils.isFreeMemoryAvailable()) {, +	protected List<StringRef> splitLines(JavaClass cls) {, +		List<StringRef> lines = StringRef.split(cls.getCode(), CodeWriter.NL);, +		int size = lines.size();, +		for (int i = 0; i < size; i++) {, +			lines.set(i, lines.get(i).trim());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, +            <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.search.TextSearchIndex;, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +import jadx.gui.utils.JNodeCache;, +import jadx.gui.utils.search.StringRef;, +import jadx.gui.utils.search.TextSearchIndex;, +, +import java.util.List;, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount, boolean useFastSearch) {, +		super(wrapper, threadsCount);, +		this.useFastSearch = useFastSearch;, +		JNodeCache nodeCache = cache.getNodeCache();, +		final TextSearchIndex index = new TextSearchIndex(nodeCache, useFastSearch);, +		final CodeUsageInfo usageInfo = new CodeUsageInfo(nodeCache);, +						List<StringRef> lines = splitLines(cls);, +						if (Utils.isFreeMemoryAvailable()) {, +	protected List<StringRef> splitLines(JavaClass cls) {, +		List<StringRef> lines = StringRef.split(cls.getCode(), CodeWriter.NL);, +		int size = lines.size();, +		for (int i = 0; i < size; i++) {, +			lines.set(i, lines.get(i).trim());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private boolean autoStartJobs = true;, +, +	public JadxSettings() {, +		setSkipResources(true);, +	}, +		return false;, +//		return useFastSearch;, +	public boolean isAutoStartJobs() {, +		return autoStartJobs;, +	}, +, +	public void setAutoStartJobs(boolean autoStartJobs) {, +		this.autoStartJobs = autoStartJobs;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, +            <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.search.TextSearchIndex;, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +import jadx.gui.utils.JNodeCache;, +import jadx.gui.utils.search.StringRef;, +import jadx.gui.utils.search.TextSearchIndex;, +, +import java.util.List;, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount, boolean useFastSearch) {, +		super(wrapper, threadsCount);, +		this.useFastSearch = useFastSearch;, +		JNodeCache nodeCache = cache.getNodeCache();, +		final TextSearchIndex index = new TextSearchIndex(nodeCache, useFastSearch);, +		final CodeUsageInfo usageInfo = new CodeUsageInfo(nodeCache);, +						List<StringRef> lines = splitLines(cls);, +						if (Utils.isFreeMemoryAvailable()) {, +	protected List<StringRef> splitLines(JavaClass cls) {, +		List<StringRef> lines = StringRef.split(cls.getCode(), CodeWriter.NL);]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		return name.equals(((JPackage) o).name);, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		return name.equals(((JPackage) o).name);, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.IdentityHashMap;, +	/**, +	 * Convert packages list to hierarchical packages representation, +	 *, +	 * @param packages input packages list, +	 * @return root packages, +	 */, +, +, +		// use identity set for collect inner packages, +		Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<JPackage,Boolean>());, +			innerPackages.addAll(pkg.getInnerPackages());, +		// find root packages, +			if (!innerPackages.contains(pkg)) {, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		return name.equals(((JPackage) o).name);, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.IdentityHashMap;, +	/**, +	 * Convert packages list to hierarchical packages representation, +	 *, +	 * @param packages input packages list, +	 * @return root packages, +	 */, +, +, +		// use identity set for collect inner packages, +		Set<JPackage> innerPackages = Collections.newSetFromMap(new IdentityHashMap<JPackage,Boolean>());, +			innerPackages.addAll(pkg.getInnerPackages());, +		// find root packages, +			if (!innerPackages.contains(pkg)) {, +++ b/jadx-gui/src/test/java/jadx/gui/treemodel/JRootTest.java, +import org.junit.Before;, +	private JRoot root;, +	private Decompiler decompiler;, +, +	@Before, +	public void init() {, +		root = new JRoot(mock(JadxWrapper.class));, +		decompiler = new Decompiler(mock(IJadxArgs.class));, +	}, +, +		List<JavaPackage> packages = Arrays.asList(newPkg(pkgName));, +	@Test, +	public void testHierarchyPackages2() {, +		List<JavaPackage> packages = Arrays.asList(, +				newPkg("a.b"),, +				newPkg("a.c"),, +				newPkg("a.d"), +		);, +		List<JPackage> out = root.getHierarchyPackages(packages);, +, +		assertEquals(out.size(), 1);, +		JPackage jpkg = out.get(0);, +		assertEquals(jpkg.getName(), "a");, +		assertEquals(jpkg.getClasses().size(), 0);, +		assertEquals(jpkg.getInnerPackages().size(), 3);, +	}, +, +	@Test, +	public void testHierarchyPackages3() {, +		List<JavaPackage> packages = Arrays.asList(, +				newPkg("a.b.p1"),, +				newPkg("a.b.p2"),, +				newPkg("a.b.p3"), +		);, +		List<JPackage> out = root.getHierarchyPackages(packages);, +, +		assertEquals(out.size(), 1);, +		JPackage jpkg = out.get(0);, +		assertEquals(jpkg.getName(), "a.b");, +		assertEquals(jpkg.getClasses().size(), 0);, +		assertEquals(jpkg.getInnerPackages().size(), 3);, +	}, +, +	@Test, +	public void testHierarchyPackages4() {, +		List<JavaPackage> packages = Arrays.asList(, +				newPkg("a.p1"),, +				newPkg("a.b.c.p2"),]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertSourceFileInfo(clsCode, cls);, +					if (mthGen.addDefinition(code)) {, +						code.add(' ');, +					}, +			code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertSourceFileInfo(clsCode, cls);, +					if (mthGen.addDefinition(code)) {, +						code.add(' ');, +					}, +			code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	public boolean addDefinition(CodeWriter code) {, +			return true;, +			return false;, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertSourceFileInfo(clsCode, cls);, +					if (mthGen.addDefinition(code)) {, +						code.add(' ');, +					}, +			code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	public boolean addDefinition(CodeWriter code) {, +			return true;, +			return false;, +		return true;, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestAnnotations.java, +, +		assertThat(code, containsString("int a();"));, +		assertThat(code, containsString("float value() default 1.1f;"));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertSourceFileInfo(clsCode, cls);, +					if (mthGen.addDefinition(code)) {, +						code.add(' ');, +					}, +			code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	public boolean addDefinition(CodeWriter code) {, +			return true;, +			return false;, +		return true;, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestAnnotations.java, +, +		assertThat(code, containsString("int a();"));, +		assertThat(code, containsString("float value() default 1.1f;"));, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestStaticMethod.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestStaticMethod extends InternalJadxTest {, +, +	public static class TestCls {, +		static {, +			f();, +		}, +, +		private static void f() {, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("static {"));, +		assertThat(code, containsString("private static void f() {"));, +	}, +}]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;]
[+++ b/build.gradle, +        testCompile "org.mockito:mockito-core:1.9.5", +++ b/build.gradle, +        testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public int getErrorsCount() {, +		return errorsCount;, +	}, +, +++ b/build.gradle, +        testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public int getErrorsCount() {, +		return errorsCount;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +public final class JavaField {, +++ b/build.gradle, +        testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public int getErrorsCount() {, +		return errorsCount;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +public final class JavaField {, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +public final class JavaMethod {, +++ b/build.gradle, +        testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public int getErrorsCount() {, +		return errorsCount;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +public final class JavaField {, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +public final class JavaMethod {, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +			List<JPackage> rootPkgs = getHierarchyPackages(wrapper.getPackages());, +			for (JPackage jPackage : rootPkgs) {, +				jPackage.updateChilds();, +				add(jPackage);, +			}, +		}, +	}, +, +	List<JPackage> getHierarchyPackages(List<JavaPackage> packages) {, +		for (JavaPackage pkg : packages) {, +		boolean repeat;, +		do {, +			repeat = false;, +, +					repeat = true;, +					pkgMap.remove(innerPkg.getName());, +					break;, +		} while (repeat);, +, +		return rootPkgs;, +++ b/build.gradle, +        testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public int getErrorsCount() {, +		return errorsCount;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +public final class JavaField {, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +public final class JavaMethod {, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +			List<JPackage> rootPkgs = getHierarchyPackages(wrapper.getPackages());, +			for (JPackage jPackage : rootPkgs) {, +				jPackage.updateChilds();, +				add(jPackage);, +			}, +		}, +	}, +, +	List<JPackage> getHierarchyPackages(List<JavaPackage> packages) {, +		for (JavaPackage pkg : packages) {, +		boolean repeat;, +		do {, +			repeat = false;, +, +					repeat = true;, +					pkgMap.remove(innerPkg.getName());, +					break;, +		} while (repeat);, +, +		return rootPkgs;, +++ b/jadx-gui/src/test/java/jadx/api/Factory.java, +package jadx.api;, +, +import jadx.core.dex.nodes.ClassNode;, +, +import java.util.List;, +]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private boolean autoStartJobs = false;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java, +import jadx.core.dex.nodes.DexNode;, +	private int generateMethodLookupId(DexNode dex, int mthId) {, +		return (dex.getDexId()<<16)|mthId;, +	public MethodInfo getMethod(DexNode dex, int mtdId) {, +		return methods.get(generateMethodLookupId(dex,mtdId));, +	}, +, +	public MethodInfo putMethod(DexNode dex, int mthId, MethodInfo mth) {, +			MethodInfo prev = methods.put(generateMethodLookupId(dex,mthId), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java, +import jadx.core.dex.nodes.DexNode;, +	private int generateMethodLookupId(DexNode dex, int mthId) {, +		return (dex.getDexId()<<16)|mthId;, +	public MethodInfo getMethod(DexNode dex, int mtdId) {, +		return methods.get(generateMethodLookupId(dex,mtdId));, +	}, +, +	public MethodInfo putMethod(DexNode dex, int mthId, MethodInfo mth) {, +			MethodInfo prev = methods.put(generateMethodLookupId(dex,mthId), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		MethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);, +		return dex.root().getInfoStorage().putMethod(dex, mthIndex, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java, +import jadx.core.dex.nodes.DexNode;, +	private int generateMethodLookupId(DexNode dex, int mthId) {, +		return (dex.getDexId()<<16)|mthId;, +	public MethodInfo getMethod(DexNode dex, int mtdId) {, +		return methods.get(generateMethodLookupId(dex,mtdId));, +	}, +, +	public MethodInfo putMethod(DexNode dex, int mthId, MethodInfo mth) {, +			MethodInfo prev = methods.put(generateMethodLookupId(dex,mthId), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		MethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);, +		return dex.root().getInfoStorage().putMethod(dex, mthIndex, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +	private final int dexId;, +	public DexNode(RootNode root, DexFile input, int dexId) {, +		this.dexId = dexId;, +	public int getDexId() {, +		return dexId;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +		return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java, +import jadx.core.dex.nodes.DexNode;, +	private int generateMethodLookupId(DexNode dex, int mthId) {, +		return (dex.getDexId()<<16)|mthId;, +	public MethodInfo getMethod(DexNode dex, int mtdId) {, +		return methods.get(generateMethodLookupId(dex,mtdId));, +	}, +, +	public MethodInfo putMethod(DexNode dex, int mthId, MethodInfo mth) {, +			MethodInfo prev = methods.put(generateMethodLookupId(dex,mthId), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		MethodInfo mth = dex.root().getInfoStorage().getMethod(dex, mthIndex);, +		return dex.root().getInfoStorage().putMethod(dex, mthIndex, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +	private final int dexId;, +	public DexNode(RootNode root, DexFile input, int dexId) {, +		this.dexId = dexId;, +	public int getDexId() {, +		return dexId;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +import jadx.core.dex.info.InfoStorage;, +	private final InfoStorage infoStorage = new InfoStorage();, +					DexNode dexNode = new DexNode(this, dexFile, dexNodes.size());, +, +	public InfoStorage getInfoStorage() {, +		return infoStorage;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		ClassInfo alias = classInfo.getAlias();, +		String clsName = alias.getShortName();, +			classInfo.rename(cls.root(), alias.makeFullClsName(newShortName, true));, +		if (alias.getPackage().isEmpty()) {, +			String fullName = alias.makeFullClsName(alias.getShortName(), true);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			regionsCount++;, +			if (regionsCount > REGIONS_LIMIT) {, +				throw new JadxRuntimeException("Regions count limit reached");, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			regionsCount++;, +			if (regionsCount > REGIONS_LIMIT) {, +				throw new JadxRuntimeException("Regions count limit reached");, +			}, +++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java, +		File out = new File("test-graph-" + desc + "-tmp");]
[+++ b/README.md, +### add by qi, +add: check file's type by file header, +, +++ b/README.md, +### add by qi, +add: check file's type by file header, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, +	//add by qi, +	public static String bytesToHex(byte[] bytes) {, +		char[] hexArray = "0123456789abcdef".toCharArray();, +		if (bytes == null || bytes.length <= 0) {, +			return null;, +		}, +		char[] hexChars = new char[bytes.length * 2];, +		for ( int j = 0; j < bytes.length; j++ ) {, +			int v = bytes[j] & 0xFF;, +			hexChars[j * 2] = hexArray[v >>> 4];, +			hexChars[j * 2 + 1] = hexArray[v & 0x0F];, +		}, +		return new String(hexChars);, +	}, +, +	//add by qi, +	public static boolean isZipfile(File file) {, +		boolean isZipfile = false;, +		InputStream is = null;, +		try {, +			byte[] headers = new byte[4];, +			is = new FileInputStream(file);, +			is.read(headers, 0, 4);, +			System.out.println(bytesToHex(headers));, +			String headerString = bytesToHex(headers);, +			if (headerString.equals("504b0304")) {, +				isZipfile = true;, +			}, +		} catch (Exception e) {, +			e.printStackTrace();, +		} finally {, +			if (is != null) {, +				try {, +					is.close();, +				} catch (IOException e) {, +					e.printStackTrace();, +				}, +			}, +		}, +, +		return isZipfile;, +	}, +, +	//add by qi, +	public static List<String> getZipfileList(File file) {, +		List<String> filelist = new ArrayList<String>();, +		ZipFile zipFile = null;, +		try {, +			zipFile = new ZipFile(file);, +			Enumeration<? extends ZipEntry> entries = zipFile.entries();, +, +			while(entries.hasMoreElements()){, +				ZipEntry entry = entries.nextElement();, +				filelist.add(entry.getName());, +				System.out.println(entry.getName());, +			}, +		} catch (IOException e) {, +			e.printStackTrace();, +			System.out.println(e.getMessage());, +		}, +, +		return filelist;, +	}, +, +	//add by qi, +	public static boolean isApkfile(File file) {, +		boolean isApkfile = false;, +		if (isZipfile(file)) {, +			List<String> filelist = getZipfileList(file);, +			if (filelist.contains("AndroidManifest.xml") && filelist.contains("classes.dex")) {, +				isApkfile = true;, +			}, +		}, +		return isApkfile;, +	}, +, +	//add by qi, +	public static boolean isZipDexfile(File file) {, +		boolean isZipDexFile = false;, +		if (isZipfile(file)) {, +			List<String> filelist = getZipfileList(file);, +			if (filelist.contains("classes.dex")) {, +				isZipDexFile = true;, +			}, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, +				if (k instanceof FieldNode) {, +					FieldNode fn = (FieldNode) k;, +					if (fn.getParentClass().isEnum()) {, +						code.add(fn.getName());, +					} else {, +						staticField(code, fn.getFieldInfo());, +					}, +				} else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, +				if (k instanceof FieldNode) {, +					FieldNode fn = (FieldNode) k;, +					if (fn.getParentClass().isEnum()) {, +						code.add(fn.getName());, +					} else {, +						staticField(code, fn.getFieldInfo());, +					}, +				} else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EnumMapAttr;, +	public static final AType<EnumMapAttr> ENUM_MAP = new AType<EnumMapAttr>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, +				if (k instanceof FieldNode) {, +					FieldNode fn = (FieldNode) k;, +					if (fn.getParentClass().isEnum()) {, +						code.add(fn.getName());, +					} else {, +						staticField(code, fn.getFieldInfo());, +					}, +				} else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EnumMapAttr;, +	public static final AType<EnumMapAttr> ENUM_MAP = new AType<EnumMapAttr>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		initStorage().add(flag);, +		initStorage().add(attr);, +		initStorage().add(type, obj);, +		initStorage().addAll(attrNode.storage);, +	AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, +				if (k instanceof FieldNode) {, +					FieldNode fn = (FieldNode) k;, +					if (fn.getParentClass().isEnum()) {, +						code.add(fn.getName());, +					} else {, +						staticField(code, fn.getFieldInfo());, +					}, +				} else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EnumMapAttr;, +	public static final AType<EnumMapAttr> ENUM_MAP = new AType<EnumMapAttr>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		initStorage().add(flag);, +		initStorage().add(attr);, +		initStorage().add(type, obj);, +		initStorage().addAll(attrNode.storage);, +	AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +public final class EmptyAttrStorage extends AttributeStorage {, +, +	@Override, +	public String toString() {, +		return "";, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, +				if (k instanceof FieldNode) {, +					FieldNode fn = (FieldNode) k;, +					if (fn.getParentClass().isEnum()) {, +						code.add(fn.getName());, +					} else {, +						staticField(code, fn.getFieldInfo());, +					}, +				} else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EnumMapAttr;, +	public static final AType<EnumMapAttr> ENUM_MAP = new AType<EnumMapAttr>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +		initStorage().add(flag);, +		initStorage().add(attr);, +		initStorage().add(type, obj);, +		initStorage().addAll(attrNode.storage);, +	AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +public final class EmptyAttrStorage extends AttributeStorage {, +, +	@Override, +	public String toString() {, +		return "";, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +package jadx.core.dex.attributes.nodes;, +, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.IAttribute;, +]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, +			passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, +			passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, +			passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.utils.InstructionRemover;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import java.util.IdentityHashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.NotNull;, +, +public final class PhiInsn extends InsnNode {, +, +	private final Map<RegisterArg, BlockNode> blockBinds;, +		this.blockBinds = new IdentityHashMap<RegisterArg, BlockNode>(predecessors);, +	public RegisterArg bindArg(BlockNode pred) {, +		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getType());, +		bindArg(arg, pred);, +		return arg;, +	}, +, +	public void bindArg(RegisterArg arg, BlockNode pred) {, +		if (blockBinds.containsValue(pred)) {, +			throw new JadxRuntimeException("Duplicate predecessors in PHI insn: " + pred + ", " + this);, +		}, +		addArg(arg);, +		blockBinds.put(arg, pred);, +	}, +, +	public BlockNode getBlockByArg(RegisterArg arg) {, +		return blockBinds.get(arg);, +	}, +, +	public Map<RegisterArg, BlockNode> getBlockBinds() {, +		return blockBinds;, +	}, +, +	@NotNull, +	@Override, +	public boolean removeArg(InsnArg arg) {, +		if (!(arg instanceof RegisterArg)) {, +			return false;, +		RegisterArg reg = (RegisterArg) arg;, +		if (super.removeArg(reg)) {, +			blockBinds.remove(reg);, +			InstructionRemover.fixUsedInPhiFlag(reg);, +			return true;, +		}, +		return false;, +	}, +, +	@Override, +	public boolean replaceArg(InsnArg from, InsnArg to) {, +		if (!(from instanceof RegisterArg) || !(to instanceof RegisterArg)) {, +			return false;, +		}, +		BlockNode pred = getBlockByArg((RegisterArg) from);, +		if (pred == null) {, +			throw new JadxRuntimeException("Unknown predecessor block by arg " + from + " in PHI: " + this);, +		}, +		if (removeArg(from)) {, +			bindArg((RegisterArg) to, pred);, +		}, +		return true;, +	}, +, +	@Override, +	public void setArg(int n, InsnArg arg) {, +		throw new JadxRuntimeException("Unsupported operation for PHI node");, +		return "PHI: " + getResult() + " = " + Utils.listToString(getArguments()), +				+ " binds: " + blockBinds;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, +			passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.utils.InstructionRemover;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import java.util.IdentityHashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.NotNull;, +, +public final class PhiInsn extends InsnNode {, +, +	private final Map<RegisterArg, BlockNode> blockBinds;, +		this.blockBinds = new IdentityHashMap<RegisterArg, BlockNode>(predecessors);, +	public RegisterArg bindArg(BlockNode pred) {, +		RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getType());, +		bindArg(arg, pred);]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +						if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +						if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +						if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +						if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +import javax.xml.parsers.DocumentBuilderFactory;, +			DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +						if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +import javax.xml.parsers.DocumentBuilderFactory;, +			DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +						if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +import javax.xml.parsers.DocumentBuilderFactory;, +			DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();, +++ /dev/null, +++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.file=文件, +menu.view=视图, +menu.recent_files=最近打开文件, +menu.no_recent_files=无最近打开文件, +menu.preferences=偏好, +menu.sync=同步, +menu.flatten=Show flatten packages, +menu.navigation=导航, +menu.text_search=搜索文字, +menu.class_search=搜索类, +menu.tools=工具, +menu.log=日志查看器, +menu.help=帮助, +menu.about=关于, +menu.update_label=发现新版本 %s !, +, +file.open=打开文件, +file.save_all=保存全部, +file.export_gradle=另存为 gradle project, +file.save_all_msg=选择反编译资源路径, +file.select=选择, +file.exit=退出, +, +tree.loading=稍等..., +, +search=搜索, +search.previous=预览, +search.next=下一个, +search.mark_all=标记全部, +search.regex=正则表达式, +search.match_case=区分大小写, +search.whole_word=整个词语, +search.find=查询, +, +tabs.close=关闭, +tabs.closeOthers=关闭其他, +tabs.closeAll=关闭全部, +, +nav.back=后退, +nav.forward=向前, +, +search_dialog.open=打开, +search_dialog.cancel=取消]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.Collections;, +		for (ClassNode cls : classes) {, +			size += cls.getInnerClasses().size();, +		}, +		int k = 0;, +		for (ClassNode cls : classes) {, +			nClasses[k++] = addClass(cls);, +			for (ClassNode inner : cls.getInnerClasses()) {, +				nClasses[k++] = addClass(inner);, +			}, +	private NClass addClass(ClassNode cls) {, +		NClass nClass = new NClass(cls.getRawName(), -1);, +		nameMap.put(cls.getRawName(), nClass);, +		return nClass;, +	}, +, +		if (clsName.equals(implClsName)) {, +			return clsName;, +		}, +		NClass cls = nameMap.get(implClsName);, +		if (cls != null) {, +		}, +		if (result != null) {, +			return result;, +		}, +			result = new HashSet<String>();, +			if (result.isEmpty()) {, +				result = Collections.emptySet();, +			ancestorCache.put(clsName, result);, +		LOG.debug("Missing class: {}", clsName);, +		return Collections.emptySet();, +	}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.Collections;, +		for (ClassNode cls : classes) {, +			size += cls.getInnerClasses().size();, +		}, +		int k = 0;, +		for (ClassNode cls : classes) {, +			nClasses[k++] = addClass(cls);, +			for (ClassNode inner : cls.getInnerClasses()) {, +				nClasses[k++] = addClass(inner);, +			}, +	private NClass addClass(ClassNode cls) {, +		NClass nClass = new NClass(cls.getRawName(), -1);, +		nameMap.put(cls.getRawName(), nClass);, +		return nClass;, +	}, +, +		if (clsName.equals(implClsName)) {, +			return clsName;, +		}, +		NClass cls = nameMap.get(implClsName);, +		if (cls != null) {, +		}, +		if (result != null) {, +			return result;, +		}, +			result = new HashSet<String>();, +			if (result.isEmpty()) {, +				result = Collections.emptySet();, +			ancestorCache.put(clsName, result);, +		LOG.debug("Missing class: {}", clsName);, +		return Collections.emptySet();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +			String parClsName = pkg + "." + clsName.substring(0, sep);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.Collections;, +		for (ClassNode cls : classes) {, +			size += cls.getInnerClasses().size();, +		}, +		int k = 0;, +		for (ClassNode cls : classes) {, +			nClasses[k++] = addClass(cls);, +			for (ClassNode inner : cls.getInnerClasses()) {, +				nClasses[k++] = addClass(inner);, +			}, +	private NClass addClass(ClassNode cls) {, +		NClass nClass = new NClass(cls.getRawName(), -1);, +		nameMap.put(cls.getRawName(), nClass);, +		return nClass;, +	}, +, +		if (clsName.equals(implClsName)) {, +			return clsName;, +		}, +		NClass cls = nameMap.get(implClsName);, +		if (cls != null) {, +		}, +		if (result != null) {, +			return result;, +		}, +			result = new HashSet<String>();, +			if (result.isEmpty()) {, +				result = Collections.emptySet();, +			ancestorCache.put(clsName, result);, +		LOG.debug("Missing class: {}", clsName);, +		return Collections.emptySet();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, +	<T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, +	<T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, +	<T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/TargetInsnNode.java, +	public void initBlocks(BlockNode curBlock) {, +	}, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, +	<T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/TargetInsnNode.java, +	public void initBlocks(BlockNode curBlock) {, +	}, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +			setEditorThemePath(EditorTheme.getDefaultTheme().getPath());, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, +	<T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/TargetInsnNode.java, +	public void initBlocks(BlockNode curBlock) {, +	}, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +			setEditorThemePath(EditorTheme.getDefaultTheme().getPath());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +		EditorTheme[] editorThemes = EditorTheme.getAllThemes();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, +		// ignore, +		// ignore, +		// ignore, +		// ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, +	<T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/TargetInsnNode.java, +	public void initBlocks(BlockNode curBlock) {, +	}, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +			setEditorThemePath(EditorTheme.getDefaultTheme().getPath());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +		EditorTheme[] editorThemes = EditorTheme.getAllThemes();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/EditorTheme.java, +	private static final EditorTheme[] ALL_THEMES =, +	public static EditorTheme[] getAllThemes() {, +		return ALL_THEMES;, +	}, +, +	public static EditorTheme getDefaultTheme() {, +		return ALL_THEMES[0];, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		ArgType type = classInfo.getType();, +		ArgType[] generics = type.getGenericTypes();, +		if (generics == null) {, +			return baseClass;, +		}, +, +			ArgType wt = gt.getWildcardType();, +			if (wt != null) {, +				int bounds = gt.getWildcardBounds();, +				if (bounds != 0) {, +					sb.append(bounds == -1 ? " super " : " extends ");, +					sb.append(TypeGen.translate(this, wt));, +				}, +			} else {, +				sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		ArgType type = classInfo.getType();, +		ArgType[] generics = type.getGenericTypes();, +		if (generics == null) {, +			return baseClass;, +		}, +, +			ArgType wt = gt.getWildcardType();, +			if (wt != null) {, +				int bounds = gt.getWildcardBounds();, +				if (bounds != 0) {, +					sb.append(bounds == -1 ? " super " : " extends ");, +					sb.append(TypeGen.translate(this, wt));, +				}, +			} else {, +				sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +				LOG.error("Error reload instructions in fallback mode:", e);, +				code.startLine("// Can't loadFile method instructions: " + e.getMessage());, +		List<InsnNode> insns = mth.getInstructions();, +		if (insns == null) {, +			code.startLine("// Can't load method instructions.");, +			return;, +		}, +		addFallbackInsns(code, mth, insns, true);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		ArgType type = classInfo.getType();, +		ArgType[] generics = type.getGenericTypes();, +		if (generics == null) {, +			return baseClass;, +		}, +, +			ArgType wt = gt.getWildcardType();, +			if (wt != null) {, +				int bounds = gt.getWildcardBounds();, +				if (bounds != 0) {, +					sb.append(bounds == -1 ? " super " : " extends ");, +					sb.append(TypeGen.translate(this, wt));, +				}, +			} else {, +				sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +				LOG.error("Error reload instructions in fallback mode:", e);, +				code.startLine("// Can't loadFile method instructions: " + e.getMessage());, +		List<InsnNode> insns = mth.getInstructions();, +		if (insns == null) {, +			code.startLine("// Can't load method instructions.");, +			return;, +		}, +		addFallbackInsns(code, mth, insns, true);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.parser.SignatureParser;, +		return new ObjectType(obj);, +		return new GenericType(type);, +	}, +, +	public static ArgType wildcard() {, +		return new WildcardType(OBJECT, 0);, +	}, +, +	public static ArgType wildcard(ArgType obj, int bound) {, +		return new WildcardType(obj, bound);, +		return new SignatureParser(sign).consumeType();, +		return new GenericObject(obj, generics);, +	}, +, +	public static ArgType genericInner(ArgType genericType, String innerName, ArgType[] generics) {, +		return new GenericObject((GenericObject) genericType, innerName, generics);, +	private abstract static class KnownType extends ArgType {, +	private static final class PrimitiveArg extends KnownType {, +	private static class ObjectType extends KnownType {, +		public ObjectType(String obj) {, +			return object.equals(((ObjectType) obj).object);, +	private static final class GenericType extends ObjectType {, +		public GenericType(String obj) {, +	private static final class WildcardType extends ObjectType {, +		private final ArgType type;, +		private final int bounds;, +		public WildcardType(ArgType obj, int bound) {, +			super(obj.getObject());, +			this.type = obj;, +			this.bounds = bound;, +		}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java, +package jadx.core.utils;, +, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +, +import java.util.ArrayList;, +import java.util.Iterator;, +import java.util.List;, +, +/**, + * Helper class for correct instructions removing,, + * can be used while iterating over instructions list, + */, +public class InstructionRemover {, +, +	private final List<InsnNode> insns;, +	private final List<InsnNode> toRemove;, +, +	public InstructionRemover(List<InsnNode> instructions) {, +		this.insns = instructions;, +		this.toRemove = new ArrayList<InsnNode>();, +	}, +, +	public void add(InsnNode insn) {, +		toRemove.add(insn);, +	}, +, +	public void perform() {, +		removeAll(insns, toRemove);, +		toRemove.clear();, +	}, +, +	public static void unbindInsnList(List<InsnNode> unbind) {, +		for (InsnNode rem : unbind), +			unbindInsn(rem);, +	}, +, +	public static void unbindInsn(InsnNode insn) {, +		if (insn.getResult() != null) {, +			InsnArg res = insn.getResult();, +			res.getTypedVar().getUseList().remove(res);, +		}, +		for (InsnArg arg : insn.getArguments()) {, +			if (arg.isRegister()) {, +				arg.getTypedVar().getUseList().remove(arg);, +			}, +		}, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +	private static final int ENCODED_BYTE = 0x00;, +	private static final int ENCODED_SHORT = 0x02;, +	private static final int ENCODED_CHAR = 0x03;, +	private static final int ENCODED_INT = 0x04;, +	private static final int ENCODED_LONG = 0x06;, +	private static final int ENCODED_FLOAT = 0x10;, +	private static final int ENCODED_DOUBLE = 0x11;, +	private static final int ENCODED_STRING = 0x17;, +	private static final int ENCODED_TYPE = 0x18;, +	private static final int ENCODED_FIELD = 0x19;, +	private static final int ENCODED_ENUM = 0x1b;, +	private static final int ENCODED_METHOD = 0x1a;, +	private static final int ENCODED_ARRAY = 0x1c;, +	private static final int ENCODED_ANNOTATION = 0x1d;, +	private static final int ENCODED_NULL = 0x1e;, +	private static final int ENCODED_BOOLEAN = 0x1f;]
[+++ b/build.gradle, +        sourceCompatibility = JavaVersion.VERSION_1_8, +        targetCompatibility = JavaVersion.VERSION_1_8, +++ b/build.gradle, +        sourceCompatibility = JavaVersion.VERSION_1_8, +        targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +        sourceCompatibility = JavaVersion.VERSION_1_8, +        targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-bin.zip, +++ b/build.gradle, +        sourceCompatibility = JavaVersion.VERSION_1_8, +        targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-bin.zip, +++ b/gradlew, +#!/usr/bin/env sh, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do, +    ls=`ls -ld "$PRG"`, +    link=`expr "$ls" : '.*-> \(.*\)$'`, +    if expr "$link" : '/.*' > /dev/null; then, +        PRG="$link", +    else, +        PRG=`dirname "$PRG"`"/$link", +    fi, +done, +SAVED="`pwd`", +cd "`dirname \"$PRG\"`/" >/dev/null, +APP_HOME="`pwd -P`", +cd "$SAVED" >/dev/null, +# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script., +DEFAULT_JVM_OPTS="", +, +nonstop=false, +  NONSTOP* ), +    nonstop=true, +    ;;, +if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then, +    JAVACMD=`cygpath --unix "$JAVACMD"`, +# Escape application args, +save () {, +    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done, +    echo " ", +APP_ARGS=$(save "$@"), +# Collect all arguments for the java command, following the shell quoting and substitution rules, +eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS", +, +# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong, +if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then, +  cd "$(dirname "$0")", +fi, +, +exec "$JAVACMD" "$@", +++ b/build.gradle, +        sourceCompatibility = JavaVersion.VERSION_1_8, +        targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-bin.zip, +++ b/gradlew, +#!/usr/bin/env sh, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do, +    ls=`ls -ld "$PRG"`, +    link=`expr "$ls" : '.*-> \(.*\)$'`, +    if expr "$link" : '/.*' > /dev/null; then, +        PRG="$link", +    else, +        PRG=`dirname "$PRG"`"/$link", +    fi, +done, +SAVED="`pwd`", +cd "`dirname \"$PRG\"`/" >/dev/null, +APP_HOME="`pwd -P`", +cd "$SAVED" >/dev/null, +# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script., +DEFAULT_JVM_OPTS="", +, +nonstop=false, +  NONSTOP* ), +    nonstop=true, +    ;;, +if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then, +    JAVACMD=`cygpath --unix "$JAVACMD"`, +# Escape application args, +save () {, +    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done, +    echo " ", +APP_ARGS=$(save "$@")]
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (decompiler == null) {, +			throw new JadxRuntimeException("Can't decompile inner class");, +		}, +		load();, +	}, +	private void load() {, +					JavaClass javaClass = new JavaClass(null, inner);, +					javaClass.load();, +					list.add(javaClass);, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (decompiler == null) {, +			throw new JadxRuntimeException("Can't decompile inner class");, +		}, +		load();, +	}, +	private void load() {, +					JavaClass javaClass = new JavaClass(null, inner);, +					javaClass.load();, +					list.add(javaClass);, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +			JClass cls = node.getRootClass();, +			if (cls != null) {, +				showCode(cls, node.getLine());, +					cls.getRootClass().load();, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (decompiler == null) {, +			throw new JadxRuntimeException("Can't decompile inner class");, +		}, +		load();, +	}, +	private void load() {, +					JavaClass javaClass = new JavaClass(null, inner);, +					javaClass.load();, +					list.add(javaClass);, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +			JClass cls = node.getRootClass();, +			if (cls != null) {, +				showCode(cls, node.getLine());, +					cls.getRootClass().load();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +	private final JClass jParent;, +		this.jParent = null;, +		this.loaded = false;, +	}, +, +	public JClass(JavaClass cls, JClass parent) {, +		this.cls = cls;, +		this.jParent = parent;, +		this.loaded = true;, +				JClass child = new JClass(javaClass, this);, +				child.updateChilds();, +				add(new JField(f, this));, +				add(new JMethod(m, this));, +	@Override, +	public JClass getJParent() {, +		return jParent;, +	public JClass getRootClass() {, +		if (jParent == null) {, +			return this;, +		}, +		return jParent.getRootClass();, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (decompiler == null) {, +			throw new JadxRuntimeException("Can't decompile inner class");, +		}, +		load();, +	}, +	private void load() {, +					JavaClass javaClass = new JavaClass(null, inner);, +					javaClass.load();, +					list.add(javaClass);, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +			JClass cls = node.getRootClass();, +			if (cls != null) {, +				showCode(cls, node.getLine());, +					cls.getRootClass().load();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +	private final JClass jParent;, +		this.jParent = null;, +		this.loaded = false;, +	}, +, +	public JClass(JavaClass cls, JClass parent) {, +		this.cls = cls;, +		this.jParent = parent;, +		this.loaded = true;, +				JClass child = new JClass(javaClass, this);, +				child.updateChilds();, +				add(new JField(f, this));, +				add(new JMethod(m, this));, +	@Override, +	public JClass getJParent() {, +		return jParent;, +	public JClass getRootClass() {, +		if (jParent == null) {]
[+++ b/build.gradle, +        testCompile 'ch.qos.logback:logback-classic:1.1.2', +        testCompile 'cglib:cglib-nodep:3.1', +++ b/build.gradle, +        testCompile 'ch.qos.logback:logback-classic:1.1.2', +        testCompile 'cglib:cglib-nodep:3.1', +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import jadx.core.utils.exceptions.JadxException;, +		reset();, +	void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +	public void loadFile(File file) throws JadxException {, +	public void loadFiles(List<File> files) throws JadxException {, +			throw new JadxException("Empty file list");, +			try {, +			} catch (IOException e) {, +				throw new JadxException("Error load file: " + file, e);, +			}, +			throw new JadxRuntimeException("Save interrupted", e);, +	public ExecutorService getSaveExecutor() {, +		ExecutorService executor = Executors.newFixedThreadPool(threadsCount);, +		if (root == null) {, +			return Collections.emptyList();, +		}, +		List<JavaClass> classList = getClasses();, +		if (classList.isEmpty()) {, +			return Collections.emptyList();, +		}, +		for (JavaClass javaClass : classList) {, +, +	@Override, +	public String toString() {, +		return "jadx decompiler";, +	}, +++ b/build.gradle, +        testCompile 'ch.qos.logback:logback-classic:1.1.2', +        testCompile 'cglib:cglib-nodep:3.1', +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import jadx.core.utils.exceptions.JadxException;, +		reset();, +	void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +	public void loadFile(File file) throws JadxException {, +	public void loadFiles(List<File> files) throws JadxException {, +			throw new JadxException("Empty file list");, +			try {, +			} catch (IOException e) {, +				throw new JadxException("Error load file: " + file, e);, +			}, +			throw new JadxRuntimeException("Save interrupted", e);, +	public ExecutorService getSaveExecutor() {, +		ExecutorService executor = Executors.newFixedThreadPool(threadsCount);, +		if (root == null) {, +			return Collections.emptyList();, +		}, +		List<JavaClass> classList = getClasses();, +		if (classList.isEmpty()) {, +			return Collections.emptyList();, +		}, +		for (JavaClass javaClass : classList) {, +, +	@Override, +	public String toString() {, +		return "jadx decompiler";, +	}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +		if (code == null) {, +			return "";, +		}, +		return code.toString();, +				if (!inner.contains(AFlag.DONT_GENERATE)) {, +				if (!f.contains(AFlag.DONT_GENERATE)) {, +				if (!m.contains(AFlag.DONT_GENERATE)) {, +++ b/build.gradle, +        testCompile 'ch.qos.logback:logback-classic:1.1.2', +        testCompile 'cglib:cglib-nodep:3.1', +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import jadx.core.utils.exceptions.JadxException;, +		reset();, +	void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +	public void loadFile(File file) throws JadxException {, +	public void loadFiles(List<File> files) throws JadxException {, +			throw new JadxException("Empty file list");, +			try {, +			} catch (IOException e) {]
[+++ b/build.gradle, +, +		testCompile 'org.eclipse.jdt.core.compiler:ecj:4.6.1', +++ b/build.gradle, +, +		testCompile 'org.eclipse.jdt.core.compiler:ecj:4.6.1', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.api.JadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.core.ProcessClass;, +import jadx.core.codegen.CodeGen;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttributeNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.xmlgen.ResourceStorage;, +import jadx.core.xmlgen.entry.ResourceEntry;, +import jadx.tests.api.compiler.DynamicCompiler;, +import jadx.tests.api.compiler.StaticCompiler;, +import jadx.tests.api.utils.TestUtils;, +import org.junit.jupiter.api.BeforeEach;, +, +	private static final String OUT_DIR = "test-out-tmp";, +, +	private static final String CHECK_METHOD_NAME = "check";, +	protected boolean deleteTmpFiles;, +	protected boolean withDebugInfo;, +	protected boolean unloadCls;, +	protected boolean compile;, +	protected boolean useEclipseCompiler;, +	@BeforeEach, +	public void init() {, +		this.deleteTmpFiles = true;, +		this.unloadCls = true;, +		this.withDebugInfo = true;, +		this.compile = true;, +		this.useEclipseCompiler = false;, +		this.resMap = Collections.emptyMap();, +, +		args.setOutDir(new File(OUT_DIR));, +		List<File> files = StaticCompiler.compile(compileFileList, outTmp, withDebugInfo, useEclipseCompiler);, +	protected void useEclipseCompiler() {, +		this.useEclipseCompiler = true;, +	}, +, +++ b/build.gradle, +, +		testCompile 'org.eclipse.jdt.core.compiler:ecj:4.6.1', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.api.JadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.core.ProcessClass;, +import jadx.core.codegen.CodeGen;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttributeNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.xmlgen.ResourceStorage;, +import jadx.core.xmlgen.entry.ResourceEntry;, +import jadx.tests.api.compiler.DynamicCompiler;, +import jadx.tests.api.compiler.StaticCompiler;, +import jadx.tests.api.utils.TestUtils;, +import org.junit.jupiter.api.BeforeEach;, +, +	private static final String OUT_DIR = "test-out-tmp";, +, +	private static final String CHECK_METHOD_NAME = "check";, +	protected boolean deleteTmpFiles;, +	protected boolean withDebugInfo;, +	protected boolean unloadCls;, +	protected boolean compile;, +	protected boolean useEclipseCompiler;, +	@BeforeEach, +	public void init() {, +		this.deleteTmpFiles = true;, +		this.unloadCls = true;, +		this.withDebugInfo = true;, +		this.compile = true;, +		this.useEclipseCompiler = false;, +		this.resMap = Collections.emptyMap();, +, +		args.setOutDir(new File(OUT_DIR));, +		List<File> files = StaticCompiler.compile(compileFileList, outTmp, withDebugInfo, useEclipseCompiler);, +	protected void useEclipseCompiler() {, +		this.useEclipseCompiler = true;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/StaticCompiler.java]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.ErrorsCounter;, +			processAndSave(jadxArgs);, +		} catch (JadxException e) {, +	private static void processAndSave(JadxCLIArgs jadxArgs) {, +		try {, +			Decompiler jadx = new Decompiler(jadxArgs);, +			jadx.loadFiles(jadxArgs.getInput());, +			jadx.setOutputDir(jadxArgs.getOutDir());, +			jadx.save();, +			LOG.info("done");, +		} catch (Throwable e) {, +			LOG.error("jadx error:", e);, +		}, +		int errorsCount = ErrorsCounter.getErrorCount();, +		if (errorsCount != 0) {, +			ErrorsCounter.printReport();, +		}, +		System.exit(errorsCount);, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.ErrorsCounter;, +			processAndSave(jadxArgs);, +		} catch (JadxException e) {, +	private static void processAndSave(JadxCLIArgs jadxArgs) {, +		try {, +			Decompiler jadx = new Decompiler(jadxArgs);, +			jadx.loadFiles(jadxArgs.getInput());, +			jadx.setOutputDir(jadxArgs.getOutDir());, +			jadx.save();, +			LOG.info("done");, +		} catch (Throwable e) {, +			LOG.error("jadx error:", e);, +		}, +		int errorsCount = ErrorsCounter.getErrorCount();, +		if (errorsCount != 0) {, +			ErrorsCounter.printReport();, +		}, +		System.exit(errorsCount);, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	public List<File> getInput() {, +		return input;, +	}, +, +	public boolean isPrintHelp() {, +		return printHelp;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.ErrorsCounter;, +			processAndSave(jadxArgs);, +		} catch (JadxException e) {, +	private static void processAndSave(JadxCLIArgs jadxArgs) {, +		try {, +			Decompiler jadx = new Decompiler(jadxArgs);, +			jadx.loadFiles(jadxArgs.getInput());, +			jadx.setOutputDir(jadxArgs.getOutDir());, +			jadx.save();, +			LOG.info("done");, +		} catch (Throwable e) {, +			LOG.error("jadx error:", e);, +		}, +		int errorsCount = ErrorsCounter.getErrorCount();, +		if (errorsCount != 0) {, +			ErrorsCounter.printReport();, +		}, +		System.exit(errorsCount);, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	public List<File> getInput() {, +		return input;, +	}, +, +	public boolean isPrintHelp() {, +		return printHelp;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import java.util.Arrays;, +/**, + * Jadx API usage example:, + * <pre><code>, + *  Decompiler jadx = new Decompiler();, + *  jadx.loadFile(new File("classes.dex"));, + *  jadx.setOutputDir(new File("out"));, + *  jadx.save();, + * </code></pre>, + * <p/>, + * Instead of 'save()' you can get list of decompiled classes:, + * <pre><code>, + *  for(JavaClass cls : jadx.getClasses()) {, + *      System.out.println(cls.getCode());, + *  }, + * </code></pre>, + */]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	private static InsnWrapArg wrap(InsnNode insn) {, +	public static InsnArg wrapArg(InsnNode insn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	private static InsnWrapArg wrap(InsnNode insn) {, +	public static InsnArg wrapArg(InsnNode insn) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	private static InsnWrapArg wrap(InsnNode insn) {, +	public static InsnArg wrapArg(InsnNode insn) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +										return new ArithNode(ArithOp.ADD, fArg, fArg, InsnArg.wrapArg(concat));]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	/**, +	 * @return {@code clsName} instanceof {@code implClsName}, +	 */, +	public List<String> getImplementations(String clsName) {, +		List<String> list = new ArrayList<>();, +		for (String cls : nameMap.keySet()) {, +			if (isImplements(cls, clsName)) {, +				list.add(cls);, +			}, +		}, +		return list;, +	}, +, +	public Set<String> getAncestors(String clsName) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	/**, +	 * @return {@code clsName} instanceof {@code implClsName}, +	 */, +	public List<String> getImplementations(String clsName) {, +		List<String> list = new ArrayList<>();, +		for (String cls : nameMap.keySet()) {, +			if (isImplements(cls, clsName)) {, +				list.add(cls);, +			}, +		}, +		return list;, +	}, +, +	public Set<String> getAncestors(String clsName) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	/**, +	 * @return {@code clsName} instanceof {@code implClsName}, +	 */, +	public List<String> getImplementations(String clsName) {, +		List<String> list = new ArrayList<>();, +		for (String cls : nameMap.keySet()) {, +			if (isImplements(cls, clsName)) {, +				list.add(cls);, +			}, +		}, +		return list;, +	}, +, +	public Set<String> getAncestors(String clsName) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			mth.addComment("JADX INFO: used method not loaded: " + callMth + ", types can be incorrect");, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	/**, +	 * @return {@code clsName} instanceof {@code implClsName}, +	 */, +	public List<String> getImplementations(String clsName) {, +		List<String> list = new ArrayList<>();, +		for (String cls : nameMap.keySet()) {, +			if (isImplements(cls, clsName)) {, +				list.add(cls);, +			}, +		}, +		return list;, +	}, +, +	public Set<String> getAncestors(String clsName) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			mth.addComment("JADX INFO: used method not loaded: " + callMth + ", types can be incorrect");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java, +import java.util.Objects;, +, +import jadx.core.utils.Utils;, +		return Objects.equals(index, other.index);, +		switch (insnType) {, +			case CAST:, +			case CHECK_CAST:, +				return InsnUtils.formatOffset(offset) + ": ", +						+ InsnUtils.insnTypeToString(insnType), +						+ getResult() + " = (" + InsnUtils.indexToString(index) + ") ", +						+ Utils.listToString(getArguments());, +, +			default:, +}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	/**, +	 * @return {@code clsName} instanceof {@code implClsName}, +	 */, +	public List<String> getImplementations(String clsName) {, +		List<String> list = new ArrayList<>();, +		for (String cls : nameMap.keySet()) {, +			if (isImplements(cls, clsName)) {, +				list.add(cls);, +			}, +		}, +		return list;, +	}, +, +	public Set<String> getAncestors(String clsName) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.StringUtils;, +	public CodeWriter addMultiLine(String str) {, +		buf.append(str);, +		if (str.contains(NL)) {, +			line += StringUtils.countMatches(str, NL);, +			offset = 0;, +		}, +		return this;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.StringUtils;, +	public CodeWriter addMultiLine(String str) {, +		buf.append(str);, +		if (str.contains(NL)) {, +			line += StringUtils.countMatches(str, NL);, +			offset = 0;, +		}, +		return this;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +					code.newLine().add("Error: ").addMultiLine(Utils.getStackTrace(cause));, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.StringUtils;, +	public CodeWriter addMultiLine(String str) {, +		buf.append(str);, +		if (str.contains(NL)) {, +			line += StringUtils.countMatches(str, NL);, +			offset = 0;, +		}, +		return this;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +					code.newLine().add("Error: ").addMultiLine(Utils.getStackTrace(cause));, +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static int countMatches(String str, String subStr) {, +		if (str == null || str.isEmpty() || subStr == null || subStr.isEmpty()) {, +			return 0;, +		}, +		int subStrLen = subStr.length();, +		int count = 0;, +		int idx = 0;, +		while ((idx = str.indexOf(subStr, idx)) != -1) {, +			count++;, +			idx += subStrLen;, +		}, +		return count;, +	}]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, +			NLS.setLocale(settings.getLangLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, +			NLS.setLocale(settings.getLangLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +	private static final int CURRENT_SETTINGS_VERSION = 4;, +	private LangLocale langLocale = NLS.defaultLocale();, +	public LangLocale getLangLocale(){, +		return this.langLocale;, +	}, +, +	public void setLangLocale(LangLocale langLocale) {, +		this.langLocale = langLocale;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 3) {, +			setLangLocale(NLS.defaultLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, +			NLS.setLocale(settings.getLangLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +	private static final int CURRENT_SETTINGS_VERSION = 4;, +	private LangLocale langLocale = NLS.defaultLocale();, +	public LangLocale getLangLocale(){, +		return this.langLocale;, +	}, +, +	public void setLangLocale(LangLocale langLocale) {, +		this.langLocale = langLocale;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 3) {, +			setLangLocale(NLS.defaultLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +			LOG.debug("Loaded settings: {}", makeString(settings));, +		builder.registerTypeAdapter(type, (InstanceCreator<T>) t -> into), +						.create(), +						.fromJson(json, type);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, +			NLS.setLocale(settings.getLangLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +	private static final int CURRENT_SETTINGS_VERSION = 4;, +	private LangLocale langLocale = NLS.defaultLocale();, +	public LangLocale getLangLocale(){, +		return this.langLocale;, +	}, +, +	public void setLangLocale(LangLocale langLocale) {, +		this.langLocale = langLocale;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 3) {, +			setLangLocale(NLS.defaultLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +			LOG.debug("Loaded settings: {}", makeString(settings));, +		builder.registerTypeAdapter(type, (InstanceCreator<T>) t -> into), +						.create(), +						.fromJson(json, type);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import jadx.gui.utils.LangLocale;, +	private final transient LangLocale prevLang;, +		this.prevLang = settings.getLangLocale();, +		setLocationRelativeTo(null);, +		saveBtn.addActionListener(event -> {, +			if (!settings.getLangLocale().equals(prevLang)){]
[+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +	private final Set<IAttributeNode> errorNodes = new HashSet<>();, +			List<String> errors = new ArrayList<>(errorNodes.size());, +			for (IAttributeNode node : errorNodes) {, +				errors.add(nodeName + ": " + node);, +			}, +			Collections.sort(errors);, +			for (String err : errors) {, +				LOG.error("  {}", err);]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			if (!tryDefaultLookAndFeel()) {, +			}, +			SwingUtilities.invokeLater(new MainWindow(settings)::open);, +, +	private static boolean tryDefaultLookAndFeel() {, +		String defLaf = System.getProperty("swing.defaultlaf");, +		if (defLaf != null) {, +			try {, +				UIManager.setLookAndFeel(defLaf);, +				return true;, +			} catch (Exception e) {, +				LOG.error("Failed to set default laf: {}", defLaf, e);, +			}, +		}, +		return false;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			if (!tryDefaultLookAndFeel()) {, +			}, +			SwingUtilities.invokeLater(new MainWindow(settings)::open);, +, +	private static boolean tryDefaultLookAndFeel() {, +		String defLaf = System.getProperty("swing.defaultlaf");, +		if (defLaf != null) {, +			try {, +				UIManager.setLookAndFeel(defLaf);, +				return true;, +			} catch (Exception e) {, +				LOG.error("Failed to set default laf: {}", defLaf, e);, +			}, +		}, +		return false;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.ui.CodeArea;, +	private static final int CURRENT_SETTINGS_VERSION = 2;, +	private String editorThemePath = "";, +	public String getEditorThemePath() {, +		return editorThemePath;, +	}, +, +	public void setEditorThemePath(String editorThemePath) {, +		this.editorThemePath = editorThemePath;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 1) {, +			setEditorThemePath(CodeArea.getAllThemes()[0].getPath());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			if (!tryDefaultLookAndFeel()) {, +			}, +			SwingUtilities.invokeLater(new MainWindow(settings)::open);, +, +	private static boolean tryDefaultLookAndFeel() {, +		String defLaf = System.getProperty("swing.defaultlaf");, +		if (defLaf != null) {, +			try {, +				UIManager.setLookAndFeel(defLaf);, +				return true;, +			} catch (Exception e) {, +				LOG.error("Failed to set default laf: {}", defLaf, e);, +			}, +		}, +		return false;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.ui.CodeArea;, +	private static final int CURRENT_SETTINGS_VERSION = 2;, +	private String editorThemePath = "";, +	public String getEditorThemePath() {, +		return editorThemePath;, +	}, +, +	public void setEditorThemePath(String editorThemePath) {, +		this.editorThemePath = editorThemePath;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 1) {, +			setEditorThemePath(CodeArea.getAllThemes()[0].getPath());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import java.util.stream.Stream;, +import jadx.gui.ui.CodeArea;, +import jadx.gui.ui.CodeArea.EditorTheme;, +, +					mainWindow.loadSettings();, +		EditorTheme[] editorThemes = CodeArea.getAllThemes();, +		final JComboBox<EditorTheme> themesCbx = new JComboBox<>(editorThemes);, +		for (EditorTheme theme: editorThemes) {, +			if (theme.getPath().equals(settings.getEditorThemePath())) {, +				themesCbx.setSelectedItem(theme);, +				break;, +			}, +		}, +		themesCbx.addActionListener(e -> {, +			int i = themesCbx.getSelectedIndex();, +			EditorTheme editorTheme = editorThemes[i];]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		for (final JavaClass cls : getClasses()) {, +					cls.decompile();, +					SaveCode.save(outDir, args, cls.getClassNode());, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		for (final JavaClass cls : getClasses()) {, +					cls.decompile();, +					SaveCode.save(outDir, args, cls.getClassNode());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +				noCode = false;, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		for (final JavaClass cls : getClasses()) {, +					cls.decompile();, +					SaveCode.save(outDir, args, cls.getClassNode());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +				noCode = false;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +		save(dir, args, cls);, +		return false;, +	}, +	public static void save(File dir, IJadxArgs args, ClassNode cls) {, +		CodeWriter clsCode = cls.getCode();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.SSAVar;, +		if (arg.getSVar().contains(AFlag.FINAL)) {, +			code.add("final ");, +		}, +				switch (replace.getReplaceType()) {, +					case CLASS_INSTANCE:, +						useClass(code, replace.getClsRef());, +						break;, +					case VAR:, +						addArg(code, replace.getVarRef());, +						break;, +			inlineAnonymousConstr(code, cls, insn);, +			return;, +		}, +		if (insn.isSelf()) {, +			throw new JadxRuntimeException("Constructor 'self' invoke must be removed!");, +		}, +		if (insn.isSuper()) {, +			code.add("super");, +		} else if (insn.isThis()) {, +			code.add("this");, +		} else {, +			code.add("new ");, +			useClass(code, insn.getClassType());, +		}, +		MethodNode callMth = mth.dex().resolveMethod(insn.getCallMth());, +		generateMethodArguments(code, insn, 0, callMth);, +	}, +, +	private void inlineAnonymousConstr(CodeWriter code, ClassNode cls, ConstructorInsn insn) throws CodegenException {, +		MethodNode callMth = mth.dex().resolveMethod(insn.getCallMth());, +		generateMethodArguments(code, insn, 0, callMth);, +		code.add(' ');, +				if (arg.isRegister()) {, +					SSAVar sVar = ((RegisterArg) arg).getSVar();, +					if (sVar != null && sVar.contains(AFlag.SKIP_ARG)) {, +						continue;, +					}, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.SSAVar;, +		if (arg.getSVar().contains(AFlag.FINAL)) {, +			code.add("final ");, +		}, +				switch (replace.getReplaceType()) {, +					case CLASS_INSTANCE:, +						useClass(code, replace.getClsRef());, +						break;, +					case VAR:, +						addArg(code, replace.getVarRef());, +						break;, +			inlineAnonymousConstr(code, cls, insn);, +			return;, +		}, +		if (insn.isSelf()) {, +			throw new JadxRuntimeException("Constructor 'self' invoke must be removed!");, +		}, +		if (insn.isSuper()) {, +			code.add("super");, +		} else if (insn.isThis()) {, +			code.add("this");, +		} else {, +			code.add("new ");, +			useClass(code, insn.getClassType());, +		}, +		MethodNode callMth = mth.dex().resolveMethod(insn.getCallMth());, +		generateMethodArguments(code, insn, 0, callMth);, +	}, +, +	private void inlineAnonymousConstr(CodeWriter code, ClassNode cls, ConstructorInsn insn) throws CodegenException {, +		MethodNode callMth = mth.dex().resolveMethod(insn.getCallMth());, +		generateMethodArguments(code, insn, 0, callMth);, +		code.add(' ');, +				if (arg.isRegister()) {, +					SSAVar sVar = ((RegisterArg) arg).getSVar();, +					if (sVar != null && sVar.contains(AFlag.SKIP_ARG)) {, +						continue;, +					}, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.instructions.args.SSAVar;, +			SSAVar argSVar = arg.getSVar();, +			if (argSVar!= null && argSVar.contains(AFlag.FINAL)) {, +				argsCode.add("final ");, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.SSAVar;, +		if (arg.getSVar().contains(AFlag.FINAL)) {, +			code.add("final ");, +		}, +				switch (replace.getReplaceType()) {, +					case CLASS_INSTANCE:, +						useClass(code, replace.getClsRef());, +						break;, +					case VAR:, +						addArg(code, replace.getVarRef());, +						break;, +			inlineAnonymousConstr(code, cls, insn);, +			return;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// ignore classes from default package, +		if (extClsInfo.isDefaultPackage()) {, +			return shortName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// ignore classes from default package, +		if (extClsInfo.isDefaultPackage()) {, +			return shortName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, +			if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// ignore classes from default package, +		if (extClsInfo.isDefaultPackage()) {, +			return shortName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, +			if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public boolean isDefaultPackage() {, +		return pkg.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// ignore classes from default package, +		if (extClsInfo.isDefaultPackage()) {, +			return shortName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, +			if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public boolean isDefaultPackage() {, +		return pkg.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java, +		this(cls, FieldInfo.fromDex(cls.dex(), field.getFieldIndex()),, +				field.getAccessFlags());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// ignore classes from default package, +		if (extClsInfo.isDefaultPackage()) {, +			return shortName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, +			if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public boolean isDefaultPackage() {, +		return pkg.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java, +		this(cls, FieldInfo.fromDex(cls.dex(), field.getFieldIndex()),, +				field.getAccessFlags());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +import jadx.core.utils.android.AndroidResourcesUtils;, +		appResClass = AndroidResourcesUtils.searchAppResClass(this);, +	public List<ClassNode> searchClassByShortName(String shortName) {, +		List<ClassNode> list = new ArrayList<ClassNode>();, +		for (DexNode dexNode : dexNodes) {, +			for (ClassNode cls : dexNode.getClasses()) {, +				if (cls.getClassInfo().getShortName().equals(shortName)) {, +					list.add(cls);, +				}, +			}, +		}, +		return list;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// ignore classes from default package, +		if (extClsInfo.isDefaultPackage()) {, +			return shortName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, +			if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public boolean isDefaultPackage() {, +		return pkg.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/FieldNode.java, +		this(cls, FieldInfo.fromDex(cls.dex(), field.getFieldIndex()),, +				field.getAccessFlags());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +import jadx.core.utils.android.AndroidResourcesUtils;, +		appResClass = AndroidResourcesUtils.searchAppResClass(this);, +	public List<ClassNode> searchClassByShortName(String shortName) {, +		List<ClassNode> list = new ArrayList<ClassNode>();, +		for (DexNode dexNode : dexNodes) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +, +	public InsnArg duplicate() {, +		return this;, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +, +	public InsnArg duplicate() {, +		return this;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +, +	@Override, +	public RegisterArg duplicate() {, +		return duplicate(getRegNum(), getSVar());, +	}, +, +	@Override, +	public RegisterArg duplicate(int regNum, SSAVar sVar) {, +		RegisterArg dup = new TypeImmutableArg(regNum, getInitType());, +		if (sVar != null) {, +			dup.setSVar(sVar);, +		}, +		dup.copyAttributesFrom(this);, +		return dup;, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +, +	public InsnArg duplicate() {, +		return this;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +, +	@Override, +	public RegisterArg duplicate() {, +		return duplicate(getRegNum(), getSVar());, +	}, +, +	@Override, +	public RegisterArg duplicate(int regNum, SSAVar sVar) {, +		RegisterArg dup = new TypeImmutableArg(regNum, getInitType());, +		if (sVar != null) {, +			dup.setSVar(sVar);, +		}, +		dup.copyAttributesFrom(this);, +		return dup;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import org.jetbrains.annotations.Nullable;, +	public void setResult(@Nullable RegisterArg res) {, +			SSAVar ssaVar = res.getSVar();, +			if (ssaVar != null) {, +				ssaVar.setAssign(res);, +			}, +		arg.setParentInsn(this);, +		if (arg.isRegister()) {, +			RegisterArg reg = (RegisterArg) arg;, +			SSAVar ssaVar = reg.getSVar();, +			if (ssaVar != null) {, +				ssaVar.use(reg);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +, +	public InsnArg duplicate() {, +		return this;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +, +	@Override, +	public RegisterArg duplicate() {, +		return duplicate(getRegNum(), getSVar());, +	}, +, +	@Override, +	public RegisterArg duplicate(int regNum, SSAVar sVar) {, +		RegisterArg dup = new TypeImmutableArg(regNum, getInitType());, +		if (sVar != null) {, +			dup.setSVar(sVar);, +		}, +		dup.copyAttributesFrom(this);, +		return dup;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import org.jetbrains.annotations.Nullable;, +	public void setResult(@Nullable RegisterArg res) {, +			SSAVar ssaVar = res.getSVar();, +			if (ssaVar != null) {, +				ssaVar.setAssign(res);, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add("(");, +				code.add(") ");, +				code.add(arg(insn.getArg(0)));, +				if (wrap), +					code.add(")");, +	private void addArgs(CodeWriter code, InsnNode insn, int k) throws CodegenException {, +		int argsCount = insn.getArgsCount();, +		code.add('(');, +		if (k < argsCount) {, +			code.add(arg(insn.getArg(k), false));, +			for (int i = k + 1; i < argsCount; i++) {, +				code.add(", ");, +				code.add(arg(insn.getArg(i), false));, +			}, +		}, +		code.add(')');, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add("(");, +				code.add(") ");, +				code.add(arg(insn.getArg(0)));, +				if (wrap), +					code.add(")");, +	private void addArgs(CodeWriter code, InsnNode insn, int k) throws CodegenException {, +		int argsCount = insn.getArgsCount();, +		code.add('(');, +		if (k < argsCount) {, +			code.add(arg(insn.getArg(k), false));, +			for (int i = k + 1; i < argsCount; i++) {, +				code.add(", ");, +				code.add(arg(insn.getArg(i), false));, +			}, +		}, +		code.add(')');, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static boolean isCastNeeded(ArgType from, ArgType to) {, +		if (from.equals(to)) {, +			return false;, +		}, +		if (from.isObject() && to.isObject(), +				&& clsp.isImplements(from.getObject(), to.getObject())) {, +			return false;, +		}, +		return true;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add("(");, +				code.add(") ");, +				code.add(arg(insn.getArg(0)));, +				if (wrap), +					code.add(")");, +	private void addArgs(CodeWriter code, InsnNode insn, int k) throws CodegenException {, +		int argsCount = insn.getArgsCount();, +		code.add('(');, +		if (k < argsCount) {, +			code.add(arg(insn.getArg(k), false));, +			for (int i = k + 1; i < argsCount; i++) {, +				code.add(", ");, +				code.add(arg(insn.getArg(i), false));, +			}, +		}, +		code.add(')');, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static boolean isCastNeeded(ArgType from, ArgType to) {, +		if (from.equals(to)) {, +			return false;, +		}, +		if (from.isObject() && to.isObject(), +				&& clsp.isImplements(from.getObject(), to.getObject())) {, +			return false;, +		}, +		return true;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			if (cls.getClassDataOffset() != 0) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				boolean wrap = state.contains(IGState.BODY_ONLY);, +				if (wrap), +					code.add("(");, +				code.add("(");, +				code.add(") ");, +				code.add(arg(insn.getArg(0)));, +				if (wrap)]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isCfgOutput()) {, +				passes.add(DotGraphVisitor.dumpRegions());, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isCfgOutput()) {, +				passes.add(DotGraphVisitor.dumpRegions());, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isCfgOutput()) {, +				passes.add(DotGraphVisitor.dumpRegions());, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (els.contains(AFlag.ELSE_IF_CHAIN) && els instanceof Region) {, +			if (subBlocks.size() == 1) {, +				IContainer elseBlock = subBlocks.get(0);, +				if (elseBlock instanceof IfRegion) {, +					declareVars(code, elseBlock);, +					makeIf((IfRegion) elseBlock, code, false);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isCfgOutput()) {, +				passes.add(DotGraphVisitor.dumpRegions());, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (els.contains(AFlag.ELSE_IF_CHAIN) && els instanceof Region) {, +			if (subBlocks.size() == 1) {, +				IContainer elseBlock = subBlocks.get(0);, +				if (elseBlock instanceof IfRegion) {, +					declareVars(code, elseBlock);, +					makeIf((IfRegion) elseBlock, code, false);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java, +	void setParent(IRegion parent);, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isCfgOutput()) {, +				passes.add(DotGraphVisitor.dumpRegions());, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (els.contains(AFlag.ELSE_IF_CHAIN) && els instanceof Region) {, +			if (subBlocks.size() == 1) {, +				IContainer elseBlock = subBlocks.get(0);, +				if (elseBlock instanceof IfRegion) {, +					declareVars(code, elseBlock);, +					makeIf((IfRegion) elseBlock, code, false);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java, +	void setParent(IRegion parent);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +	@Override, +, +	public void updateParent(IContainer container, IRegion newParent) {, +		if (container instanceof IRegion) {, +			((IRegion) container).setParent(newParent);, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isCfgOutput()) {, +				passes.add(DotGraphVisitor.dumpRegions());, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (els.contains(AFlag.ELSE_IF_CHAIN) && els instanceof Region) {, +			if (subBlocks.size() == 1) {, +				IContainer elseBlock = subBlocks.get(0);, +				if (elseBlock instanceof IfRegion) {, +					declareVars(code, elseBlock);, +					makeIf((IfRegion) elseBlock, code, false);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java, +	void setParent(IRegion parent);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +	@Override, +, +	public void updateParent(IContainer container, IRegion newParent) {, +		if (container instanceof IRegion) {, +			((IRegion) container).setParent(newParent);, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(AbstractRegion.class);, +		LOG.warn("Replace sub block not supported for class \"{}\"", this.getClass());, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(AbstractRegion.class);, +		LOG.warn("Replace sub block not supported for class \"{}\"", this.getClass());, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfRegion.java, +	public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, +		if (oldBlock == thenRegion) {, +			thenRegion = newBlock;, +			return true;, +		}, +		if (oldBlock == elseRegion) {, +			elseRegion = newBlock;, +			return true;, +		}, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(AbstractRegion.class);, +		LOG.warn("Replace sub block not supported for class \"{}\"", this.getClass());, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfRegion.java, +	public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, +		if (oldBlock == thenRegion) {, +			thenRegion = newBlock;, +			return true;, +		}, +		if (oldBlock == elseRegion) {, +			elseRegion = newBlock;, +			return true;, +		}, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.attributes.AFlag;, +					checkAndWrap(mth, tryBlocksMap, region);, +	private static void checkAndWrap(MethodNode mth, Map<BlockNode, TryCatchBlock> tryBlocksMap, IRegion region) {, +				if (!wrapBlocks(region, tb, dominator)) {, +					LOG.warn("Can't wrap try/catch for {}, method: {}", dominator, mth);, +					mth.add(AFlag.INCONSISTENT_CODE);, +				}, +	private static boolean wrapBlocks(IRegion region, TryCatchBlock tb, BlockNode dominator) {, +		List<IContainer> subBlocks = region.getSubBlocks();, +		for (IContainer cont : subBlocks) {, +			return false;, +		if (!region.replaceSubBlock(firstNode, newRegion)) {, +			return false;, +		}, +		subBlocks.removeAll(newRegion.getSubBlocks());, +		return true;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +	public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, +		ArgType type = arg.getType();, +		long literal = arg.getLiteral();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +	public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, +		ArgType type = arg.getType();, +		long literal = arg.getLiteral();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +		}, +		// splice return block if several predecessors presents, +		for (BlockNode block : mth.getExitBlocks()) {, +			if (block.getInstructions().size() == 1, +			&&  block.getInstructions().get(0).getArgsCount() > 0, +			&& !block.getInstructions().get(0).getAttributes().contains(AttributeType.CATCH_BLOCK), +			&& !block.getAttributes().contains(AttributeFlag.SYNTHETIC)) {, +				InsnNode origReturnInsn = block.getInstructions().get(0);, +					BlockNode newRetBlock;, +					InsnNode predInsn = pred.getInstructions().get(0);, +, +					switch (predInsn.getType()) {, +						case IF:, +							newRetBlock = startNewBlock(mth, block.getStartOffset());, +							newRetBlock.getAttributes().add(AttributeFlag.SYNTHETIC);, +, +							if (pred.getSuccessors().get(0) == block) {, +								pred.getSuccessors().set(0, newRetBlock);, +							} else if (pred.getSuccessors().get(1) == block){, +								pred.getSuccessors().set(1, newRetBlock);, +							}, +							block.getPredecessors().remove(pred);, +							newRetBlock.getPredecessors().add(pred);, +							break;, +, +						case SWITCH:, +							// TODO: is it ok to just skip this predecessor?, +							block.getAttributes().add(AttributeFlag.SYNTHETIC);, +							continue;, +, +						default:, +							removeConnection(pred, block);, +							newRetBlock = pred;, +							break;, +					}, +					if (retArg != null) {, +						ret.getArg(0).forceSetTypedVar(retArg.getTypedVar());, +					}, +				if (block.getPredecessors().size() == 0) {, +					mth.getBasicBlocks().remove(block);, +					mth.getExitBlocks().remove(block);, +				return block.getAttributes().contains(AttributeFlag.SYNTHETIC);, +		}, +		// TODO detect ternary operator, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +	public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, +		ArgType type = arg.getType();, +		long literal = arg.getLiteral();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +		}, +		return null;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(EliminatePhiNodes.class);, +, +				removeInsn(mth, block, phiInsn);, +			}, +		}, +	}, +, +	private static void removeInsn(MethodNode mth, BlockNode block, PhiInsn phiInsn) {, +		Iterator<InsnNode> it = block.getInstructions().iterator();, +		while (it.hasNext()) {, +			InsnNode insn = it.next();, +				it.remove();, +				return;, +		LOG.warn("Phi node not removed: {}, mth: {}", phiInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(EliminatePhiNodes.class);, +, +				removeInsn(mth, block, phiInsn);, +			}, +		}, +	}, +, +	private static void removeInsn(MethodNode mth, BlockNode block, PhiInsn phiInsn) {, +		Iterator<InsnNode> it = block.getInstructions().iterator();, +		while (it.hasNext()) {, +			InsnNode insn = it.next();, +				it.remove();, +				return;, +		LOG.warn("Phi node not removed: {}, mth: {}", phiInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java, +import jadx.core.dex.instructions.PhiInsn;, +			case PHI: {, +				PhiInsn phi = (PhiInsn) insn;, +				SSAVar resultSVar = phi.getResult().getSVar();, +				if (resultSVar != null && !resultSVar.getType().isTypeKnown()) {, +					for (InsnArg arg : phi.getArguments()) {, +						ArgType argType = arg.getType();, +						if (argType.isTypeKnown()) {, +							resultSVar.setType(argType);, +							return true;, +						}, +					}, +				}, +				return false;, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(EliminatePhiNodes.class);, +, +				removeInsn(mth, block, phiInsn);, +			}, +		}, +	}, +, +	private static void removeInsn(MethodNode mth, BlockNode block, PhiInsn phiInsn) {, +		Iterator<InsnNode> it = block.getInstructions().iterator();, +		while (it.hasNext()) {, +			InsnNode insn = it.next();, +				it.remove();, +				return;, +		LOG.warn("Phi node not removed: {}, mth: {}", phiInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java, +import jadx.core.dex.instructions.PhiInsn;, +			case PHI: {, +				PhiInsn phi = (PhiInsn) insn;, +				SSAVar resultSVar = phi.getResult().getSVar();, +				if (resultSVar != null && !resultSVar.getType().isTypeKnown()) {, +					for (InsnArg arg : phi.getArguments()) {, +						ArgType argType = arg.getType();, +						if (argType.isTypeKnown()) {, +							resultSVar.setType(argType);, +							return true;, +						}, +					}, +				}, +				return false;, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java, +	private static ArgType processType(SSAVar var) {, +			ArgType newType = ArgType.merge(type, useType);, +			if (newType != null) {, +				type = newType;, +	private static void processPhiNode(PhiInsn phi) {, +	private static String processVarName(SSAVar var) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(EliminatePhiNodes.class);]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);, +			return null;, +		}, +			}, +		if (cls == null) {, +			LOG.debug("Missing class: {}", clsName);, +			return Collections.emptySet();, +		}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);, +			return null;, +		}, +			}, +		if (cls == null) {, +			LOG.debug("Missing class: {}", clsName);, +			return Collections.emptySet();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.IfCondition.Mode;, +		String mode = condition.getMode() == Mode.AND ? " && " : " || ";, +		return !condition.isCompare() && condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);, +			return null;, +		}, +			}, +		if (cls == null) {, +			LOG.debug("Missing class: {}", clsName);, +			return Collections.emptySet();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.IfCondition.Mode;, +		String mode = condition.getMode() == Mode.AND ? " && " : " || ";, +		return !condition.isCompare() && condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	private enum Flags {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);, +			return null;, +		}, +			}, +		if (cls == null) {, +			LOG.debug("Missing class: {}", clsName);, +			return Collections.emptySet();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.IfCondition.Mode;, +		String mode = condition.getMode() == Mode.AND ? " && " : " || ";, +		return !condition.isCompare() && condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	private enum Flags {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);, +			return null;, +		}, +			}, +		if (cls == null) {, +			LOG.debug("Missing class: {}", clsName);, +			return Collections.emptySet();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.IfCondition.Mode;, +		String mode = condition.getMode() == Mode.AND ? " && " : " || ";, +		return !condition.isCompare() && condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	private enum Flags {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		PrimitiveType stype = type.getPrimitiveType();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);, +			return null;, +		}, +			}, +		if (cls == null) {, +			LOG.debug("Missing class: {}", clsName);, +			return Collections.emptySet();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.IfCondition.Mode;, +		String mode = condition.getMode() == Mode.AND ? " && " : " || ";, +		return !condition.isCompare() && condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	private enum Flags {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		PrimitiveType stype = type.getPrimitiveType();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +	public enum Visibility {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		if (cls == null) {, +			LOG.debug("Missing class: {}", implClsName);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +, +		final String firstInputFileName = root.getDexNodes().get(0).getInputFile().getFile().getAbsolutePath();, +		final String inputPath = org.apache.commons.io.FilenameUtils.getFullPathNoEndSeparator(, +				firstInputFileName);, +		final String inputName = org.apache.commons.io.FilenameUtils.getBaseName(firstInputFileName);, +, +		File deobfMapFile = new File(inputPath, inputName + ".jobf");]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +		if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +		if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		String cleanClsName = NameMapper.removeInvalidChars(clsName, "C");, +		if (!NameMapper.isValidIdentifier(cleanClsName)) {, +			return 'C' + cleanClsName;, +		return cleanClsName;, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +		if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		String cleanClsName = NameMapper.removeInvalidChars(clsName, "C");, +		if (!NameMapper.isValidIdentifier(cleanClsName)) {, +			return 'C' + cleanClsName;, +		return cleanClsName;, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java, +package jadx.tests.integration.names;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.tests.api.SmaliTest;, +, +public class TestClassNameWithInvalidChar extends SmaliTest {, +	/*, +		public class do- {}, +		public class i-f {}, +	*/, +, +	@Test, +	public void test() {, +		JadxDecompiler d = loadSmaliFiles("names", "TestClassNameWithInvalidChar");, +		RootNode root = JadxInternalAccess.getRoot(d);, +		for (ClassNode cls : root.getClasses(false)) {, +			decompileAndCheckCls(d, cls);, +		}, +	}, +, +	@Test, +	public void testWithDeobfuscation() {, +		enableDeobfuscation();, +, +		JadxDecompiler d = loadSmaliFiles("names", "TestClassNameWithInvalidChar");, +		RootNode root = JadxInternalAccess.getRoot(d);, +		for (ClassNode cls : root.getClasses(false)) {, +			decompileAndCheckCls(d, cls);, +		}, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +		if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		String cleanClsName = NameMapper.removeInvalidChars(clsName, "C");, +		if (!NameMapper.isValidIdentifier(cleanClsName)) {, +			return 'C' + cleanClsName;, +		return cleanClsName;, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java, +package jadx.tests.integration.names;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.tests.api.SmaliTest;, +, +public class TestClassNameWithInvalidChar extends SmaliTest {, +	/*, +		public class do- {}, +		public class i-f {}, +	*/, +, +	@Test, +	public void test() {, +		JadxDecompiler d = loadSmaliFiles("names", "TestClassNameWithInvalidChar");, +		RootNode root = JadxInternalAccess.getRoot(d);, +		for (ClassNode cls : root.getClasses(false)) {, +			decompileAndCheckCls(d, cls);, +		}, +	}, +, +	@Test, +	public void testWithDeobfuscation() {, +		enableDeobfuscation();, +, +		JadxDecompiler d = loadSmaliFiles("names", "TestClassNameWithInvalidChar");, +		RootNode root = JadxInternalAccess.getRoot(d);, +		for (ClassNode cls : root.getClasses(false)) {, +			decompileAndCheckCls(d, cls);, +		}, +	}, +}, +++ b/jadx-core/src/test/smali/names/TestClassNameWithInvalidChar/a.smali, +.class public Ldo-;, +.super Ljava/lang/Object;]
[+++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.21.0', +        compile 'org.slf4j:slf4j-api:1.7.26', +        testCompile 'org.mockito:mockito-core:2.25.0', +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.21.0', +        compile 'org.slf4j:slf4j-api:1.7.26', +        testCompile 'org.mockito:mockito-core:2.25.0', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip, +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.21.0', +        compile 'org.slf4j:slf4j-api:1.7.26', +        testCompile 'org.mockito:mockito-core:2.25.0', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip, +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:7.1', +    compile 'org.jetbrains:annotations:17.0.0', +    compile 'uk.com.robust-it:cloning:1.9.12', +    testCompile 'org.smali:smali:2.2.6', +    testCompile 'org.smali:baksmali:2.2.6', +, +    // update dependency in smali, +    testCompile 'com.google.guava:guava:27.1-jre', +    testCompile 'com.beust:jcommander:1.74', +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.21.0', +        compile 'org.slf4j:slf4j-api:1.7.26', +        testCompile 'org.mockito:mockito-core:2.25.0', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip, +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:7.1', +    compile 'org.jetbrains:annotations:17.0.0', +    compile 'uk.com.robust-it:cloning:1.9.12', +    testCompile 'org.smali:smali:2.2.6', +    testCompile 'org.smali:baksmali:2.2.6', +, +    // update dependency in smali, +    testCompile 'com.google.guava:guava:27.1-jre', +    testCompile 'com.beust:jcommander:1.74', +++ b/jadx-gui/build.gradle, +    id 'edu.sc.seis.launch4j' version '2.4.5', +    id 'com.github.johnrengelman.shadow' version '5.0.0', +, +    compile 'com.fifesoft:rsyntaxtextarea:3.0.2', +    compile 'io.reactivex.rxjava2:rxjava:2.2.7', +    compile "com.github.akarnokd:rxjava2-swing:0.3.4", +    compile 'com.android.tools.build:apksig:3.3.2']
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					&& stack.peekRegion() instanceof LoopRegion) {, +				LoopRegion outerLoop = (LoopRegion) stack.peekRegion();, +				if (outerLoop.getBody() == null /* processing not yet finished */, +						|| RegionUtils.isRegionContainsBlock(outerLoop, out)) {, +			}]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open_action"));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open_action"));, +++ b/jadx-gui/src/main/java/jadx/gui/utils/NLS.java, +import java.io.IOException;, +import java.io.InputStreamReader;, +import java.io.Reader;, +import java.net.URL;, +import java.nio.charset.StandardCharsets;, +import java.util.*;, +	private static Map<LangLocale, ResourceBundle> i18nMessagesMap = new HashMap<>();, +	private static ResourceBundle localizedMessagesMap;, +	private static ResourceBundle fallbackMessagesMap;, +		ResourceBundle bundle;, +		ClassLoader classLoader = ClassLoader.getSystemClassLoader();, +		String resName = String.format("i18n/Messages_%s.properties", locale.get());, +		URL bundleUrl = classLoader.getResource(resName);, +		try (Reader reader = new InputStreamReader(bundleUrl.openStream(), StandardCharsets.UTF_8)) {, +			bundle = new PropertyResourceBundle(reader);, +		} catch (IOException e) {, +			throw new RuntimeException("Failed to load " + resName, e);, +		i18nMessagesMap.put(locale, bundle);, +		try {, +			return localizedMessagesMap.getString(key);, +		} catch (MissingResourceException e) {, +			return fallbackMessagesMap.getString(key); // definitely exists, +		ResourceBundle bundle = i18nMessagesMap.get(locale);, +		if (bundle != null) {, +			try {, +				return bundle.getString(key);, +			} catch (MissingResourceException e) {, +		return fallbackMessagesMap.getString(key); // definitely exists]
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +			if(!ZipSecurity.isValidZipEntry(entry)) {, +				return null;, +			}, +			, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +			if(!ZipSecurity.isValidZipEntry(entry)) {, +				return null;, +			}, +			, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +			if(!ZipSecurity.isValidZipEntry(entry)) {, +				return null;, +			}, +			, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = new WeakHashMap<String, Set<String>>();, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +			if(!ZipSecurity.isValidZipEntry(entry)) {, +				return null;, +			}, +			, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = new WeakHashMap<String, Set<String>>();, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		collectWhileDominates(dominator, start, result);, +	private static void collectWhileDominates(BlockNode dominator, BlockNode child, List<BlockNode> result) {, +				collectWhileDominates(dominator, node, result);, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, +			if(!ZipSecurity.isValidZipEntry(entry)) {, +				return null;, +			}, +			, +				if(ZipSecurity.isValidZipEntry(entry)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, +						if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +	public boolean canThrowException() {, +		switch (getType()) {, +			case RETURN:, +			case IF:, +			case GOTO:, +			case MOVE:, +			case MOVE_EXCEPTION:, +			case NEG:, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +			case CMP_L:, +			case CMP_G:, +				return false;, +, +			default:, +				return true;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +	public boolean canThrowException() {, +		switch (getType()) {, +			case RETURN:, +			case IF:, +			case GOTO:, +			case MOVE:, +			case MOVE_EXCEPTION:, +			case NEG:, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +			case CMP_L:, +			case CMP_G:, +				return false;, +, +			default:, +				return true;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			boolean tryBlockStarted = false;, +			InsnNode insn = null;, +				if (insn != null) {, +					if (tryBlockStarted) {, +					} else if (insn.canThrowException()) {, +						insn.add(AFlag.TRY_ENTER);, +						catchBlock.addInsn(insn);, +						tryBlockStarted = true;, +					}, +				}, +			} else if (insn != null) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, +	public boolean canThrowException() {, +		switch (getType()) {, +			case RETURN:, +			case IF:, +			case GOTO:, +			case MOVE:, +			case MOVE_EXCEPTION:, +			case NEG:, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +			case CMP_L:, +			case CMP_G:, +				return false;, +, +			default:, +				return true;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			boolean tryBlockStarted = false;, +			InsnNode insn = null;, +				if (insn != null) {, +					if (tryBlockStarted) {, +					} else if (insn.canThrowException()) {, +						insn.add(AFlag.TRY_ENTER);, +						catchBlock.addInsn(insn);, +						tryBlockStarted = true;, +					}, +				}, +			} else if (insn != null) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchStartOnMove.java, +package jadx.tests.integration.trycatch;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatchStartOnMove extends SmaliTest {, +]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.Iterator;, +	private final Map<MethodInfo, OverridedMethodsNode> ovrdMap = new HashMap<MethodInfo, OverridedMethodsNode>();, +	private final List<OverridedMethodsNode> ovrd = new ArrayList<OverridedMethodsNode>();, +, +		postProcess();, +	}, +, +	private void postProcess() {, +		int id = 1;, +		for (OverridedMethodsNode o : ovrd) {, +, +			Iterator<MethodInfo> it = o.getMethods().iterator();, +			if (it.hasNext()) {, +				MethodInfo mth = it.next();, +, +				if (mth.isRenamed() && !mth.isAliasFromPreset()) {, +					mth.setAlias(String.format("mo%d%s", id, makeName(mth.getName())));, +				}, +				String firstMethodAlias = mth.getAlias();, +, +				while (it.hasNext()) {, +					mth = it.next();, +					if (!mth.getAlias().equals(firstMethodAlias)) {, +						mth.setAlias(firstMethodAlias);, +					}, +				}, +			}, +, +			id++;, +		}, +, +		ovrd.clear();, +		ovrdMap.clear();, +	}, +, +	@Nullable, +	private static ClassNode resolveOverridingInternal(DexNode dex, ClassNode cls, String signature,, +			Set<MethodInfo> overrideSet, ClassNode rootClass) {, +		ClassNode result = null;, +, +		for (MethodNode m : cls.getMethods()) {, +			if (m.getMethodInfo().getShortId().startsWith(signature)) {, +				result = cls;, +				if (!overrideSet.contains(m.getMethodInfo())) {, +					overrideSet.add(m.getMethodInfo());, +				}, +				break;, +			}, +		}, +, +		ArgType superClass = cls.getSuperClass();, +		if (superClass != null) {, +			ClassNode superNode = dex.resolveClass(superClass);, +			if (superNode != null) {, +				ClassNode clsWithMth = resolveOverridingInternal(dex, superNode, signature, overrideSet, rootClass);, +				if (clsWithMth != null) {, +					if ((result != null) && (result != cls)) {, +						if (clsWithMth != result) {, +							LOG.warn(String.format("Multiple overriding '%s' from '%s' and '%s' in '%s'",, +									signature,, +									result.getFullName(), clsWithMth.getFullName(),, +									rootClass.getFullName()));, +						}, +					} else {, +						result = clsWithMth;, +					}, +				}, +			}, +		}, +, +		for (ArgType iFaceType : cls.getInterfaces()) {, +			ClassNode iFaceNode = dex.resolveClass(iFaceType);, +			if (iFaceNode != null) {, +				ClassNode clsWithMth = resolveOverridingInternal(dex, iFaceNode, signature, overrideSet, rootClass);, +				if (clsWithMth != null) {, +					if ((result != null) && (result != cls)) {, +						if (clsWithMth != result) {, +							LOG.warn(String.format("Multiple overriding '%s' from '%s' and '%s' in '%s'",, +									signature,, +									result.getFullName(), clsWithMth.getFullName(),, +									rootClass.getFullName()));, +						}, +					} else {, +						result = clsWithMth;, +					}, +				}, +			}, +		}, +, +		return result;, +	}, +, +	private void resolveOverriding(DexNode dex, ClassNode cls, MethodNode mth) {, +		Set<MethodInfo> overrideSet = new HashSet<MethodInfo>();, +		resolveOverridingInternal(dex, cls, mth.getMethodInfo().makeSignature(false), overrideSet, cls);, +]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +			case XML:, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +			case XML:, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private static final Charset STRING_CHARSET_UTF16 = Charset.forName("UTF-16LE");, +	private static final Charset STRING_CHARSET_UTF8 = Charset.forName("UTF-8");, +, +	private static final int RES_NULL_TYPE = 0x0000;, +	private static final int RES_STRING_POOL_TYPE = 0x0001;, +	private static final int RES_TABLE_TYPE = 0x0002;, +, +	private static final int RES_XML_TYPE = 0x0003;, +	private static final int RES_XML_FIRST_CHUNK_TYPE = 0x0100;, +	private static final int RES_XML_START_NAMESPACE_TYPE = 0x0100;, +	private static final int RES_XML_END_NAMESPACE_TYPE = 0x0101;, +	private static final int RES_XML_START_ELEMENT_TYPE = 0x0102;, +	private static final int RES_XML_END_ELEMENT_TYPE = 0x0103;, +	private static final int RES_XML_CDATA_TYPE = 0x0104;, +	private static final int RES_XML_LAST_CHUNK_TYPE = 0x017f;, +	private static final int RES_XML_RESOURCE_MAP_TYPE = 0x0180;, +, +	private static final int RES_TABLE_PACKAGE_TYPE = 0x0200;, +	private static final int RES_TABLE_TYPE_TYPE = 0x0201;, +	private static final int RES_TABLE_TYPE_SPEC_TYPE = 0x0202;, +, +	// string pool flags, +	private static final int SORTED_FLAG = 1;, +	private static final int UTF8_FLAG = 1 << 8;, +	private ParserStream is;, +		is = new ParserStream(inputStream);, +		if (is.readInt16() != 0x0003) {, +		if (is.readInt16() != 0x0008) {, +		int size = is.readInt32();, +		while (is.getPos() < size) {, +			int type = is.readInt16();, +				case RES_NULL_TYPE:, +					// NullType is just doing nothing, +					break;, +				case RES_STRING_POOL_TYPE:, +				case RES_XML_RESOURCE_MAP_TYPE:, +				case RES_XML_START_NAMESPACE_TYPE:, +				case RES_XML_END_NAMESPACE_TYPE:, +				case RES_XML_START_ELEMENT_TYPE:, +				case RES_XML_END_ELEMENT_TYPE:, +		if (is.readInt16() != 0x001c) {, +		int hsize = is.readInt32();, +		int stringCount = is.readInt32();, +		int styleCount = is.readInt32();, +		int flags = is.readInt32();, +		int stringsStart = is.readInt32();, +		int stylesStart = is.readInt32();, +		// skip string offsets, +		is.skip(stringCount * 4);, +		if ((flags & UTF8_FLAG) != 0) {, +			// UTF-8, +			long start = is.getPos();, +				int charsCount = is.decodeLength8();, +				int len = is.decodeLength8();, +				strings[i] = new String(is.readArray(len), STRING_CHARSET_UTF8);, +				int zero = is.readInt8();, +				if (zero != 0) {, +					die("Not a trailing zero at string end: " + zero + ", " + strings[i]);, +				}, +			}, +			long shift = is.getPos() - start;, +			if (shift % 2 != 0) {, +				is.skip(1);, +			}, +		} else {, +			// UTF-16, +			for (int i = 0; i < stringCount; i++) {, +				int len = is.decodeLength16();, +				strings[i] = new String(is.readArray(len * 2), STRING_CHARSET_UTF16);, +				int zero = is.readInt16();, +				if (zero != 0) {, +					die("Not a trailing zero at string end: " + zero + ", " + strings[i]);, +				}, +			}, +		}, +		if (styleCount != 0) {, +			die("Styles parsing in string pool not yet implemented");, +		if (is.readInt16() != 0x8) {, +		int rhsize = is.readInt32();, +			ids[i] = is.readInt32();, +		if (is.readInt16() != 0x10) {, +		if (is.readInt32() != 0x18) {, +		int beginLineNumber = is.readInt32();, +		int comment = is.readInt32();, +		int beginPrefix = is.readInt32();, +		int beginURI = is.readInt32();, +		if (is.readInt16() != 0x10) {, +		if (is.readInt32() != 0x18) {, +		int endLineNumber = is.readInt32();, +		int comment = is.readInt32();, +		int endPrefix = is.readInt32();, +		int endURI = is.readInt32();, +		if (is.readInt16() != 0x10) {, +		is.readInt32();, +		int elementBegLineNumber = is.readInt32();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			if (source.contains(AType.CATCH_BLOCK), +					&& source.getSuccessors().size() == 2) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			if (source.contains(AType.CATCH_BLOCK), +					&& source.getSuccessors().size() == 2) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +import jadx.core.dex.attributes.AFlag;, +		fixLastTryCatchAssign(mth);, +		if (removeUselessPhi(mth)) {, +			renameVariables(mth);, +		}, +, +	private static void fixLastTryCatchAssign(MethodNode mth) {, +		for (BlockNode block : mth.getBasicBlocks()) {, +			PhiListAttr phiList = block.get(AType.PHI_LIST);, +			if (phiList == null || !block.contains(AType.EXC_HANDLER)) {, +				continue;, +			}, +			for (PhiInsn phi : phiList.getList()) {, +				for (int i = 0; i < phi.getArgsCount(); i++) {, +					RegisterArg arg = phi.getArg(i);, +					InsnNode parentInsn = arg.getAssignInsn();, +					if (parentInsn != null, +							&& parentInsn.getResult() != null, +							&& parentInsn.contains(AFlag.TRY_LEAVE)) {, +						phi.removeArg(arg);, +					}, +				}, +			}, +		}, +	}, +, +	private static boolean removeUselessPhi(MethodNode mth) {, +		return removePhiList(mth, insnToRemove);, +	private static boolean removePhiList(MethodNode mth, List<PhiInsn> insnToRemove) {, +			return false;, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			if (source.contains(AType.CATCH_BLOCK), +					&& source.getSuccessors().size() == 2) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +import jadx.core.dex.attributes.AFlag;, +		fixLastTryCatchAssign(mth);, +		if (removeUselessPhi(mth)) {, +			renameVariables(mth);, +		}, +, +	private static void fixLastTryCatchAssign(MethodNode mth) {, +		for (BlockNode block : mth.getBasicBlocks()) {, +			PhiListAttr phiList = block.get(AType.PHI_LIST);, +			if (phiList == null || !block.contains(AType.EXC_HANDLER)) {, +				continue;, +			}, +			for (PhiInsn phi : phiList.getList()) {, +				for (int i = 0; i < phi.getArgsCount(); i++) {, +					RegisterArg arg = phi.getArg(i);, +					InsnNode parentInsn = arg.getAssignInsn();, +					if (parentInsn != null, +							&& parentInsn.getResult() != null, +							&& parentInsn.contains(AFlag.TRY_LEAVE)) {, +						phi.removeArg(arg);, +					}, +				}, +			}, +		}, +	}, +, +	private static boolean removeUselessPhi(MethodNode mth) {, +		return removePhiList(mth, insnToRemove);, +	private static boolean removePhiList(MethodNode mth, List<PhiInsn> insnToRemove) {, +			return false;, +		return true;, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestNestedLoops3.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			if (source.contains(AType.CATCH_BLOCK), +					&& source.getSuccessors().size() == 2) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +import jadx.core.dex.attributes.AFlag;, +		fixLastTryCatchAssign(mth);, +		if (removeUselessPhi(mth)) {, +			renameVariables(mth);, +		}, +, +	private static void fixLastTryCatchAssign(MethodNode mth) {, +		for (BlockNode block : mth.getBasicBlocks()) {, +			PhiListAttr phiList = block.get(AType.PHI_LIST);, +			if (phiList == null || !block.contains(AType.EXC_HANDLER)) {, +				continue;, +			}, +			for (PhiInsn phi : phiList.getList()) {, +				for (int i = 0; i < phi.getArgsCount(); i++) {, +					RegisterArg arg = phi.getArg(i);, +					InsnNode parentInsn = arg.getAssignInsn();, +					if (parentInsn != null, +							&& parentInsn.getResult() != null, +							&& parentInsn.contains(AFlag.TRY_LEAVE)) {, +						phi.removeArg(arg);, +					}, +				}]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +			baseDir = baseDir.getCanonicalFile();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +		} else if (arg.isInsnWrap()) {, +		} else if (arg.isNamed()) {, +			return ((NamedArg) arg).getName();, +		} else {, +			throw new CodegenException("Unknown arg type " + arg);, +					code.add("monitor-exit(").add(arg(insn, 0)).add(')');, +					code.add(arg(insn, 0));, +				code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +		} else if (arg.isInsnWrap()) {, +		} else if (arg.isNamed()) {, +			return ((NamedArg) arg).getName();, +		} else {, +			throw new CodegenException("Unknown arg type " + arg);, +					code.add("monitor-exit(").add(arg(insn, 0)).add(')');, +					code.add(arg(insn, 0));, +				code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +	 * @param arg register variable, +		if (varNames.add(name) || fallback), +	public String assignNamedArg(NamedArg arg) {, +		String name = arg.getName();, +		if (varNames.add(name) || fallback), +			return name;, +, +		name = getUniqVarName(name);, +		arg.setName(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +		} else if (arg.isInsnWrap()) {, +		} else if (arg.isNamed()) {, +			return ((NamedArg) arg).getName();, +		} else {, +			throw new CodegenException("Unknown arg type " + arg);, +					code.add("monitor-exit(").add(arg(insn, 0)).add(')');, +					code.add(arg(insn, 0));, +				code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +	 * @param arg register variable, +		if (varNames.add(name) || fallback), +	public String assignNamedArg(NamedArg arg) {, +		String name = arg.getName();, +		if (varNames.add(name) || fallback), +			return name;, +, +		name = getUniqVarName(name);, +		arg.setName(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			code.add(mgen.assignNamedArg(handler.getArg()));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +		} else if (arg.isInsnWrap()) {, +		} else if (arg.isNamed()) {, +			return ((NamedArg) arg).getName();, +		} else {, +			throw new CodegenException("Unknown arg type " + arg);, +					code.add("monitor-exit(").add(arg(insn, 0)).add(')');, +					code.add(arg(insn, 0));, +				code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +	 * @param arg register variable, +		if (varNames.add(name) || fallback), +	public String assignNamedArg(NamedArg arg) {, +		String name = arg.getName();, +		if (varNames.add(name) || fallback), +			return name;, +, +		name = getUniqVarName(name);, +		arg.setName(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			code.add(mgen.assignNamedArg(handler.getArg()));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/BlockRegState.java, +		regType.use(arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +		} else if (arg.isInsnWrap()) {, +		} else if (arg.isNamed()) {, +			return ((NamedArg) arg).getName();, +		} else {, +			throw new CodegenException("Unknown arg type " + arg);, +					code.add("monitor-exit(").add(arg(insn, 0)).add(')');, +					code.add(arg(insn, 0));, +				code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.instructions.args.NamedArg;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +		if (!elType.isTypeKnown() && insnElementType.isPrimitive()) {, +			if (elType.contains(insnElementType.getPrimitiveType())) {, +				elType = insnElementType;, +			}, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +	public boolean removeArg(RegisterArg arg) {, +		boolean isRemoved = super.removeArg(arg);, +		if (isRemoved) {, +			arg.getSVar().setUsedInPhi(null);, +		}, +		return isRemoved;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +	public boolean removeArg(RegisterArg arg) {, +		boolean isRemoved = super.removeArg(arg);, +		if (isRemoved) {, +			arg.getSVar().setUsedInPhi(null);, +		}, +		return isRemoved;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	protected boolean removeArg(InsnArg arg) {, +		int count = getArgsCount();, +		for (int i = 0; i < count; i++) {, +			if (arg == arguments.get(i)) {, +				arguments.remove(i);, +				return true;, +			}, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +	public boolean removeArg(RegisterArg arg) {, +		boolean isRemoved = super.removeArg(arg);, +		if (isRemoved) {, +			arg.getSVar().setUsedInPhi(null);, +		}, +		return isRemoved;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	protected boolean removeArg(InsnArg arg) {, +		int count = getArgsCount();, +		for (int i = 0; i < count; i++) {, +			if (arg == arguments.get(i)) {, +				arguments.remove(i);, +				return true;, +			}, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfRegion.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +	public boolean removeArg(RegisterArg arg) {, +		boolean isRemoved = super.removeArg(arg);, +		if (isRemoved) {, +			arg.getSVar().setUsedInPhi(null);, +		}, +		return isRemoved;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	protected boolean removeArg(InsnArg arg) {, +		int count = getArgsCount();, +		for (int i = 0; i < count; i++) {, +			if (arg == arguments.get(i)) {, +				arguments.remove(i);, +				return true;, +			}, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfRegion.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +	public boolean removeArg(RegisterArg arg) {, +		boolean isRemoved = super.removeArg(arg);, +		if (isRemoved) {, +			arg.getSVar().setUsedInPhi(null);, +		}, +		return isRemoved;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	protected boolean removeArg(InsnArg arg) {, +		int count = getArgsCount();, +		for (int i = 0; i < count; i++) {, +			if (arg == arguments.get(i)) {, +				arguments.remove(i);, +				return true;, +			}, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfRegion.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.mods.TernaryInsn;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final String[] INDENT_CACHE = {, +			"",, +			INDENT,, +			INDENT + INDENT,, +			INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT + INDENT,, +	};, +, +	public CodeWriter add(Object obj) {, +		buf.append(obj);, +		return this;, +	}, +, +		if (curIndent < INDENT_CACHE.length) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final String[] INDENT_CACHE = {, +			"",, +			INDENT,, +			INDENT + INDENT,, +			INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT + INDENT,, +	};, +, +	public CodeWriter add(Object obj) {, +		buf.append(obj);, +		return this;, +	}, +, +		if (curIndent < INDENT_CACHE.length) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +			switch (((ArithNode) insn).getOp()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final String[] INDENT_CACHE = {, +			"",, +			INDENT,, +			INDENT + INDENT,, +			INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT + INDENT,, +	};, +, +	public CodeWriter add(Object obj) {, +		buf.append(obj);, +		return this;, +	}, +, +		if (curIndent < INDENT_CACHE.length) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +			switch (((ArithNode) insn).getOp()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add('(');, +				code.add('(');, +				code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, +					code.add(')');, +					code.startLine("case ").add(sw.getKeys()[i]).add(": goto ");, +					code.add(MethodGen.getLabelName(sw.getTargets()[i])).add(';');, +				code.startLine("default: goto ");, +				code.add(MethodGen.getLabelName(sw.getDefaultCaseOffset())).add(';');, +				code.add("((").add(cond).add(')').add(" ? ").add(th).add(" : ").add(els).add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final String[] INDENT_CACHE = {, +			"",, +			INDENT,, +			INDENT + INDENT,, +			INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT,, +			INDENT + INDENT + INDENT + INDENT + INDENT,, +	};, +, +	public CodeWriter add(Object obj) {, +		buf.append(obj);, +		return this;, +	}, +, +		if (curIndent < INDENT_CACHE.length) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +			switch (((ArithNode) insn).getOp()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add('(');, +				code.add('(');, +				code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, +					code.add(')');, +					code.startLine("case ").add(sw.getKeys()[i]).add(": goto ");, +					code.add(MethodGen.getLabelName(sw.getTargets()[i])).add(';');, +				code.startLine("default: goto ");, +				code.add(MethodGen.getLabelName(sw.getDefaultCaseOffset())).add(';');, +				code.add("((").add(cond).add(')').add(" ? ").add(th).add(" : ").add(els).add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			return base;, +				if (Consts.DEBUG) {, +					return base + "_" + name;, +				return name;, +			// load original instructions, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final String[] INDENT_CACHE = {, +			"",, +			INDENT,]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java, +package jadx.gui.settings;, +, +public interface ISettingsUpdater {, +	void update(JadxSettings settings);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java, +package jadx.gui.settings;, +, +public interface ISettingsUpdater {, +	void update(JadxSettings settings);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public void partialSync(ISettingsUpdater updater) {, +		JadxSettings settings = JadxSettingsAdapter.load();, +		updater.update(settings);, +		JadxSettingsAdapter.store(settings);, +	}, +, +		partialSync(settings -> settings.lastOpenFilePath = JadxSettings.this.lastOpenFilePath);, +		partialSync(settings -> settings.lastSaveFilePath = JadxSettings.this.lastSaveFilePath);, +		partialSync(settings -> settings.flattenPackage = JadxSettings.this.flattenPackage);, +		partialSync(settings -> settings.recentFiles = recentFiles);, +		partialSync(settings -> settings.windowPos = windowPos);]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +		while((count+2)<=bytes.length) {, +			else if(type==0x0101) parseNameSpaceEnd();, +			else if(type==0x0103) parseElementEnd();, +			else if(type==0x0000) continue; // NullType is just doing nothing, +		//if(beginLineNumber!=2) die("NAMESPACE beginning line number != 2 not supported yet");, +		System.out.println("NAMESPACE BEGIN Line: " + beginLineNumber);, +	private void parseNameSpaceEnd() {, +		if(cInt16(bytes, count) != 0x0010) die("NAMESPACE header is not 0x0010");, +		if(cInt32(bytes, count) != 0x18) die("NAMESPACE header chunk is not 0x18 big");, +		int endLineNumber = cInt32(bytes, count);, +		//if(endLineNumber!=2) die("NAMESPACE begining line number != 2 not supported yet");, +		System.out.println("NAMESPACE END Line: " + endLineNumber);, +		System.out.println("Comment: 0x" + Integer.toHexString(cInt32(bytes, count)));, +		int endPrefix = cInt32(bytes, count);, +		System.out.println("Prefix: " + strings[endPrefix]);, +		nsPrefix = strings[endPrefix];, +		int endURI = cInt32(bytes, count);, +		System.out.println("URI: " + strings[endURI]);, +	}, +, +		//if(cInt32(bytes, count) != 0x0060) die("ELEMENT CHUNK SIZE is not 0x60");, +		count+=4;, +		System.out.println("<" + strings[startNSName] + "");, +			else System.out.println(strings[attributeName] + " = UNKNOWN DATA TYPE: " + attrValDataType);, +		System.out.println(">");, +	}, +, +	private void parseElementEnd() {, +		if(cInt16(bytes, count) != 0x0010) die("ELEMENT END header is not 0x0010");, +		if(cInt32(bytes, count) != 0x18) die("ELEMENT END header chunk is not 0x18 big");, +		int endLineNumber = cInt32(bytes, count);, +		//if(endLineNumber!=2) die("NAMESPACE beginning line number != 2 not supported yet");, +		System.out.println("ELEMENT END Line:" + endLineNumber);, +		System.out.println("Comment: 0x" + Integer.toHexString(cInt32(bytes, count)));, +		int elementNS = cInt32(bytes, count);, +		int elementName = cInt32(bytes, count);, +		System.out.print("</");, +		if(elementNS != -1) System.out.print(strings[elementNS]+":");, +		System.out.println(strings[elementName]+">");]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +import java.nio.charset.Charset;, +import java.nio.file.Files;, +import java.nio.file.Path;, +	private static final Charset MAP_FILE_CHARSET = UTF_8;, +	private final Path deobfMapFile;, +	public DeobfPresets(Deobfuscator deobfuscator, Path deobfMapFile) {, +		if (!Files.exists(deobfMapFile)) {, +		LOG.info("Loading obfuscation map from: {}", deobfMapFile.toAbsolutePath());, +			List<String> lines = Files.readAllLines(deobfMapFile, MAP_FILE_CHARSET);, +			LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, +			if (Files.exists(deobfMapFile)) {, +							deobfMapFile.toAbsolutePath());, +			LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, +		Files.write(deobfMapFile, list, MAP_FILE_CHARSET);, +++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +import java.nio.charset.Charset;, +import java.nio.file.Files;, +import java.nio.file.Path;, +	private static final Charset MAP_FILE_CHARSET = UTF_8;, +	private final Path deobfMapFile;, +	public DeobfPresets(Deobfuscator deobfuscator, Path deobfMapFile) {, +		if (!Files.exists(deobfMapFile)) {, +		LOG.info("Loading obfuscation map from: {}", deobfMapFile.toAbsolutePath());, +			List<String> lines = Files.readAllLines(deobfMapFile, MAP_FILE_CHARSET);, +			LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, +			if (Files.exists(deobfMapFile)) {, +							deobfMapFile.toAbsolutePath());, +			LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, +		Files.write(deobfMapFile, list, MAP_FILE_CHARSET);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.nio.file.Path;, +	@Deprecated, +		this(args, dexNodes, deobfMapFile.toPath());, +	}, +, +	public Deobfuscator(JadxArgs args, @NotNull List<DexNode> dexNodes, Path deobfMapFile) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +import java.nio.charset.Charset;, +import java.nio.file.Files;, +import java.nio.file.Path;, +	private static final Charset MAP_FILE_CHARSET = UTF_8;, +	private final Path deobfMapFile;, +	public DeobfPresets(Deobfuscator deobfuscator, Path deobfMapFile) {, +		if (!Files.exists(deobfMapFile)) {, +		LOG.info("Loading obfuscation map from: {}", deobfMapFile.toAbsolutePath());, +			List<String> lines = Files.readAllLines(deobfMapFile, MAP_FILE_CHARSET);, +			LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, +			if (Files.exists(deobfMapFile)) {, +							deobfMapFile.toAbsolutePath());, +			LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, +		Files.write(deobfMapFile, list, MAP_FILE_CHARSET);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.nio.file.Path;, +	@Deprecated, +		this(args, dexNodes, deobfMapFile.toPath());, +	}, +, +	public Deobfuscator(JadxArgs args, @NotNull List<DexNode> dexNodes, Path deobfMapFile) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import java.nio.file.Path;, +		Path inputFilePath = firstInputFile.getFile().toPath();, +		String inputName = inputFilePath.getFileName().toString();, +		inputName = inputName.substring(0, inputName.lastIndexOf('.'));, +, +		Path deobfMapPath = inputFilePath.getParent().resolve(inputName + ".jobf");, +		deobfuscator = new Deobfuscator(args, dexNodes, deobfMapPath);]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +		if (deobfuscationMinLength < 0) {, +			deobfuscationMinLength = 0;, +		}, +		if (deobfuscationMaxLength < 0) {, +			deobfuscationMaxLength = 0;, +		}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +		if (deobfuscationMinLength < 0) {, +			deobfuscationMinLength = 0;, +		}, +		if (deobfuscationMaxLength < 0) {, +			deobfuscationMaxLength = 0;, +		}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import jadx.gui.utils.LangLocale;, +		SpinnerNumberModel minLenModel = new SpinnerNumberModel(settings.getDeobfuscationMinLength(), 0, Integer.MAX_VALUE, 1);, +		JSpinner minLenSpinner = new JSpinner(minLenModel);, +		minLenSpinner.addChangeListener(e -> {, +			settings.setDeobfuscationMinLength((Integer) minLenSpinner.getValue());, +		SpinnerNumberModel maxLenModel = new SpinnerNumberModel(settings.getDeobfuscationMaxLength(), 0, Integer.MAX_VALUE, 1);, +		JSpinner maxLenSpinner = new JSpinner(maxLenModel);, +		maxLenSpinner.addChangeListener(e -> {, +			settings.setDeobfuscationMaxLength((Integer) maxLenSpinner.getValue());, +		deobfGroup.addRow(NLS.str("preferences.deobfuscation_min_len"), minLenSpinner);, +		deobfGroup.addRow(NLS.str("preferences.deobfuscation_max_len"), maxLenSpinner);, +		Collection<JComponent> connectedComponents = Arrays.asList(deobfForce, minLenSpinner, maxLenSpinner, deobfSourceAlias);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			for (ClassInfo importCls : getImports()) {, +					if (classInfo.isInner()) {, +						String parent = useClassInternal(useCls, classInfo.getParentClass());, +						return parent + "." + shortName;, +					} else {, +			}, +	private Set<ClassInfo> getImports() {, +		if (parentGen != null) {, +			return parentGen.getImports();, +		} else {, +			return imports;, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			for (ClassInfo importCls : getImports()) {, +					if (classInfo.isInner()) {, +						String parent = useClassInternal(useCls, classInfo.getParentClass());, +						return parent + "." + shortName;, +					} else {, +			}, +	private Set<ClassInfo> getImports() {, +		if (parentGen != null) {, +			return parentGen.getImports();, +		} else {, +			return imports;, +		}, +	}, +, +++ b/jadx-samples/src/main/java/jadx/samples/TestImports2.java, +package jadx.samples;, +, +import jadx.samples.otherpkg.C.E;, +import jadx.samples.otherpkg.D;, +, +public class TestImports2 extends AbstractTest {, +, +	public Object f1() {, +		return new E() {, +			@Override, +			public String toString() {, +				return "C.E";, +			}, +		};, +	}, +, +	public Object f2() {, +		return new D.E() {, +			@Override, +			public String toString() {, +				return "D.E";, +			}, +		};, +	}, +, +	public static class X1 extends E {, +	}, +, +	public static class X2 extends D.E {, +	}, +, +	@Override, +	public boolean testRun() {, +		return true;, +	}, +, +	public static void main(String[] args) {, +		new TestImports2().testRun();, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			for (ClassInfo importCls : getImports()) {, +					if (classInfo.isInner()) {, +						String parent = useClassInternal(useCls, classInfo.getParentClass());, +						return parent + "." + shortName;, +					} else {, +			}, +	private Set<ClassInfo> getImports() {, +		if (parentGen != null) {, +			return parentGen.getImports();, +		} else {, +			return imports;, +		}, +	}, +, +++ b/jadx-samples/src/main/java/jadx/samples/TestImports2.java, +package jadx.samples;, +, +import jadx.samples.otherpkg.C.E;, +import jadx.samples.otherpkg.D;, +, +public class TestImports2 extends AbstractTest {, +, +	public Object f1() {, +		return new E() {, +			@Override, +			public String toString() {, +				return "C.E";, +			}]
[+++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		setInput(file);, +		inputFiles.clear();, +	private void setInput(File file) throws IOException, DecodeException {, +		inputFiles.clear();, +		inputFiles.add(new InputFile(file));, +	}, +, +++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		setInput(file);, +		inputFiles.clear();, +	private void setInput(File file) throws IOException, DecodeException {, +		inputFiles.clear();, +		inputFiles.add(new InputFile(file));, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (!file.exists()) {, +			throw new IOException("File not found: " + file.getAbsolutePath());, +		}, +++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		setInput(file);, +		inputFiles.clear();, +	private void setInput(File file) throws IOException, DecodeException {, +		inputFiles.clear();, +		inputFiles.add(new InputFile(file));, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (!file.exists()) {, +			throw new IOException("File not found: " + file.getAbsolutePath());, +		}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import javax.swing.SwingUtilities;, +import javax.swing.UIManager;, +++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		setInput(file);, +		inputFiles.clear();, +	private void setInput(File file) throws IOException, DecodeException {, +		inputFiles.clear();, +		inputFiles.add(new InputFile(file));, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (!file.exists()) {, +			throw new IOException("File not found: " + file.getAbsolutePath());, +		}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import javax.swing.SwingUtilities;, +import javax.swing.UIManager;, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.IJadxArgs;, +	private File openFile;, +		this.openFile = file;, +	public File getOpenFile() {, +		return openFile;, +	}, +++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		setInput(file);, +		inputFiles.clear();, +	private void setInput(File file) throws IOException, DecodeException {, +		inputFiles.clear();, +		inputFiles.add(new InputFile(file));, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback();, +				code.add("PHI(").add(String.valueOf(insn.getArgsCount())).add(")");, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback();, +				code.add("PHI(").add(String.valueOf(insn.getArgsCount())).add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Map;, +		for (Map.Entry<ExceptionHandler, IContainer> entry : region.getCatchRegions().entrySet()) {, +			ExceptionHandler handler = entry.getKey();, +			if (handler.isCatchAll()) {, +			} else {, +				makeCatchBlock(code, handler);, +		IContainer finallyRegion = region.getFinallyRegion();, +		if (finallyRegion != null) {, +			makeRegionIndent(code, finallyRegion);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback();, +				code.add("PHI(").add(String.valueOf(insn.getArgsCount())).add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Map;, +		for (Map.Entry<ExceptionHandler, IContainer> entry : region.getCatchRegions().entrySet()) {, +			ExceptionHandler handler = entry.getKey();, +			if (handler.isCatchAll()) {, +			} else {, +				makeCatchBlock(code, handler);, +		IContainer finallyRegion = region.getFinallyRegion();, +		if (finallyRegion != null) {, +			makeRegionIndent(code, finallyRegion);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ORIG_RETURN,, +	REMOVE,, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +]
[+++ /dev/null]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +					LOG.debug("Selected Font: {}", font);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +					LOG.debug("Selected Font: {}", font);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java, +	private static final Map<?, ?> DESKTOP_HINTS = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");, +		applyRenderHints(g);, +	private void applyRenderHints(Graphics g) {, +		if (g instanceof Graphics2D) {, +			Graphics2D g2d = (Graphics2D) g;, +			if (DESKTOP_HINTS != null) {, +				g2d.setRenderingHints(DESKTOP_HINTS);, +			} else {, +				g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);, +				g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);, +				g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);, +			}, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +			LOG.debug("Stop processing blocks after 'if': {}, method: {}", info, mth);, +		if (badElse) {, +		} else if (badThen) {, +			info = new IfInfo(info.getCondition(), elseBlock, null);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +			LOG.debug("Stop processing blocks after 'if': {}, method: {}", info, mth);, +		if (badElse) {, +		} else if (badThen) {, +			info = new IfInfo(info.getCondition(), elseBlock, null);, +++ b/jadx-core/src/test/java/jadx/tests/internal/others/TestIfInTry.java, +package jadx.tests.internal.others;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.io.File;, +import java.io.IOException;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static jadx.tests.utils.JadxMatchers.countString;, +import static org.junit.Assert.assertThat;, +, +public class TestIfInTry extends InternalJadxTest {, +, +	public static class TestCls {, +		private File dir;, +, +		public int test() {, +			try {, +				int a = f();, +				if (a != 0) {, +					return a;, +				}, +			} catch (Exception e) {, +				// skip, +			}, +			try {, +				f();, +				return 1;, +			} catch (IOException e) {, +				return -1;, +			}, +		}, +, +		private int f() throws IOException {, +			return 0;, +		}, +	}, +, +	@Test, +	public void test() {, +		setOutputCFG();, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsOne("if (a != 0) {"));, +		assertThat(code, containsOne("} catch (Exception e) {"));, +		assertThat(code, countString(2, "try {"));, +		assertThat(code, countString(3, "f()"));, +		assertThat(code, containsOne("return 1;"));, +		assertThat(code, containsOne("} catch (IOException e"));, +		assertThat(code, containsOne("return -1;"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		Set<BlockNode> cacheSet = new HashSet<BlockNode>();, +			BlockNode insnBlock = BlockUtils.getBlockByInsn(mth, exitInsn);, +			if (insnBlock != null) {, +				insnBlock.add(AFlag.SKIP);, +			}, +			exitInsn.add(AFlag.SKIP);, +		BlockNode exit = null;, +		} else if (exits.size() > 1) {, +		if (exit != null) {, +		} else {, +			for (BlockNode exitBlock : exits) {, +				// don't add exit blocks which leads to method end blocks ('return', 'throw', etc), +				List<BlockNode> list = BlockUtils.buildSimplePath(exitBlock);, +				if (list.isEmpty() || !list.get(list.size() - 1).getSuccessors().isEmpty()) {, +					stack.addExit(exitBlock);, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		Set<BlockNode> cacheSet = new HashSet<BlockNode>();, +			BlockNode insnBlock = BlockUtils.getBlockByInsn(mth, exitInsn);, +			if (insnBlock != null) {, +				insnBlock.add(AFlag.SKIP);, +			}, +			exitInsn.add(AFlag.SKIP);, +		BlockNode exit = null;, +		} else if (exits.size() > 1) {, +		if (exit != null) {, +		} else {, +			for (BlockNode exitBlock : exits) {, +				// don't add exit blocks which leads to method end blocks ('return', 'throw', etc), +				List<BlockNode> list = BlockUtils.buildSimplePath(exitBlock);, +				if (list.isEmpty() || !list.get(list.size() - 1).getSuccessors().isEmpty()) {, +					stack.addExit(exitBlock);, +				}, +			}, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/synchronize/TestSynchronized3.java, +package jadx.tests.integration.synchronize;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsLines;, +import static org.junit.Assert.assertThat;, +, +public class TestSynchronized3 extends IntegrationTest {, +, +	public static class TestCls {, +		private int x;, +, +		public void f() {, +		}, +, +		public void test() {, +			while (true) {, +				synchronized (this) {, +					if (x == 0) {, +						throw new IllegalStateException("bad luck");, +					}, +					x++;, +					if (x == 10) {, +						break;, +					}, +				}, +				this.x++;, +				f();, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsLines(3, "}", "this.x++;", "f();"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}, +		if (finallyRegion != null) {, +			sb.append(" finally: ").append(finallyRegion);, +		}, +		return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}, +		if (finallyRegion != null) {, +			sb.append(" finally: ").append(finallyRegion);, +		}, +		return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +		if (handlerAttr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}, +		if (finallyRegion != null) {, +			sb.append(" finally: ").append(finallyRegion);, +		}, +		return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +		if (handlerAttr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.trycatch.ExcHandlerAttr;, +import jadx.core.dex.trycatch.SplitterBlockAttr;, +import jadx.core.utils.BlockUtils;, +import java.util.HashMap;, +import java.util.Map;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(BlockFinish.class);, +, +			fixSplitterBlock(block);, +, +	/**, +	 * For evey exception handler must be only one splitter block,, +	 * select correct one and remove others if necessary., +	 */, +	private static void fixSplitterBlock(BlockNode block) {, +		ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);, +		if (excHandlerAttr == null) {, +			return;, +		}, +		BlockNode handlerBlock = excHandlerAttr.getHandler().getHandlerBlock();, +		if (handlerBlock.getPredecessors().size() < 2) {, +			return;, +		}, +		Map<BlockNode, SplitterBlockAttr> splitters = new HashMap<BlockNode, SplitterBlockAttr>();, +		for (BlockNode pred : handlerBlock.getPredecessors()) {, +			pred = BlockUtils.skipSyntheticPredecessor(pred);, +			SplitterBlockAttr splitterAttr = pred.get(AType.SPLITTER_BLOCK);, +			if (splitterAttr != null && pred == splitterAttr.getBlock()) {, +				splitters.put(pred, splitterAttr);, +			}, +		}, +		if (splitters.size() < 2) {, +			return;, +		}, +		BlockNode topSplitter = BlockUtils.getTopBlock(splitters.keySet());, +		if (topSplitter == null) {, +			LOG.warn("Unknown top splitter block from list: {}", splitters);, +			return;, +		}, +		for (Map.Entry<BlockNode, SplitterBlockAttr> entry : splitters.entrySet()) {, +			BlockNode pred = entry.getKey();, +			SplitterBlockAttr splitterAttr = entry.getValue();, +			if (pred == topSplitter) {, +				block.addAttr(splitterAttr);, +			} else {, +				pred.remove(AType.SPLITTER_BLOCK);, +				for (BlockNode s : pred.getCleanSuccessors()) {, +					s.remove(AType.SPLITTER_BLOCK);, +				}, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected void useType(CodeWriter code, ArgType type) {, +				if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, +		if (insn.contains(AFlag.ARITH_ONEARG)) {, +			makeArithOneArg(insn, code);, +			return;, +		}, +		InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected void useType(CodeWriter code, ArgType type) {, +				if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, +		if (insn.contains(AFlag.ARITH_ONEARG)) {, +			makeArithOneArg(insn, code);, +			return;, +		}, +		InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForEachLoop;, +			if (type instanceof ForEachLoop) {, +				ForEachLoop forEachLoop = (ForEachLoop) type;, +				code.startLine("for (");, +				declareVar(code, forEachLoop.getVarArg());, +				code.add(" : ");, +				addArg(code, forEachLoop.getIterableArg(), false);, +				code.add(") {");, +				makeRegionIndent(code, region.getBody());, +				code.startLine('}');, +				return code;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected void useType(CodeWriter code, ArgType type) {, +				if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, +		if (insn.contains(AFlag.ARITH_ONEARG)) {, +			makeArithOneArg(insn, code);, +			return;, +		}, +		InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForEachLoop;, +			if (type instanceof ForEachLoop) {, +				ForEachLoop forEachLoop = (ForEachLoop) type;, +				code.startLine("for (");, +				declareVar(code, forEachLoop.getVarArg());, +				code.add(" : ");, +				addArg(code, forEachLoop.getIterableArg(), false);, +				code.add(") {");, +				makeRegionIndent(code, region.getBody());, +				code.startLine('}');, +				return code;, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ARITH_ONEARG,, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected void useType(CodeWriter code, ArgType type) {, +				if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, +		if (insn.contains(AFlag.ARITH_ONEARG)) {, +			makeArithOneArg(insn, code);, +			return;, +		}, +		InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForEachLoop;, +			if (type instanceof ForEachLoop) {, +				ForEachLoop forEachLoop = (ForEachLoop) type;, +				code.startLine("for (");, +				declareVar(code, forEachLoop.getVarArg());, +				code.add(" : ");, +				addArg(code, forEachLoop.getIterableArg(), false);, +				code.add(") {");, +				makeRegionIndent(code, region.getBody());, +				code.startLine('}');, +				return code;, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	ARITH_ONEARG,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +import jadx.core.dex.attributes.AFlag;, +		this(op, res, res, a);, +		add(AFlag.ARITH_ONEARG);, +				+ getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected void useType(CodeWriter code, ArgType type) {, +				if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, +		if (insn.contains(AFlag.ARITH_ONEARG)) {, +			makeArithOneArg(insn, code);, +			return;, +		}, +		InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForEachLoop;, +			if (type instanceof ForEachLoop) {, +				ForEachLoop forEachLoop = (ForEachLoop) type;, +				code.startLine("for (");, +				declareVar(code, forEachLoop.getVarArg());, +				code.add(" : ");, +				addArg(code, forEachLoop.getIterableArg(), false);, +				code.add(") {");, +				makeRegionIndent(code, region.getBody());, +				code.startLine('}');, +				return code;]
[+++ b/.gitlab-ci.yml, +  - test, +  - check, +java-8:, +  stage: test, +  image: openjdk:8, +  script: ./gradlew clean build, +, +java-11:, +  stage: test, +  image: openjdk:11, +  script: ./gradlew clean build, +, +check:, +  stage: check, +  image: openjdk:8, +    - export JADX_LAST_TAG="$(git describe --abbrev=0 --tags)", +    - export JADX_VERSION="${JADX_LAST_TAG:1}-dev-$(git rev-parse --short HEAD)", +    - ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN -Dsonar.branch.name=dev, +    - ./gradlew clean dist]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		ArgType origType = callMth.getArguments(false).get(origPos).getInitType();, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +				if (fieldsCls != null && parentClass.equals(fieldsCls.getClassInfo())) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		if (aList == null || aList.isEmpty()) {, +		if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		if (aList == null || aList.isEmpty()) {, +		if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (!cls.getInterfaces().isEmpty() && !af.isAnnotation()) {, +			if (!f.getArgs().isEmpty()) {, +		ArgType[] generics = classInfo.getType().getGenericTypes();, +			if (searchCollision(cls.dex(), useCls, classInfo)) {, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, ClassInfo searchCls) {, +		String shortName = searchCls.getShortName();, +				if (inner.getShortName().equals(shortName), +						&& !inner.getClassInfo().equals(searchCls)) {, +		return searchCollision(dex, useCls.getParentClass(), searchCls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		if (aList == null || aList.isEmpty()) {, +		if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (!cls.getInterfaces().isEmpty() && !af.isAnnotation()) {, +			if (!f.getArgs().isEmpty()) {, +		ArgType[] generics = classInfo.getType().getGenericTypes();, +			if (searchCollision(cls.dex(), useCls, classInfo)) {, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, ClassInfo searchCls) {, +		String shortName = searchCls.getShortName();, +				if (inner.getShortName().equals(shortName), +						&& !inner.getClassInfo().equals(searchCls)) {, +		return searchCollision(dex, useCls.getParentClass(), searchCls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Set;, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			Set<Flags> state = EnumSet.noneOf(Flags.class);, +	private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) throws CodegenException {, +	private void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) throws CodegenException {, +	private void makeArith(ArithNode insn, CodeWriter code, Set<Flags> state) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		if (aList == null || aList.isEmpty()) {, +		if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (!cls.getInterfaces().isEmpty() && !af.isAnnotation()) {, +			if (!f.getArgs().isEmpty()) {, +		ArgType[] generics = classInfo.getType().getGenericTypes();, +			if (searchCollision(cls.dex(), useCls, classInfo)) {, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, ClassInfo searchCls) {, +		String shortName = searchCls.getShortName();, +				if (inner.getShortName().equals(shortName), +						&& !inner.getClassInfo().equals(searchCls)) {, +		return searchCollision(dex, useCls.getParentClass(), searchCls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Set;, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			Set<Flags> state = EnumSet.noneOf(Flags.class);, +	private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) throws CodegenException {, +	private void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) throws CodegenException {, +	private void makeArith(ArithNode insn, CodeWriter code, Set<Flags> state) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			if (addLabels && (insn.contains(AType.JUMP) || insn.contains(AType.EXC_HANDLER))) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		if (aList == null || aList.isEmpty()) {, +		if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (!cls.getInterfaces().isEmpty() && !af.isAnnotation()) {, +			if (!f.getArgs().isEmpty()) {, +		ArgType[] generics = classInfo.getType().getGenericTypes();, +			if (searchCollision(cls.dex(), useCls, classInfo)) {, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, ClassInfo searchCls) {, +		String shortName = searchCls.getShortName();, +				if (inner.getShortName().equals(shortName), +						&& !inner.getClassInfo().equals(searchCls)) {, +		return searchCollision(dex, useCls.getParentClass(), searchCls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Set;, +		while (fieldNode == null, +				&& pCls.getParentClass() != pCls, +				&& pCls.getParentClass() != null) {, +			Set<Flags> state = EnumSet.noneOf(Flags.class);, +	private void makeInsnBody(CodeWriter code, InsnNode insn, Set<Flags> state) throws CodegenException {, +	private void makeTernary(TernaryInsn insn, CodeWriter code, Set<Flags> state) throws CodegenException {, +	private void makeArith(ArithNode insn, CodeWriter code, Set<Flags> state) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			if (addLabels && (insn.contains(AType.JUMP) || insn.contains(AType.EXC_HANDLER))) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +	private TypeGen() {, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		if (aList == null || aList.isEmpty()) {, +		if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (!cls.getInterfaces().isEmpty() && !af.isAnnotation()) {, +			if (!f.getArgs().isEmpty()) {, +		ArgType[] generics = classInfo.getType().getGenericTypes();, +			if (searchCollision(cls.dex(), useCls, classInfo)) {, +	private static boolean searchCollision(DexNode dex, ClassInfo useCls, ClassInfo searchCls) {, +		String shortName = searchCls.getShortName();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +	private DecodedInstruction[] insnArr;, +	public InsnDecoder(MethodNode mthNode) throws DecodeException {, +	public void decodeInsns(Code mthCode) throws DecodeException {, +		short[] encodedInstructions = mthCode.getInstructions();, +		int size = encodedInstructions.length;, +		DecodedInstruction[] decoded = new DecodedInstruction[size];, +		ShortArrayCodeInput in = new ShortArrayCodeInput(encodedInstructions);, +		try {, +			while (in.hasMore()) {, +				decoded[in.cursor()] = DecodedInstruction.decode(in);, +			}, +		} catch (EOFException e) {, +			throw new DecodeException(method, "", e);, +		}, +		insnArr = decoded;, +	}, +, +	public InsnNode[] process() throws DecodeException {, +		InsnNode[] instructions = new InsnNode[insnArr.length];, +		insnArr = null;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +	private DecodedInstruction[] insnArr;, +	public InsnDecoder(MethodNode mthNode) throws DecodeException {, +	public void decodeInsns(Code mthCode) throws DecodeException {, +		short[] encodedInstructions = mthCode.getInstructions();, +		int size = encodedInstructions.length;, +		DecodedInstruction[] decoded = new DecodedInstruction[size];, +		ShortArrayCodeInput in = new ShortArrayCodeInput(encodedInstructions);, +		try {, +			while (in.hasMore()) {, +				decoded[in.cursor()] = DecodedInstruction.decode(in);, +			}, +		} catch (EOFException e) {, +			throw new DecodeException(method, "", e);, +		}, +		insnArr = decoded;, +	}, +, +	public InsnNode[] process() throws DecodeException {, +		InsnNode[] instructions = new InsnNode[insnArr.length];, +		insnArr = null;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +				if (arg != this && "this".equals(arg.getTypedVar().getName())) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +	private DecodedInstruction[] insnArr;, +	public InsnDecoder(MethodNode mthNode) throws DecodeException {, +	public void decodeInsns(Code mthCode) throws DecodeException {, +		short[] encodedInstructions = mthCode.getInstructions();, +		int size = encodedInstructions.length;, +		DecodedInstruction[] decoded = new DecodedInstruction[size];, +		ShortArrayCodeInput in = new ShortArrayCodeInput(encodedInstructions);, +		try {, +			while (in.hasMore()) {, +				decoded[in.cursor()] = DecodedInstruction.decode(in);, +			}, +		} catch (EOFException e) {, +			throw new DecodeException(method, "", e);, +		}, +		insnArr = decoded;, +	}, +, +	public InsnNode[] process() throws DecodeException {, +		InsnNode[] instructions = new InsnNode[insnArr.length];, +		insnArr = null;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +				if (arg != this && "this".equals(arg.getTypedVar().getName())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.attributes.JadxErrorAttr;, +			try {, +			} catch (DecodeException e) {, +				LOG.error("Method load error", e);, +				mth.getAttributes().add(new JadxErrorAttr(e));, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +	private DecodedInstruction[] insnArr;, +	public InsnDecoder(MethodNode mthNode) throws DecodeException {, +	public void decodeInsns(Code mthCode) throws DecodeException {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getLoopsCount() {, +		return loops.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getLoopsCount() {, +		return loops.size();, +	}, +, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getLoopsCount() {, +		return loops.size();, +	}, +, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getLoopsCount() {, +		return loops.size();, +	}, +, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/PostRegionVisitor.java, +		IContainer startRegion = mth.getRegion();, +		if (mth.isNoCode() || startRegion == null) {, +		DepthRegionTraverser.traverse(mth, new ProcessTryCatchRegions(mth), startRegion);, +		if (mth.getLoopsCount() != 0) {, +			DepthRegionTraverser.traverse(mth, new ProcessLoopRegions(), startRegion);, +		if (mth.getReturnType().equals(ArgType.VOID)) {, +			DepthRegionTraverser.traverseAll(mth, new ProcessReturnInsns());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getLoopsCount() {, +		return loops.size();, +	}, +, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/PostRegionVisitor.java, +		IContainer startRegion = mth.getRegion();, +		if (mth.isNoCode() || startRegion == null) {, +		DepthRegionTraverser.traverse(mth, new ProcessTryCatchRegions(mth), startRegion);, +		if (mth.getLoopsCount() != 0) {, +			DepthRegionTraverser.traverse(mth, new ProcessLoopRegions(), startRegion);, +		if (mth.getReturnType().equals(ArgType.VOID)) {, +			DepthRegionTraverser.traverseAll(mth, new ProcessReturnInsns());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessLoopRegions.java, +package jadx.core.dex.visitors.regions;, +, +import jadx.core.dex.nodes.IRegion;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.regions.LoopRegion;, +, +public class ProcessLoopRegions extends AbstractRegionVisitor {, +, +	@Override, +	public void enterRegion(MethodNode mth, IRegion region) {, +		if (region instanceof LoopRegion) {, +			LoopRegion loop = (LoopRegion) region;, +			loop.mergePreCondition();, +		}, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getLoopsCount() {, +		return loops.size();, +	}, +, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/PostRegionVisitor.java, +		IContainer startRegion = mth.getRegion();, +		if (mth.isNoCode() || startRegion == null) {, +		DepthRegionTraverser.traverse(mth, new ProcessTryCatchRegions(mth), startRegion);, +		if (mth.getLoopsCount() != 0) {, +			DepthRegionTraverser.traverse(mth, new ProcessLoopRegions(), startRegion);, +		if (mth.getReturnType().equals(ArgType.VOID)) {, +			DepthRegionTraverser.traverseAll(mth, new ProcessReturnInsns());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessLoopRegions.java, +package jadx.core.dex.visitors.regions;, +, +import jadx.core.dex.nodes.IRegion;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.regions.LoopRegion;, +, +public class ProcessLoopRegions extends AbstractRegionVisitor {, +, +	@Override, +	public void enterRegion(MethodNode mth, IRegion region) {, +		if (region instanceof LoopRegion) {, +			LoopRegion loop = (LoopRegion) region;, +			loop.mergePreCondition();, +		}, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessReturnInsns.java, +package jadx.core.dex.visitors.regions;, +]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, +			description = "disables use of imports, always writes entire package name"), +	protected boolean useImports = true;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, +			description = "disables use of imports, always writes entire package name"), +	protected boolean useImports = true;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	, +	boolean isUsingImports();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, +			description = "disables use of imports, always writes entire package name"), +	protected boolean useImports = true;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	, +	boolean isUsingImports();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean useImports = false;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	public void setUseImports(boolean useImports) {, +		this.useImports = useImports;, +	}, +, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, +			description = "disables use of imports, always writes entire package name"), +	protected boolean useImports = true;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	, +	boolean isUsingImports();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean useImports = false;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	public void setUseImports(boolean useImports) {, +		this.useImports = useImports;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean useImports;, +		this(cls, null, jadxArgs.isUsingImports(), jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +		this(cls, parentClsGen, parentClsGen.useImports, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean useImports, boolean fallback, boolean showBadCode) {, +		this.useImports = useImports;, +		if (fallback || !useImports) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, +			description = "disables use of imports, always writes entire package name"), +	protected boolean useImports = true;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	, +	boolean isUsingImports();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean useImports = false;, +, +	public boolean isUsingImports() {, +		return useImports;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, +			// skip synthetic loop exit blocks, +			BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, +			// skip synthetic loop exit blocks, +			BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static boolean isBlockMustBeCleared(BlockNode b) {, +		if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.SKIP)) {, +			return true;, +		}, +		if (b.contains(AFlag.SYNTHETIC)) {, +			List<BlockNode> s = b.getSuccessors();, +			if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove exception handlers from block nodes list, +	 */, +			if (!isBlockMustBeCleared(block)) {, +	 * Remove exception handlers from block nodes bitset, +	 */, +	public static void cleanBitSet(MethodNode mth, BitSet bs) {, +		for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {, +			BlockNode block = mth.getBasicBlocks().get(i);, +			if (isBlockMustBeCleared(block)) {, +				bs.clear(i);, +			}, +		}, +	}, +, +	/**, +	 * Set 'SKIP' flag for all synthetic predecessors from start block., +	 */, +	public static void skipPredSyntheticPaths(BlockNode block) {, +		for (BlockNode pred : block.getPredecessors()) {, +			if (pred.contains(AFlag.SYNTHETIC), +					&& !pred.contains(AType.SPLITTER_BLOCK), +					&& pred.getInstructions().isEmpty()) {, +				pred.add(AFlag.SKIP);, +				skipPredSyntheticPaths(pred);, +			}, +		}, +	}, +, +	/**, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, +			// skip synthetic loop exit blocks, +			BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static boolean isBlockMustBeCleared(BlockNode b) {, +		if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.SKIP)) {, +			return true;, +		}, +		if (b.contains(AFlag.SYNTHETIC)) {, +			List<BlockNode> s = b.getSuccessors();, +			if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove exception handlers from block nodes list, +	 */, +			if (!isBlockMustBeCleared(block)) {, +	 * Remove exception handlers from block nodes bitset, +	 */, +	public static void cleanBitSet(MethodNode mth, BitSet bs) {, +		for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {, +			BlockNode block = mth.getBasicBlocks().get(i);, +			if (isBlockMustBeCleared(block)) {, +				bs.clear(i);, +			}, +		}, +	}, +, +	/**, +	 * Set 'SKIP' flag for all synthetic predecessors from start block., +	 */]
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +		if (codeGen == null && cls.getState() == PROCESSED) {, +			return;, +		}, +					processDependencies(cls, passes);]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/PackageNode.java, +, +			if (pp.size() > 0) {, +			} else {, +				result.append(this.getAlias());, +			}]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +		appResClass = AndroidResourcesUtils.searchAppResClass(this, resStorage);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +		appResClass = AndroidResourcesUtils.searchAppResClass(this, resStorage);, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.LinkedList;, +import java.util.Map;, +import java.util.Set;, +import jadx.core.xmlgen.ResourceStorage;, +import jadx.core.xmlgen.entry.ResourceEntry;, +	public static ClassNode searchAppResClass(RootNode root, ResourceStorage resStorage) {, +		return makeClass(root, fullName, resStorage);, +	private static ClassNode makeClass(RootNode root, String clsName, ResourceStorage resStorage) {, +		ClassNode classNode = new ClassNode(dexNodes.get(0), r);, +		generateMissingRCode(classNode, resStorage);, +		return classNode;, +	}, +	, +	private static void generateMissingRCode(ClassNode cls, ResourceStorage resStorage) {, +		Map<String, List<ResourceEntry>> sortedMap = new HashMap<>();, +		for(ResourceEntry ri : resStorage.getResources()) {, +			List<ResourceEntry> entries = sortedMap.get(ri.getTypeName());, +			if(entries == null) {, +				entries = new LinkedList<>();, +				sortedMap.put(ri.getTypeName(), entries);, +			}, +			entries.add(ri);, +		}, +		, +		Set<String> addedValues = new HashSet<>();, +		CodeWriter clsCode = new CodeWriter();, +		if (!"".equals(cls.getPackage())) {, +			clsCode.add("package ").add(cls.getPackage()).add(';').newLine();, +		}, +		clsCode.startLine("public final class ").add(cls.getShortName()).add(" {").incIndent();, +		for(String typeName : sortedMap.keySet()) {, +			clsCode.startLine("public static final class ").add(typeName).add(" {").incIndent();, +			for(ResourceEntry ri : sortedMap.get(typeName)) {, +				if(addedValues.add(ri.getTypeName() + "." + ri.getKeyName())) {, +					clsCode.startLine("public static final int ").add(ri.getKeyName()).add(" = "), +						.add("" + ri.getId()).add(";");, +				}, +			}, +			clsCode.decIndent();, +			clsCode.add("}");, +		}, +		clsCode.decIndent();, +		clsCode.add("}");, +		, +		cls.setCode(clsCode);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (elType == null) {, +				throw new JadxRuntimeException("Null array element type");, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (elType == null) {, +				throw new JadxRuntimeException("Null array element type");, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable("Null for method arguments"), +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (elType == null) {, +				throw new JadxRuntimeException("Null array element type");, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable("Null for method arguments"), +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +		if (lit == 0 && checkObjectInline(sVar)) {, +				InsnNode assignInsn = insn.getResult().getAssignInsn();, +				if (assignInsn != null) {, +					assignInsn.add(AFlag.DONT_INLINE);, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (elType == null) {, +				throw new JadxRuntimeException("Null array element type");, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable("Null for method arguments"), +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +		if (lit == 0 && checkObjectInline(sVar)) {, +				InsnNode assignInsn = insn.getResult().getAssignInsn();, +				if (assignInsn != null) {, +					assignInsn.add(AFlag.DONT_INLINE);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +		IgnoreEdgeAttr edgeAttr = pred.get(AType.IGNORE_EDGE);, +		if (edgeAttr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (elType == null) {, +				throw new JadxRuntimeException("Null array element type");, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable("Null for method arguments"), +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +		if (lit == 0 && checkObjectInline(sVar)) {, +				InsnNode assignInsn = insn.getResult().getAssignInsn();, +				if (assignInsn != null) {, +					assignInsn.add(AFlag.DONT_INLINE);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +		IgnoreEdgeAttr edgeAttr = pred.get(AType.IGNORE_EDGE);, +		if (edgeAttr == null) {, +			return;, +		}, +++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java, +			Reader reader = new InputStreamReader(con.getInputStream(), "UTF-8");]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.utils.exceptions.DecodeException;, +	public JadxDecompiler() {, +	public JadxDecompiler(IJadxArgs jadxArgs) {, +	public void setOutputDir(File outDir) {, +	void init() {, +			sourcesOutDir = outDir;, +			resOutDir = outDir;, +	void parse() throws DecodeException {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.utils.exceptions.DecodeException;, +	public JadxDecompiler() {, +	public JadxDecompiler(IJadxArgs jadxArgs) {, +	public void setOutputDir(File outDir) {, +	void init() {, +			sourcesOutDir = outDir;, +			resOutDir = outDir;, +	void parse() throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +			return attr.getValues().get(value);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.utils.exceptions.DecodeException;, +	public JadxDecompiler() {, +	public JadxDecompiler(IJadxArgs jadxArgs) {, +	public void setOutputDir(File outDir) {, +	void init() {, +			sourcesOutDir = outDir;, +			resOutDir = outDir;, +	void parse() throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +			return attr.getValues().get(value);, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		JadxDecompiler d = new JadxDecompiler(args);]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, +					MainWindow window = new MainWindow(wrapper);, +					window.pack();, +					window.setLocationAndPosition();, +					window.setVisible(true);, +					window.setLocationRelativeTo(null);, +					window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +						window.openFile();, +						window.openFile(jadxArgs.getInput().get(0));, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, +					MainWindow window = new MainWindow(wrapper);, +					window.pack();, +					window.setLocationAndPosition();, +					window.setVisible(true);, +					window.setLocationRelativeTo(null);, +					window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +						window.openFile();, +						window.openFile(jadxArgs.getInput().get(0));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, +					MainWindow window = new MainWindow(wrapper);, +					window.pack();, +					window.setLocationAndPosition();, +					window.setVisible(true);, +					window.setLocationRelativeTo(null);, +					window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +						window.openFile();, +						window.openFile(jadxArgs.getInput().get(0));, +++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, +					MainWindow window = new MainWindow(wrapper);, +					window.pack();, +					window.setLocationAndPosition();, +					window.setVisible(true);, +					window.setLocationRelativeTo(null);, +					window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +						window.openFile();, +						window.openFile(jadxArgs.getInput().get(0));, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, +					MainWindow window = new MainWindow(wrapper);, +					window.pack();, +					window.setLocationAndPosition();, +					window.setVisible(true);, +					window.setLocationRelativeTo(null);, +					window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +						window.openFile();, +						window.openFile(jadxArgs.getInput().get(0));, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CodeArea.java, +package jadx.gui.ui;, +, +import jadx.api.CodePosition;, +import jadx.gui.treemodel.JClass;, +, +import javax.swing.JViewport;, +import javax.swing.SwingUtilities;, +import javax.swing.event.HyperlinkEvent;, +import javax.swing.event.HyperlinkListener;, +import javax.swing.text.BadLocationException;, +import javax.swing.text.Caret;, +import javax.swing.text.DefaultCaret;, +import java.awt.Color;, +import java.awt.Point;, +import java.awt.Rectangle;, +, +import org.fife.ui.rsyntaxtextarea.LinkGenerator;, +import org.fife.ui.rsyntaxtextarea.LinkGeneratorResult;, +import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +import org.fife.ui.rsyntaxtextarea.SyntaxScheme;, +import org.fife.ui.rsyntaxtextarea.Token;, +import org.fife.ui.rsyntaxtextarea.TokenTypes;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +class CodeArea extends RSyntaxTextArea {, +	private static final Logger LOG = LoggerFactory.getLogger(CodeArea.class);, +, +	private static final long serialVersionUID = 6312736869579635796L;, +, +	private static final Color BACKGROUND = new Color(0xf7f7f7);, +	private static final Color JUMP_FOREGROUND = new Color(0x785523);, +	private static final Color JUMP_BACKGROUND = new Color(0xE6E6FF);, +, +	private final CodePanel codePanel;, +	private final JClass cls;, +, +	CodeArea(CodePanel panel) {, +		this.codePanel = panel;]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AFlag;, +			if (field.contains(AFlag.DONT_RENAME)), +			    continue;, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AFlag;, +			if (field.contains(AFlag.DONT_RENAME)), +			    continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	DONT_RENAME, // do not rename during deobfuscation, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AFlag;, +			if (field.contains(AFlag.DONT_RENAME)), +			    continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	DONT_RENAME, // do not rename during deobfuscation, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +import jadx.core.dex.attributes.AFlag;, +				fieldNode.add(AFlag.DONT_RENAME);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private int clsDeclLine;, +			af = af.remove(AccessFlags.ACC_FINAL), +					.remove(AccessFlags.ACC_ABSTRACT), +					.remove(AccessFlags.ACC_STATIC);, +			if (innerCls.contains(AFlag.DONT_GENERATE), +					|| innerCls.isAnonymous()) {, +				continue;, +			}, +, +	private boolean isInnerClassesPresents() {, +		for (ClassNode innerCls : cls.getInnerClasses()) {, +			if (!innerCls.isAnonymous()) {, +				return true;, +			}, +		}, +		return false;, +			if (mth.contains(AFlag.DONT_GENERATE)) {, +				continue;, +			}, +			try {, +, +	private boolean isMethodsPresents() {, +		for (MethodNode mth : cls.getMethods()) {, +			if (!mth.contains(AFlag.DONT_GENERATE)) {, +				return true;, +			}, +		}, +		return false;, +	private boolean isFieldsPresents() {, +		for (FieldNode field : cls.getFields()) {, +			if (!field.contains(AFlag.DONT_GENERATE)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +				code.add(' ');, +		if (isMethodsPresents() || isFieldsPresents() || isInnerClassesPresents()) {, +		}, +		PrimitiveType stype = type.getPrimitiveType();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private int clsDeclLine;, +			af = af.remove(AccessFlags.ACC_FINAL), +					.remove(AccessFlags.ACC_ABSTRACT), +					.remove(AccessFlags.ACC_STATIC);, +			if (innerCls.contains(AFlag.DONT_GENERATE), +					|| innerCls.isAnonymous()) {, +				continue;, +			}, +, +	private boolean isInnerClassesPresents() {, +		for (ClassNode innerCls : cls.getInnerClasses()) {, +			if (!innerCls.isAnonymous()) {, +				return true;, +			}, +		}, +		return false;, +			if (mth.contains(AFlag.DONT_GENERATE)) {, +				continue;, +			}, +			try {, +, +	private boolean isMethodsPresents() {, +		for (MethodNode mth : cls.getMethods()) {, +			if (!mth.contains(AFlag.DONT_GENERATE)) {, +				return true;, +			}, +		}, +		return false;, +	private boolean isFieldsPresents() {, +		for (FieldNode field : cls.getFields()) {, +			if (!field.contains(AFlag.DONT_GENERATE)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +				code.add(' ');, +		if (isMethodsPresents() || isFieldsPresents() || isInnerClassesPresents()) {, +		}, +		PrimitiveType stype = type.getPrimitiveType();, +++ b/jadx-core/src/test/java/jadx/tests/internal/enums/TestEnums.java, +package jadx.tests.internal.enums;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsLines;, +import static org.junit.Assert.assertThat;, +, +public class TestEnums extends InternalJadxTest {, +, +	public static class TestCls {, +, +		public enum EmptyEnum {]
[+++ b/README.md, +     --no-replace-consts    - don't replace constant value with matching constant field, +     --escape-unicode       - escape non latin characters in strings (with \u), +     --cfg                  - save methods control flow graph to dot file, +     --raw-cfg              - save methods control flow graph (use raw instructions), + -f, --fallback             - make simple dump (using goto instead of 'if', 'for', etc), + -v, --verbose              - verbose output, +++ b/README.md, +     --no-replace-consts    - don't replace constant value with matching constant field, +     --escape-unicode       - escape non latin characters in strings (with \u), +     --cfg                  - save methods control flow graph to dot file, +     --raw-cfg              - save methods control flow graph (use raw instructions), + -f, --fallback             - make simple dump (using goto instead of 'if', 'for', etc), + -v, --verbose              - verbose output, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import com.beust.jcommander.IStringConverter;, +	@Parameter(names = "--no-replace-consts", converter = InvertedBooleanConverter.class,, +			description = "don't replace constant value with matching constant field"), +	protected boolean replaceConsts = true;, +	@Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), +	protected boolean escapeUnicode = false;, +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph to dot file"), +	protected boolean cfgOutput = false;, +, +	@Parameter(names = {"--raw-cfg"}, description = "save methods control flow graph (use raw instructions)"), +	protected boolean rawCfgOutput = false;, +, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	protected boolean fallbackMode = false;, +, +	@Parameter(names = {"-v", "--verbose"}, description = "verbose output"), +	protected boolean verbose = false;, +	public static class InvertedBooleanConverter implements IStringConverter<Boolean> {, +		@Override, +		public Boolean convert(String value) {, +			return "false".equals(value);, +		}, +	}, +, +, +	@Override, +	public boolean isReplaceConsts() {, +		return replaceConsts;, +	}, +++ b/README.md, +     --no-replace-consts    - don't replace constant value with matching constant field, +     --escape-unicode       - escape non latin characters in strings (with \u), +     --cfg                  - save methods control flow graph to dot file, +     --raw-cfg              - save methods control flow graph (use raw instructions), + -f, --fallback             - make simple dump (using goto instead of 'if', 'for', etc), + -v, --verbose              - verbose output, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import com.beust.jcommander.IStringConverter;, +	@Parameter(names = "--no-replace-consts", converter = InvertedBooleanConverter.class,, +			description = "don't replace constant value with matching constant field"), +	protected boolean replaceConsts = true;, +	@Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), +	protected boolean escapeUnicode = false;, +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph to dot file"), +	protected boolean cfgOutput = false;, +, +	@Parameter(names = {"--raw-cfg"}, description = "save methods control flow graph (use raw instructions)"), +	protected boolean rawCfgOutput = false;, +, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), +	protected boolean fallbackMode = false;, +, +	@Parameter(names = {"-v", "--verbose"}, description = "verbose output"), +	protected boolean verbose = false;, +	public static class InvertedBooleanConverter implements IStringConverter<Boolean> {, +		@Override, +		public Boolean convert(String value) {, +			return "false".equals(value);, +		}, +	}, +, +, +	@Override, +	public boolean isReplaceConsts() {, +		return replaceConsts;, +	}, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +package jadx.cli;, +, +import org.junit.Test;, +, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertThat;, +, +public class JadxCLIArgsTest {, +, +	@Test, +	public void testInvertedBooleanOption() throws Exception {, +		assertThat(parse("--no-replace-consts").isReplaceConsts(), is(false));, +		assertThat(parse("").isReplaceConsts(), is(true));, +	}, +, +	private JadxCLIArgs parse(String... args) {, +		JadxCLIArgs jadxArgs = new JadxCLIArgs();, +		boolean res = jadxArgs.processArgs(args);]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, +	public List<ResourceFile> getResources() {, +		return decompiler.getResources();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, +	public List<ResourceFile> getResources() {, +		return decompiler.getResources();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, +	public String getContent() {, +	public String getSyntaxName() {, +		return SyntaxConstants.SYNTAX_STYLE_JAVA;, +	}, +, +	@Override, +	public Integer getSourceLine(int line) {, +		return cls.getSourceLine(line);, +	}, +, +	@Override, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, +	public List<ResourceFile> getResources() {, +		return decompiler.getResources();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, +	public String getContent() {, +	public String getSyntaxName() {, +		return SyntaxConstants.SYNTAX_STYLE_JAVA;, +	}, +, +	@Override, +	public Integer getSourceLine(int line) {, +		return cls.getSourceLine(line);, +	}, +, +	@Override, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, +	public String getContent() {, +		return null;, +	}, +, +	public String getSyntaxName() {, +		return SyntaxConstants.SYNTAX_STYLE_NONE;, +	}, +, +	public int getLine() {, +		return 0;, +	}, +, +	public Integer getSourceLine(int line) {, +		return null;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, +	public List<ResourceFile> getResources() {, +		return decompiler.getResources();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, +	public String getContent() {, +	public String getSyntaxName() {, +		return SyntaxConstants.SYNTAX_STYLE_JAVA;, +	}, +, +	@Override, +	public Integer getSourceLine(int line) {, +		return cls.getSourceLine(line);, +	}, +, +	@Override, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, +	public String getContent() {, +		return null;, +	}, +, +	public String getSyntaxName() {, +		return SyntaxConstants.SYNTAX_STYLE_NONE;, +	}, +, +	public int getLine() {, +		return 0;, +	}, +, +	public Integer getSourceLine(int line) {]
[+++ b/.codecov.yml, +coverage:, +  precision: 2, +  round: down, +  range: "50...100", +, +  status:, +    project:, +      default: on, +    patch:, +      default: on, +    changes:, +      default: off, +, +comment: false]
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +import java.util.HashMap;, +import org.jetbrains.annotations.NotNull;, +import jadx.core.deobf.NameMapper;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.info.ConstStorage;, +		Map<Integer, FieldNode> resFieldsMap = fillResFieldsMap(resCls);, +			ClassNode typeCls = innerClsMap.computeIfAbsent(, +					resource.getTypeName(),, +					name -> addClassForResType(resCls, rClsExists, name), +			);, +			String resName = resource.getKeyName();, +			FieldNode rField = typeCls.searchFieldByName(resName);, +				FieldInfo rFieldInfo = FieldInfo.from(typeCls.dex(), typeCls.getClassInfo(), resName, ArgType.INT);, +			FieldNode fieldNode = resFieldsMap.get(resource.getId());, +			if (fieldNode != null, +					&& !fieldNode.getName().equals(resName), +					&& NameMapper.isValidIdentifier(resName)) {, +				fieldNode.getFieldInfo().setAlias(resName);, +, +	@NotNull, +	private static ClassNode addClassForResType(ClassNode resCls, boolean rClsExists, String typeName) {, +		ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + "$" + typeName,, +				AccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC | AccessFlags.ACC_FINAL);, +		resCls.addInnerClass(newTypeCls);, +		if (rClsExists) {, +			newTypeCls.addAttr(AType.COMMENTS, "added by JADX");, +		}, +		return newTypeCls;, +	}, +, +	@NotNull, +	private static Map<Integer, FieldNode> fillResFieldsMap(ClassNode resCls) {, +		Map<Integer, FieldNode> resFieldsMap = new HashMap<>();, +		ConstStorage constStorage = resCls.root().getConstValues();, +		Map<Object, FieldNode> constFields = constStorage.getGlobalConstFields();, +		for (Map.Entry<Object, FieldNode> entry : constFields.entrySet()) {, +			Object key = entry.getKey();, +			FieldNode field = entry.getValue();, +			AccessInfo accessFlags = field.getAccessFlags();, +			if (field.getType().equals(ArgType.INT), +					&& accessFlags.isStatic(), +					&& accessFlags.isFinal(), +					&& key instanceof Integer) {, +				resFieldsMap.put((Integer) key, field);, +			}, +		}, +		return resFieldsMap;, +	}, +}]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +		code.add(callMth.getAlias());, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);]
[+++ b/.releaserc.yml]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +	private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter code) throws CodegenException {, +		MethodInlineAttr mia = (MethodInlineAttr) callMthNode.getAttributes().get(AttributeType.METHOD_INLINE);, +		if (mia == null) {, +			return false;, +		}, +		InsnNode inl = mia.getInsn();, +				int regNum = r.getRegNum();, +				if (regNum >= regs.length) {, +					LOG.warn("Unknown register number {} in method call: {} from {}", r, callMthNode, mth);, +					InsnArg repl = regs[regNum];, +						LOG.warn("Not passed register {} in method call: {} from {}", r, callMthNode, mth);, +			// revert changes in 'MethodInlineAttr', +		return true;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +	private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter code) throws CodegenException {, +		MethodInlineAttr mia = (MethodInlineAttr) callMthNode.getAttributes().get(AttributeType.METHOD_INLINE);, +		if (mia == null) {, +			return false;, +		}, +		InsnNode inl = mia.getInsn();, +				int regNum = r.getRegNum();, +				if (regNum >= regs.length) {, +					LOG.warn("Unknown register number {} in method call: {} from {}", r, callMthNode, mth);, +					InsnArg repl = regs[regNum];, +						LOG.warn("Not passed register {} in method call: {} from {}", r, callMthNode, mth);, +			// revert changes in 'MethodInlineAttr', +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	/**, +	 * Replace instruction arg with another using recursive search., +	 * <br>, +	 * <b>Caution:</b> this method don't change usage information for replaced argument., +	 */, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +	private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter code) throws CodegenException {, +		MethodInlineAttr mia = (MethodInlineAttr) callMthNode.getAttributes().get(AttributeType.METHOD_INLINE);, +		if (mia == null) {, +			return false;, +		}, +		InsnNode inl = mia.getInsn();, +				int regNum = r.getRegNum();, +				if (regNum >= regs.length) {, +					LOG.warn("Unknown register number {} in method call: {} from {}", r, callMthNode, mth);, +					InsnArg repl = regs[regNum];, +						LOG.warn("Not passed register {} in method call: {} from {}", r, callMthNode, mth);, +			// revert changes in 'MethodInlineAttr', +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	/**, +	 * Replace instruction arg with another using recursive search., +	 * <br>, +	 * <b>Caution:</b> this method don't change usage information for replaced argument., +	 */, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +			// set arg from 'return' instruction]
[+++ b/.gitlab-ci.yml, +image: java:8, +, +variables:, +    GRADLE_OPTS: "-Dorg.gradle.daemon=false", +    TERM: "dumb", +, +before_script:, +    - chmod +x gradlew, +, +stages:, +  - build, +, +build:, +  stage: build, +  script:, +    - sed -i " 1 s/.*/&-b${CI_JOB_ID}/" version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport dist, +  artifacts:, +    paths:, +    - build/jadx*.zip, +++ b/.gitlab-ci.yml, +image: java:8, +, +variables:, +    GRADLE_OPTS: "-Dorg.gradle.daemon=false", +    TERM: "dumb", +, +before_script:, +    - chmod +x gradlew, +, +stages:, +  - build, +, +build:, +  stage: build, +  script:, +    - sed -i " 1 s/.*/&-b${CI_JOB_ID}/" version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport dist, +  artifacts:, +    paths:, +    - build/jadx*.zip, +++ b/README.md, +[![Build Status](https://gitlab.com/skylot/jadx/badges/master/build.svg)](https://gitlab.com/skylot/jadx/commits/master), +[![coverage report](https://gitlab.com/skylot/jadx/badges/master/coverage.svg)](https://gitlab.com/skylot/jadx/commits/master), +[![Latest release](https://img.shields.io/github/release/skylot/jadx.svg)](https://github.com/skylot/jadx/releases/latest), +[![Latest release downloads](https://img.shields.io/github/downloads/skylot/jadx/latest/total.svg)](https://github.com/skylot/jadx/releases/latest), +- [unstable](https://gitlab.com/skylot/jadx/builds/artifacts/master/browse/build?job=build), +*Copyright 2018 by Skylot*, +++ b/.gitlab-ci.yml, +image: java:8, +, +variables:, +    GRADLE_OPTS: "-Dorg.gradle.daemon=false", +    TERM: "dumb", +, +before_script:, +    - chmod +x gradlew, +, +stages:, +  - build, +, +build:, +  stage: build, +  script:, +    - sed -i " 1 s/.*/&-b${CI_JOB_ID}/" version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport dist, +  artifacts:, +    paths:, +    - build/jadx*.zip, +++ b/README.md, +[![Build Status](https://gitlab.com/skylot/jadx/badges/master/build.svg)](https://gitlab.com/skylot/jadx/commits/master), +[![coverage report](https://gitlab.com/skylot/jadx/badges/master/coverage.svg)](https://gitlab.com/skylot/jadx/commits/master), +[![Latest release](https://img.shields.io/github/release/skylot/jadx.svg)](https://github.com/skylot/jadx/releases/latest), +[![Latest release downloads](https://img.shields.io/github/downloads/skylot/jadx/latest/total.svg)](https://github.com/skylot/jadx/releases/latest), +- [unstable](https://gitlab.com/skylot/jadx/builds/artifacts/master/browse/build?job=build), +*Copyright 2018 by Skylot*, +++ b/build.gradle, +plugins {, +    id 'com.github.ksoichiro.console.reporter' version '0.5.0', +}, +, +    apply plugin: 'com.github.ksoichiro.console.reporter']
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +import java.io.EOFException;, +	public void readFully(byte[] b) throws IOException {, +		readFully(b, 0, b.length);, +	}, +, +	public void readFully(byte[] b, int off, int len) throws IOException {, +		readPos += len;, +		if (len < 0), +			throw new IndexOutOfBoundsException();, +		int n = 0;, +		while (n < len) {, +			int count = input.read(b, off + n, len - n);, +			if (count < 0), +				throw new EOFException();, +			n += count;, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +import java.io.EOFException;, +	public void readFully(byte[] b) throws IOException {, +		readFully(b, 0, b.length);, +	}, +, +	public void readFully(byte[] b, int off, int len) throws IOException {, +		readPos += len;, +		if (len < 0), +			throw new IndexOutOfBoundsException();, +		int n = 0;, +		while (n < len) {, +			int count = input.read(b, off + n, len - n);, +			if (count < 0), +				throw new EOFException();, +			n += count;, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +import java.math.BigInteger;, +	private static final int KNOWN_CONFIG_BYTES = 56;, +, +		if (config.isInvalid) {, +			String typeName = pkg.getTypeStrings()[id - 1];, +			LOG.warn("Invalid config flags detected: " + typeName + config.getQualifiers());, +		}, +, +		int read = 28;, +		if (size < 28) {, +			throw new IOException("Config size < 28");, +		}, +		boolean isInvalid = false;, +		short mcc = (short) is.readInt16();, +		short mnc = (short) is.readInt16();, +		char[] language = unpackLocaleOrRegion((byte) is.readInt8(), (byte) is.readInt8(), 'a');, +		char[] country = unpackLocaleOrRegion((byte) is.readInt8(), (byte) is.readInt8(), '0');, +, +		byte orientation = (byte) is.readInt8();, +		byte touchscreen = (byte) is.readInt8();, +, +		byte keyboard = (byte) is.readInt8();, +		byte navigation = (byte) is.readInt8();, +		byte inputFlags = (byte) is.readInt8();, +		/* inputPad0 */is.readInt8();, +, +		short screenWidth = (short) is.readInt16();, +		short screenHeight = (short) is.readInt16();, +, +		short sdkVersion = (short) is.readInt16();, +		/* minorVersion, now must always be 0 */is.readInt16();, +, +		byte screenLayout = 0;, +		byte uiMode = 0;, +		short smallestScreenWidthDp = 0;, +		if (size >= 32) {, +			screenLayout = (byte) is.readInt8();, +			uiMode = (byte) is.readInt8();, +			smallestScreenWidthDp = (short) is.readInt16();, +			read = 32;, +		short screenWidthDp = 0;, +		short screenHeightDp = 0;, +		if (size >= 36) {, +			screenWidthDp = (short) is.readInt16();, +			screenHeightDp = (short) is.readInt16();, +			read = 36;, +		char[] localeScript = null;, +		char[] localeVariant = null;, +		if (size >= 48) {, +			localeScript = readScriptOrVariantChar(4).toCharArray();, +			localeVariant = readScriptOrVariantChar(8).toCharArray();, +			read = 48;, +		byte screenLayout2 = 0;, +		byte colorMode = 0;, +		if (size >= 52) {, +			screenLayout2 = (byte) is.readInt8();, +			colorMode = (byte) is.readInt8();, +			is.readInt16(); // reserved padding, +			read = 52;, +		if (size >= 56) {, +			is.readInt32();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		} else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, +			args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		} else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, +			args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +		useList.removeIf(registerArg -> registerArg == arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		} else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, +			args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +		useList.removeIf(registerArg -> registerArg == arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public void skipFirstArgument() {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		} else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, +			args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +		useList.removeIf(registerArg -> registerArg == arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public void skipFirstArgument() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +		mth.skipFirstArgument();]
[+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(DynamicCompiler.class);, +, +		if (compiler == null) {, +			LOG.error("Can not find compiler, please use JDK instead");, +			return false;, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ConstClassNode;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.FillArrayNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.SwitchNode;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +		if (mth.isNoCode()) {, +		}, +		ClassNode parentClass = mth.getParentClass();, +									mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +										FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +					case CONST_CLASS: {, +						FieldNode f;, +					}, +							FieldNode f = parentClass.getConstField(sn.getKeys()[k]);, +						if (insn.getArgsCount() > 0 && insn.getArg(0).isLiteral()) {, +							FieldNode f = parentClass.getConstFieldByLiteralArg(arg);, +		if (superCall != null && !parentClass.isEnum() && superCall.getArgsCount() != 0) {, +		if (handlerAttr == null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ConstClassNode;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.FillArrayNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.SwitchNode;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +		if (mth.isNoCode()) {, +		}, +		ClassNode parentClass = mth.getParentClass();, +									mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +										FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +					case CONST_CLASS: {, +						FieldNode f;, +					}, +							FieldNode f = parentClass.getConstField(sn.getKeys()[k]);, +						if (insn.getArgsCount() > 0 && insn.getArg(0).isLiteral()) {, +							FieldNode f = parentClass.getConstFieldByLiteralArg(arg);, +		if (superCall != null && !parentClass.isEnum() && superCall.getArgsCount() != 0) {, +		if (handlerAttr == null) {, +		}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestInnerClass.java, +import static org.hamcrest.CoreMatchers.not;, +			public class Inner2 extends Thread {, +		assertThat(code, containsString("Inner {"));, +		assertThat(code, containsString("Inner2 extends Thread {"));, +		assertThat(code, not(containsString("super();")));]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +		private final Map<Object, Object> map = new HashMap<Object, Object>();, +	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +		private final Map<Object, Object> map = new HashMap<Object, Object>();, +	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +		int f = accFlags & AccessFlags.ACC_PUBLIC, +				| accFlags & AccessFlags.ACC_PROTECTED, +				| accFlags & AccessFlags.ACC_PRIVATE;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +		private final Map<Object, Object> map = new HashMap<Object, Object>();, +	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +		int f = accFlags & AccessFlags.ACC_PUBLIC, +				| accFlags & AccessFlags.ACC_PROTECTED, +				| accFlags & AccessFlags.ACC_PRIVATE;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		return shortId.equals(other.shortId), +				&& retType.equals(other.retType), +				&& declClass.equals(other.declClass);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +		private final Map<Object, Object> map = new HashMap<Object, Object>();, +	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +		int f = accFlags & AccessFlags.ACC_PUBLIC, +				| accFlags & AccessFlags.ACC_PROTECTED, +				| accFlags & AccessFlags.ACC_PRIVATE;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		return shortId.equals(other.shortId), +				&& retType.equals(other.retType), +				&& declClass.equals(other.declClass);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +		return (int) (literal ^ literal >>> 32) + 31 * getType().hashCode();, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +		private final Map<Object, Object> map = new HashMap<Object, Object>();, +	private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +		int f = accFlags & AccessFlags.ACC_PUBLIC, +				| accFlags & AccessFlags.ACC_PROTECTED, +				| accFlags & AccessFlags.ACC_PRIVATE;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		return shortId.equals(other.shortId), +				&& retType.equals(other.retType), +				&& declClass.equals(other.declClass);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +		return (int) (literal ^ literal >>> 32) + 31 * getType().hashCode();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +import org.jetbrains.annotations.NotNull;, +, +	void setSVar(@NotNull SSAVar sVar) {, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +		return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +				if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +				if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +import jadx.core.dex.instructions.args.ArgType;, +	public ArgType getType() {, +		return field.getType();, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +				if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +import jadx.core.dex.instructions.args.ArgType;, +	public ArgType getType() {, +		return field.getType();, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.List;, +, +	public List<ArgType> getArguments() {, +		return mth.getMethodInfo().getArgumentsTypes();, +	}, +, +	public ArgType getReturnType() {, +		return mth.getReturnType();, +	}, +, +	public boolean isConstructor() {, +		return mth.getMethodInfo().isConstructor();, +	}, +, +	public boolean isClassInit() {, +		return mth.getMethodInfo().isClassInit();, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +				if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +import jadx.core.dex.instructions.args.ArgType;, +	public ArgType getType() {, +		return field.getType();, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.List;, +, +	public List<ArgType> getArguments() {, +		return mth.getMethodInfo().getArgumentsTypes();, +	}, +, +	public ArgType getReturnType() {, +		return mth.getReturnType();, +	}, +, +	public boolean isConstructor() {, +		return mth.getMethodInfo().isConstructor();, +	}, +, +	public boolean isClassInit() {, +		return mth.getMethodInfo().isClassInit();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// inline method, +				ClassInfo declClass = callMth.getDeclClass();, +				if (!insnCls.equals(declClass)) {, +					code.add(useClass(declClass)).add('.');, +				}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +	public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +				if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +import jadx.core.dex.instructions.args.ArgType;, +	public ArgType getType() {, +		return field.getType();, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, +		sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, +		sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	@Deprecated, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, +		sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	@Deprecated, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	private boolean typeImmutable;, +	public int getRegNum() {, +		return regNum;, +	}, +, +		ArgType acceptedType;, +		if (typeImmutable) {, +			// don't change type, just update types in useList, +			acceptedType = this.type;, +		} else {, +			acceptedType = type;, +			this.type = acceptedType;, +		}, +			assign.type = acceptedType;, +			useList.get(i).type = acceptedType;, +	public void setTypeImmutable(ArgType type) {, +		setType(type);, +		this.typeImmutable = true;, +	}, +, +	public boolean isTypeImmutable() {, +		return typeImmutable;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, +		sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	@Deprecated, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	private boolean typeImmutable;, +	public int getRegNum() {, +		return regNum;, +	}, +, +		ArgType acceptedType;, +		if (typeImmutable) {, +			// don't change type, just update types in useList, +			acceptedType = this.type;, +		} else {, +			acceptedType = type;, +			this.type = acceptedType;, +		}, +			assign.type = acceptedType;, +			useList.get(i).type = acceptedType;, +	public void setTypeImmutable(ArgType type) {, +		setType(type);, +		this.typeImmutable = true;, +	}, +, +	public boolean isTypeImmutable() {, +		return typeImmutable;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/PostTypeInference.java, +				RegisterArg result = insn.getResult();, +				boolean skip = castType.isObject() && castType.getObject().equals(result.getType().getObject());, +					result.getSVar().setType(castType);, +				RegisterArg result = phi.getResult();, +				SSAVar resultSVar = result.getSVar();, +				if (resultSVar != null && !result.getType().isTypeKnown()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, +		sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	@Deprecated, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	private boolean typeImmutable;, +	public int getRegNum() {, +		return regNum;, +	}, +, +		ArgType acceptedType;, +		if (typeImmutable) {, +			// don't change type, just update types in useList, +			acceptedType = this.type;, +		} else {, +			acceptedType = type;, +			this.type = acceptedType;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +		List<TypeUpdateEntry> updates = updateInfo.getUpdates();, +		updates.forEach(TypeUpdateEntry::apply);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +		List<TypeUpdateEntry> updates = updateInfo.getUpdates();, +		updates.forEach(TypeUpdateEntry::apply);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java, +package jadx.core.dex.visitors.typeinference;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +, +public final class TypeUpdateEntry {, +	private final InsnArg arg;, +	private final ArgType type;, +, +	public TypeUpdateEntry(InsnArg arg, ArgType type) {, +		this.arg = arg;, +		this.type = type;, +	}, +, +	public void apply() {, +		arg.setType(type);, +	}, +, +	public InsnArg getArg() {, +		return arg;, +	}, +, +	public ArgType getType() {, +		return type;, +	}, +, +	@Override, +	public String toString() {, +		return "TypeUpdateEntry{" + arg + " -> " + type + '}';, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +		List<TypeUpdateEntry> updates = updateInfo.getUpdates();, +		updates.forEach(TypeUpdateEntry::apply);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java, +package jadx.core.dex.visitors.typeinference;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +, +public final class TypeUpdateEntry {, +	private final InsnArg arg;, +	private final ArgType type;, +, +	public TypeUpdateEntry(InsnArg arg, ArgType type) {, +		this.arg = arg;, +		this.type = type;, +	}, +, +	public void apply() {, +		arg.setType(type);, +	}, +, +	public InsnArg getArg() {, +		return arg;, +	}, +, +	public ArgType getType() {, +		return type;, +	}, +, +	@Override, +	public String toString() {, +		return "TypeUpdateEntry{" + arg + " -> " + type + '}';, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateInfo.java, +import java.util.ArrayList;, +import java.util.List;, +	private final List<TypeUpdateEntry> updates = new ArrayList<>();, +		updates.add(new TypeUpdateEntry(arg, changeType));, +		if (updates.isEmpty()) {, +			return false;, +		}, +		for (TypeUpdateEntry entry : updates) {, +			if (entry.getArg() == arg) {, +				return true;, +			}, +		}, +		return false;, +		updates.removeIf(updateEntry -> updateEntry.getArg() == arg);, +	public List<TypeUpdateEntry> getUpdates() {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +			}, +		return "LOOP:" + info.getId() + ": " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +			}, +		return "LOOP:" + info.getId() + ": " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +				SplitterBlockAttr splitter = new SplitterBlockAttr(curBlock);, +				block.addAttr(splitter);, +				curBlock.addAttr(splitter);, +					BlockNode splitterBlock = spl.getBlock();, +					boolean tryEnd = insn.contains(AFlag.TRY_LEAVE);, +						BlockNode handlerBlock = getBlock(h.getHandleOffset(), blocksMap);, +						if (splitterBlock != handlerBlock) {, +							connect(splitterBlock, handlerBlock);, +						}, +						if (tryEnd) {, +							connect(block, handlerBlock);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		if (catchBlocks.length == 0 && tries.length == 0) {, +			return;, +		}, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +				insn = insnByOffset[offset];, +				catchBlock.addInsn(insn);, +			} else {, +				insn.add(AFlag.TRY_LEAVE);, +			if (parentClass.getClassInfo().isInner(), +					&& !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +			}, +		return "LOOP:" + info.getId() + ": " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +				SplitterBlockAttr splitter = new SplitterBlockAttr(curBlock);, +				block.addAttr(splitter);, +				curBlock.addAttr(splitter);, +					BlockNode splitterBlock = spl.getBlock();, +					boolean tryEnd = insn.contains(AFlag.TRY_LEAVE);, +						BlockNode handlerBlock = getBlock(h.getHandleOffset(), blocksMap);, +						if (splitterBlock != handlerBlock) {, +							connect(splitterBlock, handlerBlock);, +						}, +						if (tryEnd) {, +							connect(block, handlerBlock);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (!exitBlocks.isEmpty()) {, +				List<LoopInfo> list = mth.getAllLoopsForBlock(block);, +				if (list.size() >= 2) {, +					// bad condition if successors going out of all loops, +					boolean allOuter = true;, +					for (BlockNode outerBlock : block.getCleanSuccessors()) {, +						List<LoopInfo> outLoopList = mth.getAllLoopsForBlock(outerBlock);, +						outLoopList.remove(loop);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, +			if (k++ > ITERATIVE_LIMIT) {, +				throw new JadxOverflowException("Iterative traversal limit reached, method: " + mth);, +			}, +		} while (repeat);, +	}, +, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionIterativeVisitor visitor) {, +		boolean repeat;, +		int k = 0;, +		do {, +			repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, +			if (!repeat) {, +				for (ExceptionHandler h : mth.getExceptionHandlers()) {, +					repeat = traverseIterativeStepInternal(mth, visitor, h.getHandlerRegion());, +					if (repeat) {, +						break;, +					}, +				}, +			}, +	private static boolean traverseIterativeStepInternal(MethodNode mth, IRegionIterativeVisitor visitor,, +				if (traverseIterativeStepInternal(mth, visitor, subCont)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, +			if (k++ > ITERATIVE_LIMIT) {, +				throw new JadxOverflowException("Iterative traversal limit reached, method: " + mth);, +			}, +		} while (repeat);, +	}, +, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionIterativeVisitor visitor) {, +		boolean repeat;, +		int k = 0;, +		do {, +			repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, +			if (!repeat) {, +				for (ExceptionHandler h : mth.getExceptionHandlers()) {, +					repeat = traverseIterativeStepInternal(mth, visitor, h.getHandlerRegion());, +					if (repeat) {, +						break;, +					}, +				}, +			}, +	private static boolean traverseIterativeStepInternal(MethodNode mth, IRegionIterativeVisitor visitor,, +				if (traverseIterativeStepInternal(mth, visitor, subCont)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.nodes.IBranchRegion;, +		IRegionIterativeVisitor visitor = new IRegionIterativeVisitor() {, +			public boolean visitRegion(MethodNode mth, IRegion region) {, +				boolean changed = checkAndWrap(mth, tryBlocksMap, region);, +				return changed && !tryBlocksMap.isEmpty();, +		};, +		DepthRegionTraversal.traverseIncludingExcHandlers(mth, visitor);, +	private static boolean checkAndWrap(MethodNode mth, Map<BlockNode, TryCatchBlock> tryBlocksMap, IRegion region) {, +				return true;, +		return false;, +		if (replaceRegion == null) {, +			return false;, +		}, +		if (replaceRegion instanceof LoopRegion) {, +			LoopRegion loop = (LoopRegion) replaceRegion;, +			return wrapBlocks(loop.getBody(), tb, dominator);, +		}, +		if (replaceRegion instanceof IBranchRegion) {, +			return wrapBlocks(replaceRegion.getParent(), tb, dominator);, +		Region tryRegion = new Region(replaceRegion);, +		List<IContainer> subBlocks = replaceRegion.getSubBlocks();, +		TryCatchRegion tryCatchRegion = new TryCatchRegion(replaceRegion, tryRegion);, +		if (!replaceRegion.replaceSubBlock(firstNode, tryCatchRegion)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, +			if (k++ > ITERATIVE_LIMIT) {, +				throw new JadxOverflowException("Iterative traversal limit reached, method: " + mth);, +			}, +		} while (repeat);, +	}, +, +	public static void traverseIncludingExcHandlers(MethodNode mth, IRegionIterativeVisitor visitor) {, +		boolean repeat;, +		int k = 0;, +		do {, +			repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, +			if (!repeat) {, +				for (ExceptionHandler h : mth.getExceptionHandlers()) {, +					repeat = traverseIterativeStepInternal(mth, visitor, h.getHandlerRegion());, +					if (repeat) {, +						break;, +					}, +				}, +			}, +	private static boolean traverseIterativeStepInternal(MethodNode mth, IRegionIterativeVisitor visitor,, +				if (traverseIterativeStepInternal(mth, visitor, subCont)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.nodes.IBranchRegion;, +		IRegionIterativeVisitor visitor = new IRegionIterativeVisitor() {, +			public boolean visitRegion(MethodNode mth, IRegion region) {, +				boolean changed = checkAndWrap(mth, tryBlocksMap, region);, +				return changed && !tryBlocksMap.isEmpty();, +		};]
[+++ b/jadx-core/build.gradle, +    compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/build.gradle, +    compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, +	public void copyLines(LineAttrNode lineAttrNode) {, +		setSourceLine(lineAttrNode.getSourceLine());, +		setDecompiledLine(lineAttrNode.getDecompiledLine());, +	}, +++ b/jadx-core/build.gradle, +    compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, +	public void copyLines(LineAttrNode lineAttrNode) {, +		setSourceLine(lineAttrNode.getSourceLine());, +		setDecompiledLine(lineAttrNode.getDecompiledLine());, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstClassNode(clsType));, +	}, +, +	@Override, +++ b/jadx-core/build.gradle, +    compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, +	public void copyLines(LineAttrNode lineAttrNode) {, +		setSourceLine(lineAttrNode.getSourceLine());, +		setDecompiledLine(lineAttrNode.getDecompiledLine());, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstClassNode(clsType));, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstStringNode(str));, +	}, +, +	@Override, +++ b/jadx-core/build.gradle, +    compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, +	public void copyLines(LineAttrNode lineAttrNode) {, +		setSourceLine(lineAttrNode.getSourceLine());, +		setDecompiledLine(lineAttrNode.getDecompiledLine());, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstClassNode(clsType));, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstStringNode(str));, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java, +	public IndexInsnNode copy() {, +		return copyCommonParams(new IndexInsnNode(insnType, index, getArgsCount()));, +	}, +, +	@Override, +++ b/jadx-core/build.gradle, +    compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, +	public void copyLines(LineAttrNode lineAttrNode) {, +		setSourceLine(lineAttrNode.getSourceLine());, +		setDecompiledLine(lineAttrNode.getDecompiledLine());, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstClassNode(clsType));, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java, +	public InsnNode copy() {, +		return copyCommonParams(new ConstStringNode(str));, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IndexInsnNode.java, +	public IndexInsnNode copy() {, +		return copyCommonParams(new IndexInsnNode(insnType, index, getArgsCount()));, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +	private InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {, +		super(InsnType.INVOKE, argsCount);, +		this.mth = mth;]
[+++ b/jadx-core/build.gradle, +    compile 'com.intellij:annotations:12.0', +++ b/jadx-core/build.gradle, +    compile 'com.intellij:annotations:12.0', +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	// not null after SSATransform pass, +	private SSAVar sVar;, +		return sVar.getAssign().getParentInsn();, +		InsnNode parent = sVar.getAssign().getParentInsn();, +++ b/jadx-core/build.gradle, +    compile 'com.intellij:annotations:12.0', +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	// not null after SSATransform pass, +	private SSAVar sVar;, +		return sVar.getAssign().getParentInsn();, +		InsnNode parent = sVar.getAssign().getParentInsn();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +, +	@NotNull, +	@Nullable, +	public SSAVar(int regNum, int v, @NotNull RegisterArg assign) {, +		if (assign.getParentInsn() != null) {, +	@NotNull, +	public void setAssign(@NotNull RegisterArg assign) {, +	public void setUsedInPhi(@Nullable PhiInsn usedInPhi) {, +	@Nullable, +		if (usedInPhi == null) {, +++ b/jadx-core/build.gradle, +    compile 'com.intellij:annotations:12.0', +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	// not null after SSATransform pass, +	private SSAVar sVar;, +		return sVar.getAssign().getParentInsn();, +		InsnNode parent = sVar.getAssign().getParentInsn();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +, +	@NotNull, +	@Nullable, +	public SSAVar(int regNum, int v, @NotNull RegisterArg assign) {, +		if (assign.getParentInsn() != null) {, +	@NotNull, +	public void setAssign(@NotNull RegisterArg assign) {, +	public void setUsedInPhi(@Nullable PhiInsn usedInPhi) {, +	@Nullable, +		if (usedInPhi == null) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java, +			PhiInsn phi = t.getResult().getSVar().getUsedInPhi();, +			if (phi == null || !t.getResult().equalRegisterAndType(e.getResult())) {, +++ b/jadx-core/build.gradle, +    compile 'com.intellij:annotations:12.0', +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	// not null after SSATransform pass, +	private SSAVar sVar;, +		return sVar.getAssign().getParentInsn();, +		InsnNode parent = sVar.getAssign().getParentInsn();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +, +	@NotNull, +	@Nullable, +	public SSAVar(int regNum, int v, @NotNull RegisterArg assign) {, +		if (assign.getParentInsn() != null) {, +	@NotNull, +	public void setAssign(@NotNull RegisterArg assign) {, +	public void setUsedInPhi(@Nullable PhiInsn usedInPhi) {, +	@Nullable, +		if (usedInPhi == null) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/TernaryMod.java, +			PhiInsn phi = t.getResult().getSVar().getUsedInPhi();, +			if (phi == null || !t.getResult().equalRegisterAndType(e.getResult())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInference.java, +			PhiInsn phi = sVar.getUsedInPhi();, +			if (phi != null) {, +				processPhiNode(phi);, +		if (useList.isEmpty() || var.isTypeImmutable()) {, +		ArgType type = assign.getType();, +		String name = var.getAssign().getName();, +				return vName;, +		return null;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		} else if (insn instanceof ConstructorInsn) {, +			ClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();, +			addDep(dex, depList, declClass);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		} else if (insn instanceof ConstructorInsn) {, +			ClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();, +			addDep(dex, depList, declClass);, +++ b/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java, +			code.startLine("/* ").addMultiLine(comment).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		} else if (insn instanceof ConstructorInsn) {, +			ClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();, +			addDep(dex, depList, declClass);, +++ b/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java, +			code.startLine("/* ").addMultiLine(comment).add(" */");, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java, +package jadx.tests.integration.invoke;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestInheritedStaticInvoke extends IntegrationTest {, +, +	public static class TestCls {, +		public static class A {, +			public static int a() {, +				return 1;, +			}, +		}, +, +		public static class B extends A {, +		}, +, +		public int test() {, +			return B.a(); // not A.a(), +		}, +	}, +, +	@Test]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// 'static' and 'private' modifier not allowed for top classes (not inner), +			af = af.remove(AccessFlags.ACC_STATIC).remove(AccessFlags.ACC_PRIVATE);, +			code.startLine(f.getField().getAlias());, +			if (isFieldsPresents()) {, +				code.startLine();, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// 'static' and 'private' modifier not allowed for top classes (not inner), +			af = af.remove(AccessFlags.ACC_STATIC).remove(AccessFlags.ACC_PRIVATE);, +			code.startLine(f.getField().getAlias());, +			if (isFieldsPresents()) {, +				code.startLine();, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +import jadx.core.dex.info.FieldInfo;, +		private final FieldInfo field;, +		public EnumField(FieldInfo field, ConstructorInsn co, int startArg) {, +			this.field = field;, +		public FieldInfo getField() {, +			return field;, +			return field + "(" + constrInsn + ") " + cls;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		// 'static' and 'private' modifier not allowed for top classes (not inner), +			af = af.remove(AccessFlags.ACC_STATIC).remove(AccessFlags.ACC_PRIVATE);, +			code.startLine(f.getField().getAlias());, +			if (isFieldsPresents()) {, +				code.startLine();, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +import jadx.core.dex.info.FieldInfo;, +		private final FieldInfo field;, +		public EnumField(FieldInfo field, ConstructorInsn co, int startArg) {, +			this.field = field;, +		public FieldInfo getField() {, +			return field;, +			return field + "(" + constrInsn + ") " + cls;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.deobf.NameMapper;, +			FieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) putInsn).getIndex();, +			if (name != null, +					&& !fieldInfo.getAlias().equals(name), +					&& NameMapper.isValidIdentifier(name)) {, +				// LOG.debug("Rename enum field: '{}' to '{}' in {}", fieldInfo.getName(), name, cls);, +				fieldInfo.setAlias(name);, +, +			EnumField field = new EnumField(fieldInfo, co, 2);, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +package jadx.cli;, +, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +import com.beust.jcommander.Parameterized;, +, +import jadx.api.JadxDecompiler;, +, +public class JCommanderWrapper<T> {, +	private final JCommander jc;, +, +	public JCommanderWrapper(T obj) {, +		this.jc = JCommander.newBuilder().addObject(obj).build();, +	}, +, +	public boolean parse(String[] args) {, +		try {, +			jc.parse(args);, +			return true;, +		} catch (ParameterException e) {, +			System.err.println("Arguments parse error: " + e.getMessage());, +			printUsage();, +			return false;, +		}, +	}, +, +	public void overrideProvided(T obj) {, +		List<ParameterDescription> fieldsParams = jc.getParameters();, +		List<ParameterDescription> parameters = new ArrayList<>(1 + fieldsParams.size());, +		parameters.add(jc.getMainParameterValue());, +		parameters.addAll(fieldsParams);, +		for (ParameterDescription parameter : parameters) {, +			if (parameter.isAssigned()) {, +				// copy assigned field value to obj, +				Parameterized parameterized = parameter.getParameterized();, +				Object val = parameterized.get(parameter.getObject());, +				parameterized.set(obj, val);, +			}, +		}, +	}, +, +	public void printUsage() {, +		// print usage in not sorted fields order (by default its sorted by description), +		PrintStream out = System.out;, +		out.println();, +		out.println("jadx - dex to java decompiler, version: " + JadxDecompiler.getVersion());, +		out.println();, +		out.println("usage: jadx [options] " + jc.getMainParameterDescription());, +		out.println("options:");, +, +		List<ParameterDescription> params = jc.getParameters();, +		Map<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());, +		int maxNamesLen = 0;, +		for (ParameterDescription p : params) {, +			paramsMap.put(p.getParameterized().getName(), p);, +			int len = p.getNames().length();, +			if (len > maxNamesLen) {, +				maxNamesLen = len;, +			}, +		}, +		JadxCLIArgs args = new JadxCLIArgs();, +		Field[] fields = args.getClass().getDeclaredFields();, +		for (Field f : fields) {, +			String name = f.getName();, +			ParameterDescription p = paramsMap.get(name);, +			if (p == null) {, +				continue;, +			}, +			StringBuilder opt = new StringBuilder();, +			opt.append("  ").append(p.getNames());, +			addSpaces(opt, maxNamesLen - opt.length() + 3);, +			opt.append("- ").append(p.getDescription());, +			addDefaultValue(args, f, opt);, +			out.println(opt);, +		}, +		out.println("Example:");, +		out.println("  jadx -d out classes.dex");, +	}, +, +	private void addDefaultValue(JadxCLIArgs args, Field f, StringBuilder opt) {, +		Class<?> fieldType = f.getType();, +		if (fieldType == int.class) {, +			try {, +				int val = f.getInt(args);, +				opt.append(" (default: ").append(val).append(")");, +			} catch (Exception e) {, +				// ignore, +			}, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					"Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()), +							+ ", element type: " + elType + ", insn element type: " + insnElementType);, +			if (!elType.isTypeKnown()) {, +				elType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +					"Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()), +							+ ", element type: " + elType + ", insn element type: " + insnElementType);, +			if (!elType.isTypeKnown()) {, +				elType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();, +			}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestTmp2.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestTmp2 extends InternalJadxTest {, +, +	public static class TestCls extends Exception {, +		int c;, +		String d;, +		String f;, +, +		public void testComplexIf(String a, int b) {, +			if (d == null || (c == 0 && b != -1 && d.length() == 0)) {, +				c = a.codePointAt(c);, +			} else {, +				if (a.hashCode() != 0xCDE) {, +					c = f.compareTo(a);, +				}, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsString("return;"));, +		assertThat(code, not(containsString("else")));, +	}, +}]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		} catch (Exception e) {, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {, +		if (jadxArgs.getInput().isEmpty()) {, +			LOG.error("Please specify input file");, +			jadxArgs.printUsage();, +			System.exit(1);, +		}, +			if (pos != -1) {, +			} else {, +			}, +		if (outputDir.exists() && !outputDir.isDirectory()) {, +			throw new Exception("Output directory exists as file " + outputDir);, +		}, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		} catch (Exception e) {, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {, +		if (jadxArgs.getInput().isEmpty()) {, +			LOG.error("Please specify input file");, +			jadxArgs.printUsage();, +			System.exit(1);, +		}, +			if (pos != -1) {, +			} else {, +			}, +		if (outputDir.exists() && !outputDir.isDirectory()) {, +			throw new Exception("Output directory exists as file " + outputDir);, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk or .jar)"), +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph to dot file"), +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		} catch (Exception e) {, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {, +		if (jadxArgs.getInput().isEmpty()) {, +			LOG.error("Please specify input file");, +			jadxArgs.printUsage();, +			System.exit(1);, +		}, +			if (pos != -1) {, +			} else {, +			}, +		if (outputDir.exists() && !outputDir.isDirectory()) {, +			throw new Exception("Output directory exists as file " + outputDir);, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk or .jar)"), +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph to dot file"), +++ b/jadx-cli/src/main/resources/logback.xml, +<configuration>, +, +    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, +        <encoder>, +            <pattern>%-5level - %msg%n</pattern>, +        </encoder>, +    </appender>, +, +    <root level="INFO">, +        <appender-ref ref="STDOUT"/>, +    </root>, +, +</configuration>, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		} catch (Exception e) {, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {, +		if (jadxArgs.getInput().isEmpty()) {, +			LOG.error("Please specify input file");, +			jadxArgs.printUsage();, +			System.exit(1);, +		}, +			if (pos != -1) {, +			} else {, +			}, +		if (outputDir.exists() && !outputDir.isDirectory()) {, +			throw new Exception("Output directory exists as file " + outputDir);, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk or .jar)"), +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph to dot file"), +++ b/jadx-cli/src/main/resources/logback.xml, +<configuration>, +, +    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, +        <encoder>, +            <pattern>%-5level - %msg%n</pattern>, +        </encoder>, +    </appender>, +, +    <root level="INFO">, +        <appender-ref ref="STDOUT"/>, +    </root>, +, +</configuration>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.ConstClassNode;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private int numtabs=-1;, +		numtabs+=1;, +		for(int i=0; i<numtabs; i++) System.out.print("\t");, +		System.out.print("<" + strings[startNSName]);, +		if(attributeCount>0) System.out.print(" ");, +			//if(attributeNS!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeNS]);, +			if(attributeName!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeName]);, +			if(attrValDataType==0x3) System.out.print(strings[attributeName] + "=\"" + strings[attrValData]+"\"");, +			else if(attrValDataType==0x10) System.out.print(strings[attributeName] + "=\"" + attrValData+"\"");, +			else if(attrValDataType==0x12) {, +				// TODO: data is always -1, FIXME, +				if(attrValData==0) System.out.print(strings[attributeName] + "=\"false\"");, +				else if(attrValData==1 || attrValData==-1) System.out.print(strings[attributeName] + "=\"true\"");, +				else System.out.print(strings[attributeName] + "=\"UNKNOWN\"");, +			}, +			else System.out.print(strings[attributeName] + " = UNKNOWN DATA TYPE: " + attrValDataType);, +			System.out.print(" ");, +		for(int i=0; i<numtabs; i++) System.out.print("\t");, +		numtabs-=1;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		// must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		// must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;, +		if (contains(AFlag.THIS)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		// must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;, +		if (contains(AFlag.THIS)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +	public static final String THIS_ARG_NAME = "this";, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		if (isThis()) {, +			sVar.setName(THIS_ARG_NAME);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		// must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;, +		if (contains(AFlag.THIS)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +	public static final String THIS_ARG_NAME = "this";, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		if (isThis()) {, +			sVar.setName(THIS_ARG_NAME);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			return true;, +			arg.add(AFlag.THIS);, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		// must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;, +		if (contains(AFlag.THIS)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +	public static final String THIS_ARG_NAME = "this";, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		if (isThis()) {, +			sVar.setName(THIS_ARG_NAME);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			return true;, +			arg.add(AFlag.THIS);, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +		markThisArg(mth);, +, +	private static void markThisArg(MethodNode mth) {, +		RegisterArg thisArg = mth.getThisArg();, +		if (thisArg != null) {, +			thisArg.getSVar().getUseList().forEach(arg -> arg.add(AFlag.THIS));, +		}, +	}]
[+++ b/.travis.yml, +      if: branch = master AND repo = env(MAIN_REPO) AND type = push, +      if: branch = release AND repo = env(MAIN_REPO) AND type = push]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +			processTryCatchBlocks(block);, +		ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, +		if (!block.getInstructions().isEmpty()) {, +			InsnNode me = block.getInstructions().get(0);, +				resArg.copyAttributesFrom(me);, +				return;, +			}, +		}, +			return eh.isCatchAll() || eh.isFinally();, +	private static void processTryCatchBlocks(BlockNode block) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +			processTryCatchBlocks(block);, +		ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, +		if (!block.getInstructions().isEmpty()) {, +			InsnNode me = block.getInstructions().get(0);, +				resArg.copyAttributesFrom(me);, +				return;, +			}, +		}, +			return eh.isCatchAll() || eh.isFinally();, +	private static void processTryCatchBlocks(BlockNode block) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +import jadx.core.dex.trycatch.ExcHandlerAttr;, +					BlockNode newBlock = startNewBlock(mth, insn.getOffset());, +						connect(curBlock, newBlock);, +					curBlock = newBlock;, +						curBlock = connectNewBlock(mth, curBlock, insn.getOffset());, +				curBlock = insertSplitterBlock(mth, blocksMap, curBlock, insn, startNew);, +			} else if (insn.contains(AType.EXC_HANDLER)) {, +				processExceptionHandler(mth, curBlock, insn);, +				curBlock.getInstructions().add(insn);, +			}, +	/**, +	 * Make separate block for exception handler. New block already added if MOVE_EXCEPTION insn exists., +	 * Also link ExceptionHandler with current block., +	 */, +	private static void processExceptionHandler(MethodNode mth, BlockNode curBlock, InsnNode insn) {, +		ExcHandlerAttr excHandlerAttr = insn.get(AType.EXC_HANDLER);, +		insn.remove(AType.EXC_HANDLER);, +, +		BlockNode excHandlerBlock;, +		if (insn.getType() == InsnType.MOVE_EXCEPTION) {, +			excHandlerBlock = curBlock;, +		} else {, +			BlockNode newBlock = startNewBlock(mth, -1);, +			newBlock.add(AFlag.SYNTHETIC);, +			connect(newBlock, curBlock);, +, +			excHandlerBlock = newBlock;, +		}, +		excHandlerBlock.addAttr(excHandlerAttr);, +		excHandlerAttr.getHandler().setHandlerBlock(excHandlerBlock);, +	}, +, +	/**, +	 * For try/catch make empty (splitter) block for connect handlers, +	 */, +	private static BlockNode insertSplitterBlock(MethodNode mth, Map<Integer, BlockNode> blocksMap,, +	                                             BlockNode curBlock, InsnNode insn, boolean startNew) {, +		BlockNode splitterBlock;, +		if (insn.getOffset() == 0 || startNew) {, +			splitterBlock = curBlock;, +		} else {, +			splitterBlock = connectNewBlock(mth, curBlock, insn.getOffset());, +		}, +		blocksMap.put(insn.getOffset(), splitterBlock);, +, +		SplitterBlockAttr splitterAttr = new SplitterBlockAttr(splitterBlock);, +		splitterBlock.add(AFlag.SYNTHETIC);, +		splitterBlock.addAttr(splitterAttr);, +, +		// add this insn in new block, +		BlockNode newBlock = startNewBlock(mth, -1);, +		newBlock.getInstructions().add(insn);, +		newBlock.addAttr(splitterAttr);, +		connect(splitterBlock, newBlock);, +		return newBlock;, +	}, +, +	private static BlockNode connectNewBlock(MethodNode mth, BlockNode curBlock, int offset) {, +		BlockNode block = startNewBlock(mth, offset);, +		connect(curBlock, block);, +		return block;, +	}, +, +				connectExceptionHandlers(block, insn);, +	private static void connectExceptionHandlers(BlockNode block, InsnNode insn) {, +			BlockNode handlerBlock = h.getHandlerBlock();, +				if (!insn.isAttrStorageEmpty()) {, +					return false;, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +			processTryCatchBlocks(block);, +		ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, +		if (!block.getInstructions().isEmpty()) {, +			InsnNode me = block.getInstructions().get(0);, +				resArg.copyAttributesFrom(me);, +				return;, +			}]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMinLength = 4;, +	protected boolean deobfuscationUseSourceNameAsAlias = true;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMinLength = 4;, +	protected boolean deobfuscationUseSourceNameAsAlias = true;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxSettings.class);, +	private static final int CURRENT_SETTINGS_VERSION = 1;, +	private int settingsVersion = 0;, +, +		if (settingsVersion != CURRENT_SETTINGS_VERSION) {, +			upgradeSettings(settingsVersion);, +		}, +, +	private void upgradeSettings(int fromVersion) {, +		LOG.debug("upgrade settings from version: {} to {}", fromVersion, CURRENT_SETTINGS_VERSION);, +		if (fromVersion == 0) {, +			setDeobfuscationMinLength(4);, +			setDeobfuscationUseSourceNameAsAlias(true);, +			setDeobfuscationForceSave(true);, +			setThreadsCount(1);, +			setReplaceConsts(true);, +			setSkipResources(false);, +			setAutoStartJobs(false);, +//			fromVersion++;, +		}, +		settingsVersion = CURRENT_SETTINGS_VERSION;, +		sync();, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMinLength = 4;, +	protected boolean deobfuscationUseSourceNameAsAlias = true;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxSettings.class);, +	private static final int CURRENT_SETTINGS_VERSION = 1;, +	private int settingsVersion = 0;, +, +		if (settingsVersion != CURRENT_SETTINGS_VERSION) {, +			upgradeSettings(settingsVersion);, +		}, +, +	private void upgradeSettings(int fromVersion) {, +		LOG.debug("upgrade settings from version: {} to {}", fromVersion, CURRENT_SETTINGS_VERSION);, +		if (fromVersion == 0) {, +			setDeobfuscationMinLength(4);, +			setDeobfuscationUseSourceNameAsAlias(true);, +			setDeobfuscationForceSave(true);, +			setThreadsCount(1);, +			setReplaceConsts(true);, +			setSkipResources(false);, +			setAutoStartJobs(false);, +//			fromVersion++;, +		}, +		settingsVersion = CURRENT_SETTINGS_VERSION;, +		sync();, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JLoadableNode.java, +	private static final long serialVersionUID = 5543590584166374958L;, +]
[+++ b/build.gradle, +		compile 'com.google.android:android:4.1.1.4', +++ b/build.gradle, +		compile 'com.google.android:android:4.1.1.4', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +/*, +*/, +++ b/build.gradle, +		compile 'com.google.android:android:4.1.1.4', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +/*, +*/, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.lang.reflect.Field;, +, +import java.util.HashMap;, +import java.util.Map;, +, +import android.R.style;, +//import android.content.res.Resources;, +, +	Map<Integer, String> styleMap = null;, +		styleMap = new HashMap<Integer, String>();, +		if(null==styleMap) die("null==styleMap");, +		for(Field f : android.R.style.class.getFields()) {, +			try {, +				styleMap.put(f.getInt(f.getType()),f.getName());, +			} catch(IllegalAccessException iae) {, +				die("IAE");, +			}, +		}, +		, +		if(styleIndex!=0) System.out.println("startNS: styleIndex: " + styleIndex);, +			} else if(attrValDataType==0x1) {, +				if(attrValData<0x7f000000) {, +					//System.out.println("0x"+Integer.toHexString(attrValData));, +					//System.out.println(styleMap.get(attrValData));, +					//System.out.println(android.R.style.class);, +					writer.print("@*");, +					if(attributeNS != -1) writer.print(nsPrefix+":");, +					writer.print("style/"+styleMap.get(attrValData).replaceAll("_", "."));, +				} else {, +					writer.print("0x" + Integer.toHexString(attrValData));, +				}, +			}, +			else {, +/*, +	//System.out.println("ai["+i+"] ns: " + attributeNS);, +	//if(attributeNS!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeNS]);, +	//System.out.println("ai["+i+"] name: " + attributeName);, +	if(attributeName!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeName]);, +	System.out.println("ai["+i+"] rawval: " + attributeRawValue);, +	if(attributeRawValue!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeRawValue]);, +	System.out.println("ai["+i+"] dt: " + attrValDataType);, +	System.out.println("ai["+i+"] d: " + attrValData);, +*/, +				if("configChanges".equals(strings[attributeName])) {, +					if(attrValData==1152) writer.print("orientation");, +					else if(attrValData==4016) writer.print("keyboard|keyboardHidden|orientation|screenLayout|uiMode");, +					else if(attrValData==176) writer.print("keyboard|keyboardHidden|orientation");, +					else if(attrValData==160) writer.print("keyboardHidden|orientation");, +					else writer.print("UNKNOWN_DATA_"+Integer.toHexString(attrValData));, +				} else {, +					writer.print("UNKNOWN_DATA_TYPE_" + attrValDataType);, +				}, +			}]
[+++ b/.gitignore, +*-tmp/, +, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, +    compile 'ch.qos.logback:logback-classic:1.0.13', +, +    runtime files(jadxClasspath), +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, +    compile 'ch.qos.logback:logback-classic:1.0.13', +, +    runtime files(jadxClasspath), +++ b/jadx-core/clsp-data/android-4.3.jar, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, +    compile 'ch.qos.logback:logback-classic:1.0.13', +, +    runtime files(jadxClasspath), +++ b/jadx-core/clsp-data/android-4.3.jar, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		List<ClassNode> classNodeList = root.getClasses(false);, +		List<JavaClass> classes = new ArrayList<JavaClass>(classNodeList.size());, +		for (ClassNode classNode : classNodeList) {, +		for (ClassNode cls : root.getClasses(false)) {, +		root = new RootNode();, +		root.load(inputFiles);, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, +    compile 'ch.qos.logback:logback-classic:1.0.13', +, +    runtime files(jadxClasspath), +++ b/jadx-core/clsp-data/android-4.3.jar, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		List<ClassNode> classNodeList = root.getClasses(false);, +		List<JavaClass> classes = new ArrayList<JavaClass>(classNodeList.size());, +		for (ClassNode classNode : classNodeList) {, +		for (ClassNode cls : root.getClasses(false)) {, +		root = new RootNode();, +		root.load(inputFiles);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +package jadx.core.clsp;, +, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.DecodeException;, +, +import java.io.BufferedOutputStream;, +import java.io.DataInputStream;, +import java.io.DataOutputStream;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipInputStream;, +import java.util.zip.ZipOutputStream;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +/**, + * Classes list for import into classpath graph, + */, +public class ClsSet {, +	private static final Logger LOG = LoggerFactory.getLogger(ClsSet.class);, +, +	private static final String CLST_EXTENSION = ".jcst";]
[+++ b/jadx-gui/build.gradle, +    defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +    jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/build.gradle, +    defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +    jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +	private static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();, +++ b/jadx-gui/build.gradle, +    defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +    jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +	private static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +		registerBundledFonts();, +	public static void registerBundledFonts() {, +		GraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();, +		if (FONT_HACK != null) {, +			grEnv.registerFont(FONT_HACK);, +		}, +	}, +, +++ b/jadx-gui/build.gradle, +    defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +    jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +	private static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +		registerBundledFonts();, +	public static void registerBundledFonts() {, +		GraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();, +		if (FONT_HACK != null) {, +			grEnv.registerFont(FONT_HACK);, +		}, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +import java.awt.*;, +import java.io.InputStream;, +import javax.swing.*;, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(Utils.class);, +	private static final ImageIcon ICON_STATIC = openIcon("static_co");, +	private static final ImageIcon ICON_FINAL = openIcon("final_co");, +	private static final ImageIcon ICON_ABSTRACT = openIcon("abstract_co");, +	private static final ImageIcon ICON_NATIVE = openIcon("native_co");, +, +	public static final Font FONT_HACK = openFontTTF("Hack-Regular");, +	@Nullable, +	public static Font openFontTTF(String name) {, +		String fontPath = "/fonts/" + name + ".ttf";, +		try (InputStream is = Utils.class.getResourceAsStream(fontPath)) {, +			Font font = Font.createFont(Font.TRUETYPE_FONT, is);, +			return font.deriveFont(12f);, +		} catch (Exception e) {, +			LOG.error("Failed load font by path: {}", fontPath, e);, +			return null;, +		}, +	}, +, +++ b/jadx-gui/build.gradle, +    defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +    jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +	private static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, +		registerBundledFonts();, +	public static void registerBundledFonts() {, +		GraphicsEnvironment grEnv = GraphicsEnvironment.getLocalGraphicsEnvironment();, +		if (FONT_HACK != null) {, +			grEnv.registerFont(FONT_HACK);, +		}, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +import java.awt.*;, +import java.io.InputStream;, +import javax.swing.*;, +import org.jetbrains.annotations.Nullable;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import static jadx.core.utils.Utils.lockList;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import static jadx.core.utils.Utils.lockList;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import static jadx.core.utils.Utils.lockList;, +, +		exceptionHandlers = Collections.emptyList();, +		loops = Collections.emptyList();, +		blocks = lockList(blocks);, +		exitBlocks = lockList(exitBlocks);, +		loops = lockList(loops);, +		blocks.forEach(BlockNode::lock);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import static jadx.core.utils.Utils.lockList;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import static jadx.core.utils.Utils.lockList;, +, +		exceptionHandlers = Collections.emptyList();, +		loops = Collections.emptyList();, +		blocks = lockList(blocks);, +		exitBlocks = lockList(exitBlocks);, +		loops = lockList(loops);, +		blocks.forEach(BlockNode::lock);, +++ b/jadx-core/src/main/java/jadx/core/utils/ImmutableList.java, +package jadx.core.utils;, +, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +import java.util.ListIterator;, +import java.util.Objects;, +import java.util.RandomAccess;, +import java.util.function.Consumer;, +import java.util.function.Predicate;, +import java.util.function.UnaryOperator;, +, +import org.jetbrains.annotations.NotNull;, +, +/**, + * Simple immutable list implementation, + * Warning: some methods not implemented!, + */, +public final class ImmutableList<E> implements List<E>, RandomAccess {, +	private final E[] arr;, +, +	@SuppressWarnings("unchecked"), +	public ImmutableList(Object[] arr) {, +		this.arr = (E[]) Objects.requireNonNull(arr);, +	}, +, +	@Override, +	public int size() {, +		return arr.length;, +	}, +, +	@Override, +	public boolean isEmpty() {, +		return arr.length == 0;, +	}, +, +	@Override, +	public E get(int index) {, +		return arr[index];, +	}, +, +	@Override, +	public int indexOf(Object o) {, +		int len = arr.length;, +		for (int i = 0; i < len; i++) {, +			E e = arr[i];, +			if (Objects.equals(e, o)) {, +				return i;, +			}, +		}, +		return -1;, +	}, +, +	@Override, +	public int lastIndexOf(Object o) {, +		for (int i = arr.length - 1; i > 0; i--) {, +			E e = arr[i];, +			if (Objects.equals(e, o)) {, +				return i;, +			}, +		}, +		return -1;, +	}, +, +	@Override, +	public boolean contains(Object o) {, +		return indexOf(o) != -1;, +	}, +, +	@Override]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +		res.setContent(makeXmlDump());, +	public CodeWriter makeXmlDump() {, +		CodeWriter writer = new CodeWriter();, +		writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");, +		writer.startLine("<resources>");, +		writer.incIndent();, +, +		for (ResourceEntry ri : resStorage.getResources()) {, +			String format = String.format("<public type=\"%s\" name=\"%s\" id=\"%s\" />",, +					ri.getTypeName(), ri.getKeyName(), ri.getId());, +			writer.startLine(format);, +		}, +		writer.decIndent();, +		writer.startLine("</resources>");, +		writer.finish();, +		return writer;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +		res.setContent(makeXmlDump());, +	public CodeWriter makeXmlDump() {, +		CodeWriter writer = new CodeWriter();, +		writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");, +		writer.startLine("<resources>");, +		writer.incIndent();, +, +		for (ResourceEntry ri : resStorage.getResources()) {, +			String format = String.format("<public type=\"%s\" name=\"%s\" id=\"%s\" />",, +					ri.getTypeName(), ri.getKeyName(), ri.getId());, +			writer.startLine(format);, +		}, +		writer.decIndent();, +		writer.startLine("</resources>");, +		writer.finish();, +		return writer;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java, +			saveToFile(rc, new File(outDir, "res/values/public.xml"));, +		saveToFile(rc, outFile);, +	}, +	, +	private void saveToFile(ResContainer rc, File outFile) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, +						insertLoopBreak(stack, loop, loopExit, exitEdge);, +			if (found && !checkLoopExits(loop, block)) {, +				found = false;, +			}, +	private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, +		List<Edge> exitEdges = loop.getExitEdges();, +		if (exitEdges.size() < 2) {, +			return true;, +		}, +		Optional<Edge> mainEdgeOpt = exitEdges.stream().filter(edge -> edge.getSource() == mainExitBlock).findFirst();, +		if (!mainEdgeOpt.isPresent()) {, +			throw new JadxRuntimeException("Not found exit edge by exit block: " + mainExitBlock);, +		}, +		Edge mainExitEdge = mainEdgeOpt.get();, +		BlockNode mainOutBlock = skipSyntheticSuccessor(mainExitEdge.getTarget());, +		for (Edge exitEdge : exitEdges) {, +			if (exitEdge != mainExitEdge) {, +				BlockNode outBlock = skipSyntheticSuccessor(exitEdge.getTarget());, +				// all exit paths must be same or don't cross (will be inside loop), +				if (!isEqualPaths(mainOutBlock, outBlock)) {, +					BlockNode crossBlock = BlockUtils.getPathCross(mth, mainOutBlock, outBlock);, +					if (crossBlock != null) {, +						return false;, +					}, +				}, +			}, +		}, +		return true;, +	}, +, +			if (insertLoopBreak(stack, loop, exit, exitEdge)) {, +						insertLoopBreak(stack, loop, block, exitEdge);, +						insertLoopBreak(stack, loop, exit, exitEdge);, +	private boolean insertLoopBreak(RegionStack stack, LoopInfo loop, BlockNode loopExit, Edge exitEdge) {, +		breakInsn.addAttr(AType.LOOP, loop);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, +						insertLoopBreak(stack, loop, loopExit, exitEdge);, +			if (found && !checkLoopExits(loop, block)) {, +				found = false;, +			}, +	private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, +		List<Edge> exitEdges = loop.getExitEdges();, +		if (exitEdges.size() < 2) {, +			return true;, +		}, +		Optional<Edge> mainEdgeOpt = exitEdges.stream().filter(edge -> edge.getSource() == mainExitBlock).findFirst();, +		if (!mainEdgeOpt.isPresent()) {, +			throw new JadxRuntimeException("Not found exit edge by exit block: " + mainExitBlock);, +		}, +		Edge mainExitEdge = mainEdgeOpt.get();, +		BlockNode mainOutBlock = skipSyntheticSuccessor(mainExitEdge.getTarget());, +		for (Edge exitEdge : exitEdges) {, +			if (exitEdge != mainExitEdge) {, +				BlockNode outBlock = skipSyntheticSuccessor(exitEdge.getTarget());, +				// all exit paths must be same or don't cross (will be inside loop), +				if (!isEqualPaths(mainOutBlock, outBlock)) {, +					BlockNode crossBlock = BlockUtils.getPathCross(mth, mainOutBlock, outBlock);, +					if (crossBlock != null) {, +						return false;, +					}, +				}, +			}, +		}, +		return true;, +	}, +, +			if (insertLoopBreak(stack, loop, exit, exitEdge)) {, +						insertLoopBreak(stack, loop, block, exitEdge);, +						insertLoopBreak(stack, loop, exit, exitEdge);, +	private boolean insertLoopBreak(RegionStack stack, LoopInfo loop, BlockNode loopExit, Edge exitEdge) {, +		breakInsn.addAttr(AType.LOOP, loop);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMakerVisitor.java, +		if (last instanceof BlockNode) {, +			BlockNode block = (BlockNode) last;, +			if (block.getInstructions().isEmpty()) {, +				block.getInstructions().add(insnAttr.getInsn());, +				return;, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +		if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, +						insertLoopBreak(stack, loop, loopExit, exitEdge);, +			if (found && !checkLoopExits(loop, block)) {, +				found = false;, +			}, +	private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, +		List<Edge> exitEdges = loop.getExitEdges();, +		if (exitEdges.size() < 2) {, +			return true;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +public class JClass extends JLoadableNode {, +	@Override, +	public void loadNode() {, +		getRootClass().load();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +public class JClass extends JLoadableNode {, +	@Override, +	public void loadNode() {, +		getRootClass().load();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JLoadableNode.java, +package jadx.gui.treemodel;, +, +public abstract class JLoadableNode extends JNode {, +	public abstract void loadNode();, +}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +public class JClass extends JLoadableNode {, +	@Override, +	public void loadNode() {, +		getRootClass().load();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JLoadableNode.java, +package jadx.gui.treemodel;, +, +public abstract class JLoadableNode extends JNode {, +	public abstract void loadNode();, +}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java, +import org.jetbrains.annotations.NotNull;, +import jadx.gui.utils.NLS;, +import static jadx.api.ResourceFileContent.createResourceFileContentInstance;, +, +public class JResource extends JLoadableNode implements Comparable<JResource> {, +		this.loaded = false;, +		if (!loaded) {, +			if (type == JResType.DIR, +					|| type == JResType.ROOT, +					|| resFile.getType() == ResourceType.ARSC) {, +				add(new TextNode(NLS.str("tree.loading")));, +			}, +		} else {, +			loadContent();, +	}, +, +	@Override, +	public void loadNode() {, +		loadContent();, +		loaded = true;, +		update();, +	}, +				ResourceFileContent fileContent = createResourceFileContentInstance(resShortName, ResourceType.XML, cw);, +	public int compareTo(@NotNull JResource o) {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +public class JClass extends JLoadableNode {, +	@Override, +	public void loadNode() {, +		getRootClass().load();, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JLoadableNode.java, +package jadx.gui.treemodel;, +, +public abstract class JLoadableNode extends JNode {, +	public abstract void loadNode();, +}, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java, +import org.jetbrains.annotations.NotNull;, +import jadx.gui.utils.NLS;, +import static jadx.api.ResourceFileContent.createResourceFileContentInstance;, +, +public class JResource extends JLoadableNode implements Comparable<JResource> {, +		this.loaded = false;, +		if (!loaded) {, +			if (type == JResType.DIR, +					|| type == JResType.ROOT, +					|| resFile.getType() == ResourceType.ARSC) {, +				add(new TextNode(NLS.str("tree.loading")));, +			}, +		} else {, +			loadContent();, +	}, +, +	@Override, +	public void loadNode() {]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +		res.append('"');, +		res.append('"');, +		return res.toString();, +		res.append('\'');, +		res.append('\'');, +		return res.toString();]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +	private Set<String> getAncestors(String clsName) {, +++ b/.gitignore]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.load(inputFiles);, +, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.load(inputFiles);, +, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public int getIndent() {, +		return indent;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.load(inputFiles);, +, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public int getIndent() {, +		return indent;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +	public List<DexNode> getDexNodes() {, +		return dexNodes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.load(inputFiles);, +, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public int getIndent() {, +		return indent;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +	public List<DexNode> getDexNodes() {, +		return dexNodes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.RootNode;, +	private Map<Integer, String> styleMap = new HashMap<Integer, String>();, +	private Map<Integer, FieldNode> localStyleMap = new HashMap<Integer, FieldNode>();, +	private final ManifestAttributes attributes;, +	public BinaryXMLParser(RootNode root) {, +			// add application constants, +			for (DexNode dexNode : root.getDexNodes()) {, +				for (Map.Entry<Object, FieldNode> entry : dexNode.getConstFields().entrySet()) {, +					Object key = entry.getKey();, +					FieldNode field = entry.getValue();, +					if (field.getType().equals(ArgType.INT) && key instanceof Integer) {, +						localStyleMap.put((Integer) key, field);, +					}, +				}, +			}, +			attributes = new ManifestAttributes();, +			attributes.parse();, +		} catch (Exception e) {, +		writer.startLine("<").add(strings[startNSName]);, +			writer.add(" xmlns:\"").add(nsURI).add("\"");, +				writer.add(nsPrefix).add(':');, +			String attrName = strings[attributeName];, +			writer.add(attrName).add("=\"");, +			String decodedAttr = attributes.decode(attrName, attrValData);, +			if (decodedAttr != null) {, +				writer.add(decodedAttr);, +			} else {, +				switch (attrValDataType) {, +					case 0x3:, +						break;, +, +					case 0x10:, +						break;, +, +					case 0x12:, +						break;, +, +					case 0x1:, +								writer.add(nsPrefix).add(':');, +							writer.add("style/").add(name.replaceAll("_", "."));, +							FieldNode field = localStyleMap.get(attrValData);, +							if (field != null) {, +								String cls = field.getParentClass().getShortName().toLowerCase();, +								writer.add("@").add(cls).add("/").add(field.getName());, +							} else {, +								writer.add("0x").add(Integer.toHexString(attrValData));, +						break;, +, +					default:, +						break;, +			writer.add('"');, +				writer.add(strings[elementNS]).add(':');, +			writer.add(strings[elementName]).add(">");, +		if (writer.getIndent() != 0) {, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +					return true;, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +					return true;, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			if (visitor.enterRegion(mth, region)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +					return true;, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			if (visitor.enterRegion(mth, region)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IRegionVisitor.java, +	/**, +	 * @return true for traverse sub-blocks, false otherwise., +	 */, +	boolean enterRegion(MethodNode mth, IRegion region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +					return true;, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			if (visitor.enterRegion(mth, region)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IRegionVisitor.java, +	/**, +	 * @return true for traverse sub-blocks, false otherwise., +	 */, +	boolean enterRegion(MethodNode mth, IRegion region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {, +					return true;, +				return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +			if (visitor.enterRegion(mth, region)) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IRegionVisitor.java, +	/**, +	 * @return true for traverse sub-blocks, false otherwise., +	 */, +	boolean enterRegion(MethodNode mth, IRegion region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, +	public boolean enterRegion(MethodNode mth, IRegion region) {, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +			public boolean enterRegion(MethodNode mth, IRegion region) {]
[+++ b/jadx-gui/build.gradle, +, +    compile 'org.apache.commons:commons-lang3:3.7', +, +    compile 'io.reactivex.rxjava2:rxjava:2.1.13', +    compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/build.gradle, +, +    compile 'org.apache.commons:commons-lang3:3.7', +, +    compile 'io.reactivex.rxjava2:rxjava:2.1.13', +    compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +	private final transient int lineNum;, +	public CodeNode(JNode jNode, int lineNum, StringRef lineStr) {, +		this.line = lineStr;, +++ b/jadx-gui/build.gradle, +, +    compile 'org.apache.commons:commons-lang3:3.7', +, +    compile 'io.reactivex.rxjava2:rxjava:2.1.13', +    compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +	private final transient int lineNum;, +	public CodeNode(JNode jNode, int lineNum, StringRef lineStr) {, +		this.line = lineStr;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +		String statusText = String.format(, +				NLS.str("search_dialog.info_label"),, +				resultsModel.getDisplayedResultsStart(),, +				resultsModel.getDisplayedResultsEnd(),, +				resultsModel.getResultCount(), +		);, +			rows.addAll(nodes);, +			if (!addDescColumn) {, +				for (JNode row : rows) {, +					if (row.hasDescString()) {, +						break;, +				}, +			}, +			if (rows.isEmpty()) {, +				return 0;, +			}, +			return getDisplayedResultsEnd() - getDisplayedResultsStart();, +++ b/jadx-gui/build.gradle, +, +    compile 'org.apache.commons:commons-lang3:3.7', +, +    compile 'io.reactivex.rxjava2:rxjava:2.1.13', +    compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +	private final transient int lineNum;, +	public CodeNode(JNode jNode, int lineNum, StringRef lineStr) {, +		this.line = lineStr;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +		String statusText = String.format(, +				NLS.str("search_dialog.info_label"),, +				resultsModel.getDisplayedResultsStart(),, +				resultsModel.getDisplayedResultsEnd(),, +				resultsModel.getResultCount(), +		);, +			rows.addAll(nodes);, +			if (!addDescColumn) {, +				for (JNode row : rows) {, +					if (row.hasDescString()) {, +						break;, +				}, +			}, +			if (rows.isEmpty()) {, +				return 0;, +			}, +			return getDisplayedResultsEnd() - getDisplayedResultsStart();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +				new SearchDialog(MainWindow.this, true).setVisible(true);, +				new SearchDialog(MainWindow.this, false).setVisible(true);, +++ b/jadx-gui/build.gradle, +, +    compile 'org.apache.commons:commons-lang3:3.7', +, +    compile 'io.reactivex.rxjava2:rxjava:2.1.13', +    compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +	private final transient int lineNum;, +	public CodeNode(JNode jNode, int lineNum, StringRef lineStr) {, +		this.line = lineStr;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +		String statusText = String.format(, +				NLS.str("search_dialog.info_label"),, +				resultsModel.getDisplayedResultsStart(),, +				resultsModel.getDisplayedResultsEnd(),, +				resultsModel.getResultCount(), +		);, +			rows.addAll(nodes);, +			if (!addDescColumn) {, +				for (JNode row : rows) {, +					if (row.hasDescString()) {, +						break;, +				}, +			}, +			if (rows.isEmpty()) {]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java]
[+++ b/build.gradle, +    id 'org.sonarqube' version '2.7', +        testCompile 'org.hamcrest:hamcrest-library:2.1', +        testCompile 'org.mockito:mockito-core:2.23.4', +++ b/build.gradle, +    id 'org.sonarqube' version '2.7', +        testCompile 'org.hamcrest:hamcrest-library:2.1', +        testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/build.gradle, +    id 'org.sonarqube' version '2.7', +        testCompile 'org.hamcrest:hamcrest-library:2.1', +        testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:7.0', +    compile 'org.jetbrains:annotations:16.0.3', +    compile 'uk.com.robust-it:cloning:1.9.11', +    testCompile 'org.smali:smali:2.2.5', +    testCompile 'org.smali:baksmali:2.2.5', +    testCompile 'org.apache.commons:commons-lang3:3.8.1', +++ b/build.gradle, +    id 'org.sonarqube' version '2.7', +        testCompile 'org.hamcrest:hamcrest-library:2.1', +        testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:7.0', +    compile 'org.jetbrains:annotations:16.0.3', +    compile 'uk.com.robust-it:cloning:1.9.11', +    testCompile 'org.smali:smali:2.2.5', +    testCompile 'org.smali:baksmali:2.2.5', +    testCompile 'org.apache.commons:commons-lang3:3.8.1', +++ b/jadx-core/src/test/java/jadx/tests/api/utils/CountString.java, +import org.hamcrest.TypeSafeMatcher;, +public class CountString extends TypeSafeMatcher<String> {, +	private final String substring;, +		this.substring = substring;, +	protected boolean matchesSafely(String item) {, +		return this.count == count(item);, +	@Override, +	public void describeTo(Description description) {, +		description.appendText("containing <" + count + "> occurrence of ").appendValue(this.substring);, +	}, +, +		return TestUtils.count(string, this.substring);, +++ b/build.gradle, +    id 'org.sonarqube' version '2.7', +        testCompile 'org.hamcrest:hamcrest-library:2.1', +        testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:7.0', +    compile 'org.jetbrains:annotations:16.0.3', +    compile 'uk.com.robust-it:cloning:1.9.11', +    testCompile 'org.smali:smali:2.2.5', +    testCompile 'org.smali:baksmali:2.2.5', +    testCompile 'org.apache.commons:commons-lang3:3.8.1', +++ b/jadx-core/src/test/java/jadx/tests/api/utils/CountString.java, +import org.hamcrest.TypeSafeMatcher;, +public class CountString extends TypeSafeMatcher<String> {, +	private final String substring;, +		this.substring = substring;, +	protected boolean matchesSafely(String item) {, +		return this.count == count(item);, +	@Override, +	public void describeTo(Description description) {, +		description.appendText("containing <" + count + "> occurrence of ").appendValue(this.substring);, +	}, +, +		return TestUtils.count(string, this.substring);, +++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:3.0.0', +    compile 'org.apache.commons:commons-lang3:3.8.1', +    compile 'io.reactivex.rxjava2:rxjava:2.2.5', +    compile "com.github.akarnokd:rxjava2-swing:0.3.3"]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import org.jetbrains.annotations.Nullable;, +		String filledArray = makeArrayElements(insn);, +		code.add("new ");, +		useType(code, insn.getElementType());, +		code.add("[]{").add(filledArray).add('}');, +	}, +, +	private String makeArrayElements(FillArrayNode insn) throws CodegenException {, +		insn.mergeElementType(elType);, +, +		return str.toString();, +		generateMethodArguments(code, insn, 0, mth.dex().resolveMethod(insn.getCallMth()));, +		generateMethodArguments(code, insn, k, callMthNode);, +	private void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +			@Nullable MethodNode callMth) throws CodegenException {, +		int k = startArgNum;, +		if (k < argsCount) {, +			boolean overloaded = callMth != null && callMth.isArgsOverload();, +				boolean cast = overloaded && processOverloadedArg(code, callMth, arg, i - startArgNum);, +				if (!cast && i == argsCount - 1 && processVarArg(code, callMth, arg)) {, +					continue;, +				}, +				addArg(code, arg, false);, +				if (i < argsCount - 1) {, +					code.add(", ");, +				}, +			}, +		}, +		code.add(')');, +	}, +, +	/**, +	 * Add additional cast for overloaded method argument., +	 */, +	private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +			return true;, +		return false;, +	}, +, +	/**, +	 * Expand varArgs from filled array., +	 */, +	private boolean processVarArg(CodeWriter code, MethodNode callMth, InsnArg lastArg) throws CodegenException {, +		if (callMth == null || !callMth.getAccessFlags().isVarArgs()) {, +			return false;, +		}, +		if (!lastArg.getType().isArray() || !lastArg.isInsnWrap()) {, +			return false;, +		}, +		InsnNode insn = ((InsnWrapArg) lastArg).getWrapInsn();, +		if (insn.getType() == InsnType.FILLED_NEW_ARRAY) {, +			int count = insn.getArgsCount();, +			for (int i = 0; i < count; i++) {, +				InsnArg elemArg = insn.getArg(i);, +				addArg(code, elemArg, false);, +				if (i < count - 1) {, +			return true;, +		} else if (insn.getType() == InsnType.FILL_ARRAY) {, +			code.add(makeArrayElements((FillArrayNode) insn));, +			return true;, +		return false;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import org.jetbrains.annotations.Nullable;, +		String filledArray = makeArrayElements(insn);, +		code.add("new ");, +		useType(code, insn.getElementType());, +		code.add("[]{").add(filledArray).add('}');, +	}, +, +	private String makeArrayElements(FillArrayNode insn) throws CodegenException {, +		insn.mergeElementType(elType);, +, +		return str.toString();, +		generateMethodArguments(code, insn, 0, mth.dex().resolveMethod(insn.getCallMth()));, +		generateMethodArguments(code, insn, k, callMthNode);, +	private void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +			@Nullable MethodNode callMth) throws CodegenException {, +		int k = startArgNum;, +		if (k < argsCount) {, +			boolean overloaded = callMth != null && callMth.isArgsOverload();, +				boolean cast = overloaded && processOverloadedArg(code, callMth, arg, i - startArgNum);, +				if (!cast && i == argsCount - 1 && processVarArg(code, callMth, arg)) {, +					continue;, +				}, +				addArg(code, arg, false);, +				if (i < argsCount - 1) {, +					code.add(", ");, +				}, +			}, +		}, +		code.add(')');, +	}, +, +	/**, +	 * Add additional cast for overloaded method argument., +	 */, +	private boolean processOverloadedArg(CodeWriter code, MethodNode callMth, InsnArg arg, int origPos) {, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		return "LOOP: " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		return "LOOP: " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			Region body = makeRegion(loopBody, stack);, +			// add blocks from loop start to first condition block, +			BlockNode conditionBlock = condInfo.getIfBlock();, +			if (loopStart != conditionBlock) {, +				Set<BlockNode> blocks = BlockUtils.getAllPathsBlocks(loopStart, conditionBlock);, +				blocks.remove(conditionBlock);, +				for (BlockNode block : blocks) {, +					if (block.getInstructions().isEmpty(), +							&& !block.contains(AFlag.SKIP), +							&& !RegionUtils.isRegionContainsBlock(body, block)) {, +						body.add(block);, +					}, +				}, +			}, +			loopRegion.setBody(body);, +					List<BlockNode> s = splitter.getSuccessors();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		return "LOOP: " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			Region body = makeRegion(loopBody, stack);, +			// add blocks from loop start to first condition block, +			BlockNode conditionBlock = condInfo.getIfBlock();, +			if (loopStart != conditionBlock) {, +				Set<BlockNode> blocks = BlockUtils.getAllPathsBlocks(loopStart, conditionBlock);, +				blocks.remove(conditionBlock);, +				for (BlockNode block : blocks) {, +					if (block.getInstructions().isEmpty(), +							&& !block.contains(AFlag.SKIP), +							&& !RegionUtils.isRegionContainsBlock(body, block)) {, +						body.add(block);, +					}, +				}, +			}, +			loopRegion.setBody(body);, +					List<BlockNode> s = splitter.getSuccessors();, +++ b/jadx-core/src/test/java/jadx/tests/internal/others/TestLoopInTry2.java, +package jadx.tests.internal.others;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.utils.exceptions.DecodeException;, +, +import java.io.EOFException;, +, +import org.junit.Test;, +, +import com.android.dex.Code;, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopInTry2 extends InternalJadxTest {, +, +	public static class TestCls {, +		private MethodNode method;, +		private DexNode dex;, +		private DecodedInstruction[] insnArr;, +, +		public void test(Code mthCode) throws DecodeException {, +			short[] encodedInstructions = mthCode.getInstructions();, +			int size = encodedInstructions.length;, +			DecodedInstruction[] decoded = new DecodedInstruction[size];, +			ShortArrayCodeInput in = new ShortArrayCodeInput(encodedInstructions);, +			try {, +				while (in.hasMore()) {, +					decoded[in.cursor()] = DecodedInstruction.decode(in);, +				}, +			} catch (EOFException e) {, +				throw new DecodeException(method, "", e);, +			}, +			insnArr = decoded;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsOne("try {"));, +		assertThat(code, containsOne("while (in.hasMore()) {"));, +		assertThat(code, containsOne("decoded[in.cursor()] = DecodedInstruction.decode(in);"));, +		assertThat(code, containsOne("} catch (EOFException e) {"));, +		assertThat(code, containsOne("throw new DecodeException"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, +	public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, +	public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +public class InvokeNode extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, +	public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +public class InvokeNode extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +import jadx.core.dex.instructions.CallMthInterface;, +public class ConstructorInsn extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, +	public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +public class InvokeNode extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +import jadx.core.dex.instructions.CallMthInterface;, +public class ConstructorInsn extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.*;, +	/**, +	 * Simplify chains of calls to StringBuilder#append() plus constructor of StringBuilder., +	 * Those chains are usually automatically generated by the Java compiler when you create String, +	 * concatenations like <code>"text " + 1 + " text"</code>., +	 *, +	 * @param mth, +	 * @param insn, +	 * @return, +	 */, +							InsnNode node = chain.get(argInd);, +							MethodInfo method = ((CallMthInterface) node).getCallMth();, +							if (!(node.getArgsCount() < 2 && method.isConstructor() || method.getName().equals("append"))) {, +								// The chain contains other calls to StringBuilder methods than the constructor or append., +								// We can't simplify such chains, therefore we leave them as they are., +								return null;, +							}, +							// process only constructor and append() calls, +							concatInsn.addArg(node.getArg(1));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, +	public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +public class InvokeNode extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +import jadx.core.dex.instructions.CallMthInterface;, +public class ConstructorInsn extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.*;, +	/**, +	 * Simplify chains of calls to StringBuilder#append() plus constructor of StringBuilder., +	 * Those chains are usually automatically generated by the Java compiler when you create String, +	 * concatenations like <code>"text " + 1 + " text"</code>., +	 *, +	 * @param mth, +	 * @param insn, +	 * @return, +	 */, +							InsnNode node = chain.get(argInd);, +							MethodInfo method = ((CallMthInterface) node).getCallMth();, +							if (!(node.getArgsCount() < 2 && method.isConstructor() || method.getName().equals("append"))) {, +								// The chain contains other calls to StringBuilder methods than the constructor or append., +								// We can't simplify such chains, therefore we leave them as they are., +								return null;, +							}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			JadxErrorAttr errorAttr = mth.get(AType.JADX_ERROR);, +			if (errorAttr == null, +					|| errorAttr.getCause() == null, +					|| !errorAttr.getCause().getClass().equals(DecodeException.class)) {, +					code.startLine("// Can't load method instructions: " + e.getMessage());, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			JadxErrorAttr errorAttr = mth.get(AType.JADX_ERROR);, +			if (errorAttr == null, +					|| errorAttr.getCause() == null, +					|| !errorAttr.getCause().getClass().equals(DecodeException.class)) {, +					code.startLine("// Can't load method instructions: " + e.getMessage());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			} catch (Exception e) {, +				LOG.error("Method load error:", e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			JadxErrorAttr errorAttr = mth.get(AType.JADX_ERROR);, +			if (errorAttr == null, +					|| errorAttr.getCause() == null, +					|| !errorAttr.getCause().getClass().equals(DecodeException.class)) {, +					code.startLine("// Can't load method instructions: " + e.getMessage());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			} catch (Exception e) {, +				LOG.error("Method load error:", e);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +					&& mth.getArguments(false).isEmpty(), +					&& !mth.contains(AType.JADX_ERROR)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +, +		RegisterArg activeReg = (RegisterArg) activeRegisters[var.getRegNum()];, +		if (activeReg != null) {, +			SSAVar ssaVar = activeReg.getSVar();, +			if ((ssaVar != null) && (ssaVar.getStartAddr() != -1)) {, +				if (ssaVar.getAssign() != null) {, +					if (ssaVar.getAssign().getParentInsn() != null) {, +						if (ssaVar.getAssign().getParentInsn().getOffset() >= 0) {, +							addr = ssaVar.getAssign().getParentInsn().getOffset();, +						}, +					}, +				}, +			}, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +, +		RegisterArg activeReg = (RegisterArg) activeRegisters[var.getRegNum()];, +		if (activeReg != null) {, +			SSAVar ssaVar = activeReg.getSVar();, +			if ((ssaVar != null) && (ssaVar.getStartAddr() != -1)) {, +				if (ssaVar.getAssign() != null) {, +					if (ssaVar.getAssign().getParentInsn() != null) {, +						if (ssaVar.getAssign().getParentInsn().getOffset() >= 0) {, +							addr = ssaVar.getAssign().getParentInsn().getOffset();, +						}, +					}, +				}, +			}, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.utils.InsnUtils;, +				ArgType castArgType = castArg.getType();, +, +				/*, +				 * Don't removes CHECK_CAST for wrapped INVOKE, +				 * if invoked method returns different type, +				 */, +				if (castArg.isInsnWrap()) {, +					InsnWrapArg castWrapArg = (InsnWrapArg) castArg;, +					InsnNode wrapInsn = castWrapArg.getWrapInsn();, +, +					if (wrapInsn.getType() == InsnType.INVOKE) {, +						InvokeNode invkInsn = (InvokeNode) wrapInsn;, +						castArgType = invkInsn.getCallMth().getReturnType();, +, +						if (invkInsn.getResult().getType(), +								!= invkInsn.getCallMth().getReturnType()) {, +							LOG.warn("Invoke without cast at {} in {}", InsnUtils.formatOffset(invkInsn.getOffset()), mth);, +						}, +					}, +				}, +, +				if (!ArgType.isCastNeeded(castArgType, castType)) {, +					insnNode.setOffset(insn.getOffset());]
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			LOG.info("Loaded: {}", inputFile.getFile());, +		LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			LOG.info("Loaded: {}", inputFile.getFile());, +		LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		} else if (val instanceof Iterable) {, +			Iterator<?> it = ((Iterable) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			LOG.info("Loaded: {}", inputFile.getFile());, +		LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		} else if (val instanceof Iterable) {, +			Iterator<?> it = ((Iterable) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.Named;, +			code.add(((Named) arg).getName());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			LOG.info("Loaded: {}", inputFile.getFile());, +		LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		} else if (val instanceof Iterable) {, +			Iterator<?> it = ((Iterable) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.Named;, +			code.add(((Named) arg).getName());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					LOG.warn("Several 'all' handlers in try/catch block in {}", mth);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			LOG.info("Loaded: {}", inputFile.getFile());, +		LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		} else if (val instanceof Iterable) {, +			Iterator<?> it = ((Iterable) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.Named;, +			code.add(((Named) arg).getName());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					LOG.warn("Several 'all' handlers in try/catch block in {}", mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +		// not allowed, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);, +			LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			LOG.info("Loaded: {}", inputFile.getFile());, +		LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		} else if (val instanceof Iterable) {, +			Iterator<?> it = ((Iterable) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.Named;, +			code.add(((Named) arg).getName());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					LOG.warn("Several 'all' handlers in try/catch block in {}", mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +		// not allowed, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				LOG.error("Error parsing annotations in {}", this, e);, +			LOG.error("Class signature parse error: {}", this, e);, +					LOG.error("Field signature parse error: {}", field, e);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +			LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +			LOG.warn("Class not found: {}", fullName);]
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ b/.travis.yml, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, +		List<BlockNode> successors = curBlock.getSuccessors();, +		thenBlock = getBlockByOffset(target, successors);, +		if (successors.size() == 1) {, +			elseBlock = selectOther(thenBlock, successors);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, +		List<BlockNode> successors = curBlock.getSuccessors();, +		thenBlock = getBlockByOffset(target, successors);, +		if (successors.size() == 1) {, +			elseBlock = selectOther(thenBlock, successors);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import java.util.Objects;, +		if (Objects.equals(thenBlock, elseBlock)) {, +			IfInfo ifInfo = new IfInfo(info, null, null);, +			ifInfo.setOutBlock(thenBlock);, +			return ifInfo;, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, +		List<BlockNode> successors = curBlock.getSuccessors();, +		thenBlock = getBlockByOffset(target, successors);, +		if (successors.size() == 1) {, +			elseBlock = selectOther(thenBlock, successors);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import java.util.Objects;, +		if (Objects.equals(thenBlock, elseBlock)) {, +			IfInfo ifInfo = new IfInfo(info, null, null);, +			ifInfo.setOutBlock(thenBlock);, +			return ifInfo;, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +	private BitSet processedBlocks;, +		this.processedBlocks = new BitSet(mth.getBasicBlocks().size());, +		Region r = new Region(stack.peekRegion());, +		if (startBlock == null) {, +			return r;, +		int startBlockId = startBlock.getId();, +		if (processedBlocks.get(startBlockId)) {, +			mth.addWarn("Removed duplicated region for block: " + startBlock + " " + startBlock.getAttributesString());, +			return r;, +		}, +		processedBlocks.set(startBlockId);, +, +			processedBlocks.clear(loopStart.getId());, +		processedBlocks.clear(loopStart.getId());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, +		List<BlockNode> successors = curBlock.getSuccessors();, +		thenBlock = getBlockByOffset(target, successors);, +		if (successors.size() == 1) {, +			elseBlock = selectOther(thenBlock, successors);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import java.util.Objects;, +		if (Objects.equals(thenBlock, elseBlock)) {, +			IfInfo ifInfo = new IfInfo(info, null, null);, +			ifInfo.setOutBlock(thenBlock);, +			return ifInfo;, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +	private BitSet processedBlocks;, +		this.processedBlocks = new BitSet(mth.getBasicBlocks().size());, +		Region r = new Region(stack.peekRegion());, +		if (startBlock == null) {, +			return r;, +		int startBlockId = startBlock.getId();, +		if (processedBlocks.get(startBlockId)) {, +			mth.addWarn("Removed duplicated region for block: " + startBlock + " " + startBlock.getAttributesString());, +			return r;, +		}, +		processedBlocks.set(startBlockId);, +, +			processedBlocks.clear(loopStart.getId());, +		processedBlocks.clear(loopStart.getId());, +++ b/jadx-core/src/test/java/jadx/tests/integration/TestWrongCode.java, +import static jadx.tests.api.utils.JadxMatchers.containsLines;, +		assertThat(code, containsLines(2,, +				"if (a == 0) {",, +				"}",, +				"return a;", +		));]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import java.util.EnumSet;, +import java.util.HashSet;, +import java.util.Locale;, +import java.util.Set;, +import com.beust.jcommander.IStringConverter;, +import com.beust.jcommander.Parameter;, +, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import jadx.api.JadxArgs.RENAME;, +	@Parameter(names = {"--rename-flags"}, description = "what to rename, comma-separated, 'case' for system case sensitivity, 'valid' for java identifiers, 'printable' characters, 'none' or 'all'",, +			converter = RenameConverter.class), +	protected Set<RENAME> renameFlags = EnumSet.allOf(RENAME.class);, +, +		args.setRenameCaseSensitive(isRenameCaseSensitive());, +		args.setRenameValid(isRenameValid());, +		args.setRenamePrintable(isRenamePrintable());, +, +	public boolean isRenameCaseSensitive() {, +		return renameFlags.contains(RENAME.CASE);, +	}, +, +	public void setRenameCaseSensitive(boolean renameCase) {, +		if (renameCase && !isRenameCaseSensitive()) {, +			renameFlags.add(RENAME.CASE);, +		} else if (!renameCase && isRenameCaseSensitive()) {, +			renameFlags.remove(RENAME.CASE);, +		}, +	}, +, +	public boolean isRenameValid() {, +		return renameFlags.contains(RENAME.VALID);, +	}, +, +	public void setRenameValid(boolean renameValid) {, +		if (renameValid && !isRenameValid()) {, +			renameFlags.add(RENAME.VALID);, +		} else if (!renameValid && isRenameValid()) {, +			renameFlags.remove(RENAME.VALID);, +		}, +	}, +, +	public boolean isRenamePrintable() {, +		return renameFlags.contains(RENAME.PRINTABLE);, +	}, +, +	public void setRenamePrintable(boolean renamePrintable) {, +		if (renamePrintable && !isRenamePrintable()) {, +			renameFlags.add(RENAME.PRINTABLE);, +		} else if (!renamePrintable && isRenamePrintable()) {, +			renameFlags.remove(RENAME.PRINTABLE);, +		}, +	}, +, +	static class RenameConverter implements IStringConverter<Set<RENAME>> {, +, +		private final String paramName;, +, +		RenameConverter(String paramName) {, +			this.paramName = paramName;, +		}, +, +		@Override, +		public Set<RENAME> convert(String value) {, +			Set<RENAME> set = new HashSet<>();, +			if (value.equalsIgnoreCase("ALL")) {, +				set.add(RENAME.CASE);, +				set.add(RENAME.VALID);, +				set.add(RENAME.PRINTABLE);, +			} else if (!value.equalsIgnoreCase("NONE")) {, +				for (String s : value.split(",")) {, +					try {, +						set.add(RENAME.valueOf(s.toUpperCase(Locale.ROOT)));, +					} catch (IllegalArgumentException e) {, +						String values = "'" + RENAME.CASE, +								+ "', '" + RENAME.VALID, +								+ "' and '" + RENAME.PRINTABLE + '\'';, +						throw new IllegalArgumentException(, +								s + " is unknown for parameter " + paramName, +								+ ", possible values are " + values.toLowerCase(Locale.ROOT));, +					}, +				}, +			}, +			return set;, +		}, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import java.util.EnumSet;, +import java.util.HashSet;, +import java.util.Locale;, +import java.util.Set;, +import com.beust.jcommander.IStringConverter;, +import com.beust.jcommander.Parameter;, +, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import jadx.api.JadxArgs.RENAME;, +	@Parameter(names = {"--rename-flags"}, description = "what to rename, comma-separated, 'case' for system case sensitivity, 'valid' for java identifiers, 'printable' characters, 'none' or 'all'",, +			converter = RenameConverter.class)]
[+++ /dev/null]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, +    testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, +    testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +	/**, +	 * Run auto check method if defined:, +	 * <pre>, +	 *     public static void check(), +	 * </pre>, +	 */, +	public static final String CHECK_METHOD_NAME = "check";, +, +				checkMth = origCls.getMethod(CHECK_METHOD_NAME);, +				rethrow("Original check failed", ie);, +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, +    testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +	/**, +	 * Run auto check method if defined:, +	 * <pre>, +	 *     public static void check(), +	 * </pre>, +	 */, +	public static final String CHECK_METHOD_NAME = "check";, +, +				checkMth = origCls.getMethod(CHECK_METHOD_NAME);, +				rethrow("Original check failed", ie);, +++ b/jadx-core/src/test/java/jadx/tests/external/.gitignore, +/ExternalTests.java, +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, +    testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +	/**, +	 * Run auto check method if defined:, +	 * <pre>, +	 *     public static void check(), +	 * </pre>, +	 */, +	public static final String CHECK_METHOD_NAME = "check";, +, +				checkMth = origCls.getMethod(CHECK_METHOD_NAME);, +				rethrow("Original check failed", ie);, +++ b/jadx-core/src/test/java/jadx/tests/external/.gitignore, +/ExternalTests.java, +++ b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java, +package jadx.tests.external;, +, +import java.io.File;, +import java.util.List;, +import java.util.regex.Pattern;, +, +import org.apache.commons.lang3.StringUtils;, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.JadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.api.JavaClass;, +import jadx.core.Jadx;, +import jadx.core.codegen.CodeGen;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import jadx.tests.api.IntegrationTest;, +, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertThat;, +, +public abstract class BaseExternalTest extends IntegrationTest {, +	private static final Logger LOG = LoggerFactory.getLogger(BaseExternalTest.class);, +, +	protected abstract String getSamplesDir();, +, +	protected JadxArgs prepare(String inputFile) {, +		JadxArgs args = new JadxArgs();, +		args.getInputFiles().add(new File(getSamplesDir(), inputFile));, +		args.setOutDir(new File("../jadx-external-tests-tmp"));, +		return args;, +	}, +, +	protected void decompile(JadxArgs jadxArgs) {, +		decompile(jadxArgs, null, null);, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			MethodGen mthGen = new MethodGen(this, mth);, +			MethodGen mthGen;, +			if (badCode || mth.contains(AType.JADX_ERROR)) {, +				mthGen = MethodGen.getFallbackMethodGen(mth);, +			} else {, +				mthGen = new MethodGen(this, mth);, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			MethodGen mthGen = new MethodGen(this, mth);, +			MethodGen mthGen;, +			if (badCode || mth.contains(AType.JADX_ERROR)) {, +				mthGen = MethodGen.getFallbackMethodGen(mth);, +			} else {, +				mthGen = new MethodGen(this, mth);, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.contains(AType.JADX_ERROR), +				|| mth.contains(AFlag.INCONSISTENT_CODE), +				|| mth.getRegion() == null) {, +			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), +					.add(mth.toString()), +					.add("\");");, +			if (mth.contains(AType.JADX_ERROR)) {, +			}, +			RegionGen regionGen = new RegionGen(this);, +			regionGen.makeRegion(code, mth.getRegion());, +			code.startLine(nameGen.useArg(mth.getThisArg())).add(" = this;");, +	static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			MethodGen mthGen = new MethodGen(this, mth);, +			MethodGen mthGen;, +			if (badCode || mth.contains(AType.JADX_ERROR)) {, +				mthGen = MethodGen.getFallbackMethodGen(mth);, +			} else {, +				mthGen = new MethodGen(this, mth);, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		if (mth.contains(AType.JADX_ERROR), +				|| mth.contains(AFlag.INCONSISTENT_CODE), +				|| mth.getRegion() == null) {, +			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), +					.add(mth.toString()), +					.add("\");");, +			if (mth.contains(AType.JADX_ERROR)) {, +			}, +			RegionGen regionGen = new RegionGen(this);, +			regionGen.makeRegion(code, mth.getRegion());, +			code.startLine(nameGen.useArg(mth.getThisArg())).add(" = this;");, +	static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			if (name != null && !name.equals("this")) {]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				if (!classNode.contains(AFlag.DONT_GENERATE)) {, +			}, +		ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				if (!classNode.contains(AFlag.DONT_GENERATE)) {, +			}, +		ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, +		if (!generateCode && cls.getState() == PROCESSED) {, +				if (cls.getState() == PROCESSED && generateCode) {, +					CodeGen.generate(cls);, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, false));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				if (!classNode.contains(AFlag.DONT_GENERATE)) {, +			}, +		ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, +		if (!generateCode && cls.getState() == PROCESSED) {, +				if (cls.getState() == PROCESSED && generateCode) {, +					CodeGen.generate(cls);, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		return clsCode.finish();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				if (!classNode.contains(AFlag.DONT_GENERATE)) {, +			}, +		ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, +		if (!generateCode && cls.getState() == PROCESSED) {, +				if (cls.getState() == PROCESSED && generateCode) {, +					CodeGen.generate(cls);, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		return clsCode.finish();, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +import jadx.core.dex.attributes.AFlag;, +	public static void generate(ClassNode cls) throws CodegenException {, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			cls.setCode(CodeWriter.EMPTY);, +		} else {, +			cls.setCode(clsGen.makeClass());, +		}, +	}, +, +	private CodeGen() {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				if (!classNode.contains(AFlag.DONT_GENERATE)) {, +			}, +		ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, +		if (!generateCode && cls.getState() == PROCESSED) {, +				if (cls.getState() == PROCESSED && generateCode) {, +					CodeGen.generate(cls);, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		return clsCode.finish();, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +import jadx.core.dex.attributes.AFlag;, +	public static void generate(ClassNode cls) throws CodegenException {, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			cls.setCode(CodeWriter.EMPTY);, +		} else {, +			cls.setCode(clsGen.makeClass());, +		}, +	}, +, +	private CodeGen() {, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public static final CodeWriter EMPTY = new CodeWriter().finish();, +, +	public CodeWriter finish() {, +		return this;, +		if (buf.length() > len && buf.substring(0, len).equals(NL)) {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				if (!classNode.contains(AFlag.DONT_GENERATE)) {, +			}, +		ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, +		if (!generateCode && cls.getState() == PROCESSED) {, +				if (cls.getState() == PROCESSED && generateCode) {, +					CodeGen.generate(cls);, +		cls.getDependencies().forEach(depCls -> process(depCls, passes, false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		return clsCode.finish();, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +import jadx.core.dex.attributes.AFlag;, +	public static void generate(ClassNode cls) throws CodegenException {, +		if (cls.contains(AFlag.DONT_GENERATE)) {, +			cls.setCode(CodeWriter.EMPTY);, +		} else {, +			cls.setCode(clsGen.makeClass());, +		}, +	}, +]
[+++ b/.travis.yml, +env:, +    - TERM=dumb, +, +, +    - ./gradlew clean build dist, +, +after_success:, +    - ./gradlew jacocoTestReport coveralls, +, +++ b/.travis.yml, +env:, +    - TERM=dumb, +, +, +    - ./gradlew clean build dist, +, +after_success:, +    - ./gradlew jacocoTestReport coveralls, +, +++ b/README.md, +, +[![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx), +[![Build Status](https://drone.io/github.com/skylot/jadx/status.png)](https://drone.io/github.com/skylot/jadx/latest), +[![Coverage Status](https://coveralls.io/repos/skylot/jadx/badge.png)](https://coveralls.io/r/skylot/jadx), +, +*Copyright 2014 by Skylot*, +++ b/.travis.yml, +env:, +    - TERM=dumb, +, +, +    - ./gradlew clean build dist, +, +after_success:, +    - ./gradlew jacocoTestReport coveralls, +, +++ b/README.md, +, +[![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx), +[![Build Status](https://drone.io/github.com/skylot/jadx/status.png)](https://drone.io/github.com/skylot/jadx/latest), +[![Coverage Status](https://coveralls.io/repos/skylot/jadx/badge.png)](https://coveralls.io/r/skylot/jadx), +, +*Copyright 2014 by Skylot*, +++ b/build.gradle, +    apply plugin: 'coveralls', +        compile 'org.slf4j:slf4j-api:1.7.7', +        testCompile 'ch.qos.logback:logback-classic:1.1.2', +, +    jacocoTestReport {, +        reports {, +            xml.enabled = true // coveralls plugin depends on xml format report, +            html.enabled = true, +        }, +    }, +}, +, +// setup coveralls (http://coveralls.io/), +// see http://github.com/kt3k/coveralls-gradle-plugin, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +, +    dependencies {, +        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.4.0', +    }, +    gradleVersion = '1.12', +++ b/.travis.yml, +env:, +    - TERM=dumb, +, +, +    - ./gradlew clean build dist, +, +after_success:, +    - ./gradlew jacocoTestReport coveralls, +, +++ b/README.md, +, +[![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx), +[![Build Status](https://drone.io/github.com/skylot/jadx/status.png)](https://drone.io/github.com/skylot/jadx/latest), +[![Coverage Status](https://coveralls.io/repos/skylot/jadx/badge.png)](https://coveralls.io/r/skylot/jadx), +, +*Copyright 2014 by Skylot*, +++ b/build.gradle, +    apply plugin: 'coveralls', +        compile 'org.slf4j:slf4j-api:1.7.7', +        testCompile 'ch.qos.logback:logback-classic:1.1.2', +, +    jacocoTestReport {, +        reports {, +            xml.enabled = true // coveralls plugin depends on xml format report, +            html.enabled = true, +        }, +    }, +}, +, +// setup coveralls (http://coveralls.io/), +// see http://github.com/kt3k/coveralls-gradle-plugin]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		// remove classes which are parents for test class, +			if (!next.getName().contains(cls.getSimpleName())) {, +		for (File clsFile : files) {, +			clsFile.deleteOnExit();, +		}, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		// remove classes which are parents for test class, +			if (!next.getName().contains(cls.getSimpleName())) {, +		for (File clsFile : files) {, +			clsFile.deleteOnExit();, +		}, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/StaticCompiler.java, +			super(file.toURI(), kind);]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			return StringUtils.escape(shortName.toLowerCase());]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +			// TODO: don't store binary files in memory, +		} catch (Exception e) {, +			LOG.warn("Contents of the binary resource '{}' not saved, got exception", name, e);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +			// TODO: don't store binary files in memory, +		} catch (Exception e) {, +			LOG.warn("Contents of the binary resource '{}' not saved, got exception", name, e);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java, +import jadx.core.utils.files.FileUtils;, +				FileUtils.makeDirsForFile(outFile);, +				try (FileOutputStream binaryFileStream = new FileOutputStream(outFile)) {, +				} finally {, +			} catch (Exception e) {, +				LOG.warn("Resource '{}' not saved, got exception", rc.getName(), e);]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.MethodNode;, +	private final MethodNode mth;, +	public NameGen(MethodNode mth, boolean fallback) {, +		this.mth = mth;, +			varName = guessName(arg);, +	private String guessName(RegisterArg arg) {, +		SSAVar sVar = arg.getSVar();, +		if (sVar != null && sVar.getName() == null) {, +			RegisterArg assignArg = sVar.getAssign();, +			InsnNode assignInsn = assignArg.getParentInsn();, +			if (assignInsn != null) {, +				String name = makeNameFromInsn(assignInsn);, +				if (name != null && !NameMapper.isReserved(name)) {, +					assignArg.setName(name);, +					return name;, +				}, +			}, +		}, +		return makeNameForType(arg.getType());, +	}, +, +	private String makeNameForType(ArgType type) {, +	private String makeNameForObject(ArgType type) {, +			ClassInfo clsInfo = ClassInfo.fromType(mth.dex(), type);, +	private String makeNameFromInsn(InsnNode insn) {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.MethodNode;, +	private final MethodNode mth;, +	public NameGen(MethodNode mth, boolean fallback) {, +		this.mth = mth;, +			varName = guessName(arg);, +	private String guessName(RegisterArg arg) {, +		SSAVar sVar = arg.getSVar();, +		if (sVar != null && sVar.getName() == null) {, +			RegisterArg assignArg = sVar.getAssign();, +			InsnNode assignInsn = assignArg.getParentInsn();, +			if (assignInsn != null) {, +				String name = makeNameFromInsn(assignInsn);, +				if (name != null && !NameMapper.isReserved(name)) {, +					assignArg.setName(name);, +					return name;, +				}, +			}, +		}, +		return makeNameForType(arg.getType());, +	}, +, +	private String makeNameForType(ArgType type) {, +	private String makeNameForObject(ArgType type) {, +			ClassInfo clsInfo = ClassInfo.fromType(mth.dex(), type);, +	private String makeNameFromInsn(InsnNode insn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private ClassInfo(DexNode dex, ArgType type) {, +		if (!type.isObject()) {, +			throw new JadxRuntimeException("Not class type: " + type);, +		}, +		splitNames(dex, true);, +	}, +, +	public static ClassInfo fromType(DexNode dex, ArgType type) {, +		ClassInfo cls = dex.getInfoStorage().getCls(type);, +		if (cls != null) {, +			return cls;, +		}, +		cls = new ClassInfo(dex, type);, +		return dex.getInfoStorage().putCls(cls);, +		return fromType(dex, type);, +	public static ClassInfo fromName(DexNode dex, String clsName) {, +		return fromType(dex, ArgType.object(clsName));, +	private void splitNames(DexNode dex, boolean canBeInner) {, +			parentClass = fromName(dex, parClsName);]
[+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +import jadx.api.JadxDecompiler;, +, +import java.util.Arrays;, +	public static final String JADX_API_PACKAGE = JadxDecompiler.class.getPackage().getName();, +, +		filterRecursive(throwable);, +	private static void filterRecursive(Throwable th) {, +		try {, +			filter(th);, +		} catch (Exception e) {, +			// ignore filter exceptions, +		}, +		Throwable cause = th.getCause();, +		if (cause != null) {, +			filterRecursive(cause);, +		}, +	}, +, +	private static void filter(Throwable th) {, +		StackTraceElement[] stackTrace = th.getStackTrace();, +		int cutIndex = -1;, +		int length = stackTrace.length;, +		for (int i = 0; i < length; i++) {, +			StackTraceElement stackTraceElement = stackTrace[i];, +			if (stackTraceElement.getClassName().startsWith(JADX_API_PACKAGE)) {, +				cutIndex = i;, +			} else if (cutIndex > 0) {, +				cutIndex = i;, +				break;, +			}, +		}, +		if (cutIndex > 0 && cutIndex < length) {, +			th.setStackTrace(Arrays.copyOfRange(stackTrace, 0, cutIndex));, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		boolean firstArg = true;, +				if (!firstArg) {, +				firstArg = false;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		boolean firstArg = true;, +				if (!firstArg) {, +				firstArg = false;, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java, +package jadx.tests.integration.invoke;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestConstructorInvoke extends IntegrationTest {, +, +	public class TestCls {, +		void test(String root, String name) {, +			ViewHolder viewHolder = new ViewHolder(root, name);, +		}, +, +		private final class ViewHolder {, +			private int mElements = 0;, +			private final String mRoot;, +			private String mName;, +, +			private ViewHolder(String root, String name) {, +				this.mRoot = root;, +				this.mName = name;, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestConstructorInvoke.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("new ViewHolder(root, name);"));, +	}, +}]
[+++ b/README.md, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.close;, +		if (fileName.endsWith(".apk") || fileName.endsWith(".zip")) {]
[+++ b/.travis.yml, +language: java, +jdk:, +    - oraclejdk7, +    - openjdk7, +    - openjdk6, +script: gradle clean build samples, +notifications:, +    email:, +        - skylot@gmail.com, +++ b/.travis.yml, +language: java, +jdk:, +    - oraclejdk7, +    - openjdk7, +    - openjdk6, +script: gradle clean build samples, +notifications:, +    email:, +        - skylot@gmail.com, +++ b/README.md, +### Build  [![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx)]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.isApkFile;, +import static jadx.core.utils.files.FileUtils.isZipDexFile;, +, +import java.nio.file.Files;, +import java.nio.file.Path;, +import com.android.dex.Dex;, +, +			for (Dex dex : loadFromClassFile(file)) {, +				addDexFile(dex);, +			}, +				for (Dex dex : loadFromJar(file.toPath())) {, +					addDexFile(dex);, +				}, +								Path jarFile = Files.createTempFile(entryName, ".jar");, +								Files.copy(inputStream, jarFile);, +								for (Dex dex : loadFromJar(jarFile)) {, +									addDexFile(entryName, dex);, +	private static List<Dex> loadFromJar(Path jar) throws DecodeException {, +			LOG.info("converting to dex: {} ...", jar.getFileName());, +			List<byte[]> byteList = j2d.convert(jar);, +			if (byteList.isEmpty()) {, +			List<Dex> dexList = new ArrayList<>(byteList.size());, +			for (byte[] b : byteList) {, +				dexList.add(new Dex(b));, +			}, +			return dexList;, +	private static List<Dex> loadFromClassFile(File file) throws IOException, DecodeException {, +		Path outFile = Files.createTempFile("cls", ".jar");, +		try (JarOutputStream jo = new JarOutputStream(Files.newOutputStream(outFile))) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.isApkFile;, +import static jadx.core.utils.files.FileUtils.isZipDexFile;, +, +import java.nio.file.Files;, +import java.nio.file.Path;, +import com.android.dex.Dex;, +, +			for (Dex dex : loadFromClassFile(file)) {, +				addDexFile(dex);, +			}, +				for (Dex dex : loadFromJar(file.toPath())) {, +					addDexFile(dex);, +				}, +								Path jarFile = Files.createTempFile(entryName, ".jar");, +								Files.copy(inputStream, jarFile);, +								for (Dex dex : loadFromJar(jarFile)) {, +									addDexFile(entryName, dex);, +	private static List<Dex> loadFromJar(Path jar) throws DecodeException {, +			LOG.info("converting to dex: {} ...", jar.getFileName());, +			List<byte[]> byteList = j2d.convert(jar);, +			if (byteList.isEmpty()) {, +			List<Dex> dexList = new ArrayList<>(byteList.size());, +			for (byte[] b : byteList) {, +				dexList.add(new Dex(b));, +			}, +			return dexList;, +	private static List<Dex> loadFromClassFile(File file) throws IOException, DecodeException {, +		Path outFile = Files.createTempFile("cls", ".jar");, +		try (JarOutputStream jo = new JarOutputStream(Files.newOutputStream(outFile))) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java, +import java.nio.file.DirectoryStream;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.util.ArrayList;, +import java.util.List;, +		public DxArgs(DxContext context, String dexDir, String[] input) {, +			outName = dexDir;, +			multiDex = true;, +	public List<byte[]> convert(Path jar) throws JadxException {, +			Path dir = Files.createTempDirectory("jadx");, +			DxArgs args = new DxArgs(, +					context,, +					dir.toAbsolutePath().toString(),, +					new String[]{jar.toAbsolutePath().toString()});, +			int result = new Main(context).runDx(args);, +			List<byte[]> list = new ArrayList<>();, +	        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir)) {, +	            for (Path child : ds) {, +	            	list.add(Files.readAllBytes(child));, +	            	Files.delete(child);, +	            }, +	        }, +	        Files.delete(dir);, +	        return list;]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +			if (clsName == null || !ZipSecurity.isValidZipEntryName(clsName)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		for (BlockNode node : block.getSuccessors()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		for (BlockNode node : block.getSuccessors()) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch8.java, +package jadx.tests.integration.trycatch;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.*;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatch8 extends IntegrationTest {, +, +	public static class TestCls {, +		static class MyException extends Exception {, +			private static final long serialVersionUID = 7963400419047287279L;, +, +			MyException() {, +			}, +, +			MyException(String msg, Throwable cause) {, +				super(msg, cause);, +			}, +		}, +, +		MyException e = null;, +, +		public void test() {, +			synchronized (this) {, +				try {, +					throw new MyException();, +				} catch (MyException e) {, +					this.e = e;, +				} catch (Exception x) {, +					this.e = new MyException("MyExc", x);, +				}, +			}, +		}, +, +		public void check() {, +			test();, +			assertThat(e, notNullValue());, +			assertThat(e, isA(MyException.class));, +			assertThat(e.getMessage(), nullValue());, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("synchronized (this) {"));, +		assertThat(code, containsOne("throw new MyException();"));, +		assertThat(code, containsOne("} catch (MyException e) {"));, +		assertThat(code, containsOne("this.e = e;"));, +		assertThat(code, containsOne("} catch (Exception x) {"));, +		assertThat(code, containsOne("this.e = new MyException(\"MyExc\", x);"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	public static final AType<AttrList<JadxError>> JADX_ERROR = new AType<>(); // code failed to decompile completely, +	public static final AType<AttrList<JadxWarn>> JADX_WARN = new AType<>(); // mark code as inconsistent (code can be viewed), +	public static final AType<AttrList<String>> COMMENTS = new AType<>(); // any additional info about decompilation, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	public static final AType<AttrList<JadxError>> JADX_ERROR = new AType<>(); // code failed to decompile completely, +	public static final AType<AttrList<JadxWarn>> JADX_WARN = new AType<>(); // mark code as inconsistent (code can be viewed), +	public static final AType<AttrList<String>> COMMENTS = new AType<>(); // any additional info about decompilation, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttributeNode;, +import static org.junit.Assert.assertFalse;, +		assertFalse("Inconsistent cls: " + cls, hasErrors(cls));, +			assertFalse("Method with problems: " + mthNode, hasErrors(mthNode));, +	private static boolean hasErrors(IAttributeNode node) {, +		if (node.contains(AFlag.INCONSISTENT_CODE), +				|| node.contains(AType.JADX_ERROR), +				|| node.contains(AType.JADX_WARN)) {, +			return true;, +		}, +		AttrList<String> commentsAttr = node.get(AType.COMMENTS);, +		if (commentsAttr != null) {, +			for (String comment : commentsAttr.getList()) {, +				if (comment.contains("JADX WARN")) {, +					return true;, +				}, +			}, +		}, +		return false;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.rits.cloning.Cloner;, +, +import jadx.core.dex.attributes.AFlag;, +		if (contains(AFlag.DONT_GENERATE)) {, +			if (getType() == InsnType.MONITOR_EXIT) {, +				return false;, +			}, +			return true;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.rits.cloning.Cloner;, +, +import jadx.core.dex.attributes.AFlag;, +		if (contains(AFlag.DONT_GENERATE)) {, +			if (getType() == InsnType.MONITOR_EXIT) {, +				return false;, +			}, +			return true;, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java, +		assertThat(code, containsOne("return new Result(400);"));]
[+++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, +    compile files('libs/jfontchooser-1.0.5.jar'), +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, +    compile files('libs/jfontchooser-1.0.5.jar'), +++ b/jadx-gui/libs/jfontchooser-1.0.5.jar, +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, +    compile files('libs/jfontchooser-1.0.5.jar'), +++ b/jadx-gui/libs/jfontchooser-1.0.5.jar, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import javax.swing.JLabel;, +import java.awt.Font;, +	private static final Font DEFAULT_FONT = new JLabel().getFont();, +, +	private String fontStr = "";, +, +	public Font getFont() {, +		if (fontStr.isEmpty()) {, +			return DEFAULT_FONT;, +		}, +		return Font.decode(fontStr);, +	}, +, +	public void setFont(Font font) {, +		this.fontStr = font.getFontName() + addStyleName(font.getStyle()) + "-" + font.getSize();, +	}, +, +	private static String addStyleName(int style) {, +		switch (style) {, +			case Font.BOLD:, +				return "-BOLD";, +			case Font.PLAIN:, +				return "-PLAIN";, +			case Font.ITALIC:, +				return "-ITALIC";, +			default:, +				return "";, +		}, +	}, +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, +    compile files('libs/jfontchooser-1.0.5.jar'), +++ b/jadx-gui/libs/jfontchooser-1.0.5.jar, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import javax.swing.JLabel;, +import java.awt.Font;, +	private static final Font DEFAULT_FONT = new JLabel().getFont();, +, +	private String fontStr = "";, +, +	public Font getFont() {, +		if (fontStr.isEmpty()) {, +			return DEFAULT_FONT;, +		}, +		return Font.decode(fontStr);, +	}, +, +	public void setFont(Font font) {, +		this.fontStr = font.getFontName() + addStyleName(font.getStyle()) + "-" + font.getSize();, +	}, +, +	private static String addStyleName(int style) {, +		switch (style) {, +			case Font.BOLD:, +				return "-BOLD";, +			case Font.PLAIN:, +				return "-PLAIN";, +			case Font.ITALIC:, +				return "-ITALIC";, +			default:, +				return "";, +		}, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import say.swing.JFontChooser;, +import java.awt.Font;, +import java.awt.event.MouseAdapter;, +import java.awt.event.MouseEvent;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxSettingsWindow.class);, +, +		JButton fontBtn = new JButton(NLS.str("preferences.select_font"));, +		fontBtn.addMouseListener(new MouseAdapter() {, +			@Override, +			public void mouseClicked(MouseEvent e) {, +				JFontChooser fontChooser = new JFontChooser();, +				fontChooser.setSelectedFont(settings.getFont());, +				int result = fontChooser.showDialog(JadxSettingsWindow.this);, +				if (result == JFontChooser.OK_OPTION) {, +					Font font = fontChooser.getSelectedFont();]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/.travis.yml, +sudo: false, +dist: trusty, +  - wget https://github.com/sormuras/bach/raw/master/install-jdk.sh, +env:, +  global:, +    - TERM=dumb, +, +matrix:, +  include:, +    - env: JDK=oracle-8, +      jdk: oraclejdk8, +    - env: JDK=oracle-10, +      install: . ./install-jdk.sh -F 10 -L BCL, +, +  - java -version, +  - test $JDK = "oracle-8" && ./gradlew clean build jacocoTestReport && bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +  - test $JDK = "oracle-8" && ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN || echo "Skip sonar build and upload", +, +before_deploy:, +    condition: $JDK = oracle-8, +++ b/.gitignore, +++ b/.travis.yml, +sudo: false, +dist: trusty, +  - wget https://github.com/sormuras/bach/raw/master/install-jdk.sh, +env:, +  global:, +    - TERM=dumb, +, +matrix:, +  include:, +    - env: JDK=oracle-8, +      jdk: oraclejdk8, +    - env: JDK=oracle-10, +      install: . ./install-jdk.sh -F 10 -L BCL, +, +  - java -version, +  - test $JDK = "oracle-8" && ./gradlew clean build jacocoTestReport && bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +  - test $JDK = "oracle-8" && ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN || echo "Skip sonar build and upload", +, +before_deploy:, +    condition: $JDK = oracle-8, +++ b/build.gradle, +        testCompile 'org.mockito:mockito-core:2.18.3', +        toolVersion = "0.8.1", +++ b/.gitignore, +++ b/.travis.yml, +sudo: false, +dist: trusty, +  - wget https://github.com/sormuras/bach/raw/master/install-jdk.sh, +env:, +  global:, +    - TERM=dumb, +, +matrix:, +  include:, +    - env: JDK=oracle-8, +      jdk: oraclejdk8, +    - env: JDK=oracle-10, +      install: . ./install-jdk.sh -F 10 -L BCL, +, +  - java -version, +  - test $JDK = "oracle-8" && ./gradlew clean build jacocoTestReport && bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +  - test $JDK = "oracle-8" && ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN || echo "Skip sonar build and upload", +, +before_deploy:, +    condition: $JDK = oracle-8, +++ b/build.gradle, +        testCompile 'org.mockito:mockito-core:2.18.3', +        toolVersion = "0.8.1", +++ b/gradle.properties, +org.gradle.daemon=false, +++ b/.gitignore, +++ b/.travis.yml, +sudo: false, +dist: trusty, +  - wget https://github.com/sormuras/bach/raw/master/install-jdk.sh, +env:, +  global:, +    - TERM=dumb, +, +matrix:, +  include:, +    - env: JDK=oracle-8, +      jdk: oraclejdk8, +    - env: JDK=oracle-10, +      install: . ./install-jdk.sh -F 10 -L BCL, +, +  - java -version, +  - test $JDK = "oracle-8" && ./gradlew clean build jacocoTestReport && bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +  - test $JDK = "oracle-8" && ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN || echo "Skip sonar build and upload", +, +before_deploy:, +    condition: $JDK = oracle-8, +++ b/build.gradle, +        testCompile 'org.mockito:mockito-core:2.18.3', +        toolVersion = "0.8.1"]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, +	public boolean isAttrStorageEmpty() {, +		return storage.isEmpty();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, +	public boolean isAttrStorageEmpty() {, +		return storage.isEmpty();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import java.util.Objects;, +		if (insnType != other.insnType) {, +			return false;, +		}, +		int size = arguments.size();, +		if (size != other.arguments.size()) {, +	/**, +	 * 'Hard' equals, compare all arguments, +	 */, +	public boolean isDeepEquals(InsnNode other) {, +		if (this == other) {, +			return true;, +		}, +		return isSame(other), +				&& Objects.equals(arguments, other.arguments);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, +	public boolean isAttrStorageEmpty() {, +		return storage.isEmpty();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import java.util.Objects;, +		if (insnType != other.insnType) {, +			return false;, +		}, +		int size = arguments.size();, +		if (size != other.arguments.size()) {, +	/**, +	 * 'Hard' equals, compare all arguments, +	 */, +	public boolean isDeepEquals(InsnNode other) {, +		if (this == other) {, +			return true;, +		}, +		return isSame(other), +				&& Objects.equals(arguments, other.arguments);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +		if (independentBlockTreeMod(mth)) {, +			clearBlocksState(mth);, +			computeDominators(mth);, +		}, +	private static boolean removeEmptyBlock(MethodNode mth, BlockNode block) {, +		if (block.getInstructions().isEmpty(), +				&& !block.isSynthetic(), +				&& block.isAttrStorageEmpty(), +				&& block.getSuccessors().size() <= 1) {, +			LOG.debug("Removing empty block: {}", block);, +			if (block.getSuccessors().size() == 1) {, +				BlockNode successor = block.getSuccessors().get(0);, +				block.getPredecessors().forEach(pred -> {, +					pred.getSuccessors().remove(block);, +					BlockSplitter.connect(pred, successor);, +					BlockSplitter.replaceTarget(pred, block, successor);, +					pred.updateCleanSuccessors();, +				});, +				BlockSplitter.removeConnection(block, successor);, +			} else {, +				block.getPredecessors().forEach(pred -> {, +					pred.getSuccessors().remove(block);, +					pred.updateCleanSuccessors();, +				});, +			}, +			block.add(AFlag.REMOVE);, +			block.getSuccessors().clear();, +			block.getPredecessors().clear();, +			return true;, +		}, +		return false;, +	}, +, +	private static boolean deduplicateBlockInsns(BlockNode block) {, +		if (block.contains(AFlag.LOOP_START) || block.contains(AFlag.LOOP_END)) {, +			// search for same instruction at end of all predecessors blocks, +			List<BlockNode> predecessors = block.getPredecessors();, +			int predsCount = predecessors.size();, +			if (predsCount > 1) {, +				InsnNode lastInsn = BlockUtils.getLastInsn(block);, +				if (lastInsn != null && lastInsn.getType() == InsnType.IF) {, +					return false;, +				}, +				int sameInsnCount = getSameLastInsnCount(predecessors);, +				if (sameInsnCount > 0) {, +					List<InsnNode> insns = getLastInsns(predecessors.get(0), sameInsnCount);, +					insertAtStart(block, insns);, +					predecessors.forEach(pred -> getLastInsns(pred, sameInsnCount).clear());, +					LOG.debug("Move duplicate insns, count: {} to block {}", sameInsnCount, block);, +					return true;]
[+++ b/.gitlab-ci.yml, +    - cat version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport, +    - ./gradlew -g /cache/.gradle clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew -g /cache/.gradle clean dist, +++ b/.gitlab-ci.yml, +    - cat version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport, +    - ./gradlew -g /cache/.gradle clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew -g /cache/.gradle clean dist, +++ b/README.md, +[![Gitlab CI](https://gitlab.com/skylot/jadx/badges/master/build.svg)](https://gitlab.com/skylot/jadx/builds), +[![Jadx Core Coverage](https://gitlab.com/skylot/jadx/badges/master/coverage.svg)](https://gitlab.com/skylot/jadx/builds), +[![SonarQube Bugs](https://sonarcloud.io/api/badges/measure?key=jadx&metric=bugs)](https://sonarcloud.io/dashboard?id=jadx), +Java 8 JDK or higher must be installed:, +, +++ b/.gitlab-ci.yml, +    - cat version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport, +    - ./gradlew -g /cache/.gradle clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew -g /cache/.gradle clean dist, +++ b/README.md, +[![Gitlab CI](https://gitlab.com/skylot/jadx/badges/master/build.svg)](https://gitlab.com/skylot/jadx/builds), +[![Jadx Core Coverage](https://gitlab.com/skylot/jadx/badges/master/coverage.svg)](https://gitlab.com/skylot/jadx/builds), +[![SonarQube Bugs](https://sonarcloud.io/api/badges/measure?key=jadx&metric=bugs)](https://sonarcloud.io/dashboard?id=jadx), +Java 8 JDK or higher must be installed:, +, +++ b/build.gradle, +    id 'org.sonarqube' version '2.4', +sonarqube {, +    properties {, +        property 'sonar.exclusions', '**/jadx/samples/**/*,**/test-app/**/*', +        property 'sonar.coverage.exclusions', '**/jadx/gui/**/*', +    }, +}, +, +++ b/.gitlab-ci.yml, +    - cat version, +    - ./gradlew -g /cache/.gradle clean build jacocoTestReport, +    - ./gradlew -g /cache/.gradle clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, +    - ./gradlew -g /cache/.gradle clean dist, +++ b/README.md, +[![Gitlab CI](https://gitlab.com/skylot/jadx/badges/master/build.svg)](https://gitlab.com/skylot/jadx/builds), +[![Jadx Core Coverage](https://gitlab.com/skylot/jadx/badges/master/coverage.svg)](https://gitlab.com/skylot/jadx/builds), +[![SonarQube Bugs](https://sonarcloud.io/api/badges/measure?key=jadx&metric=bugs)](https://sonarcloud.io/dashboard?id=jadx), +Java 8 JDK or higher must be installed:, +, +++ b/build.gradle, +    id 'org.sonarqube' version '2.4', +sonarqube {, +    properties {, +        property 'sonar.exclusions', '**/jadx/samples/**/*,**/test-app/**/*', +        property 'sonar.coverage.exclusions', '**/jadx/gui/**/*', +    }, +}, +, +++ b/version, +0.7.0]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		setFromOut(args);, +		checkDir(args.getOutDir());, +		checkDir(args.getOutDirSrc());, +		checkDir(args.getOutDirRes());, +	private static void setFromOut(JadxArgs args) {, +		if (args.getOutDirSrc() == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (args.getOutDirRes() == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +	}, +, +	private static void checkDir(File dir) {, +			throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		setFromOut(args);, +		checkDir(args.getOutDir());, +		checkDir(args.getOutDirSrc());, +		checkDir(args.getOutDirRes());, +	private static void setFromOut(JadxArgs args) {, +		if (args.getOutDirSrc() == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (args.getOutDirRes() == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +	}, +, +	private static void checkDir(File dir) {, +			throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		setFromOut(args);, +		checkDir(args.getOutDir());, +		checkDir(args.getOutDirSrc());, +		checkDir(args.getOutDirRes());, +	private static void setFromOut(JadxArgs args) {, +		if (args.getOutDirSrc() == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (args.getOutDirRes() == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +	}, +, +	private static void checkDir(File dir) {, +			throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new MethodInlineVisitor());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore]
[+++ b/.gitlab-ci.yml, +  before_script:, +    - export JADX_LAST_TAG="$(git describe --abbrev=0 --tags)", +    - export JADX_VERSION="${JADX_LAST_TAG:1}-$(git rev-parse --short HEAD)"]
[+++ b/build.gradle, +    gradleVersion = '2.7', +++ b/build.gradle, +    gradleVersion = '2.7', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.7-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static String escapeResStrValue(String str) {, +		int len = str.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			char c = str.charAt(i);, +			switch (c) {, +				case '&': sb.append("&amp;"); break;, +				case '<': sb.append("&lt;"); break;, +				case '>': sb.append("&gt;"); break;, +				case '"': sb.append("\\\""); break;, +				case '\'': sb.append("\\'"); break;, +, +				case '\n': sb.append("\\n"); break;, +				case '\r': sb.append("\\r"); break;, +				case '\t': sb.append("\\t"); break;, +				case '\b': sb.append("\\b"); break;, +				case '\f': sb.append("\\f"); break;, +				default:, +					sb.append(c);, +					break;, +			}, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static String escapeResStrValue(String str) {, +		int len = str.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			char c = str.charAt(i);, +			switch (c) {, +				case '&': sb.append("&amp;"); break;, +				case '<': sb.append("&lt;"); break;, +				case '>': sb.append("&gt;"); break;, +				case '"': sb.append("\\\""); break;, +				case '\'': sb.append("\\'"); break;, +, +				case '\n': sb.append("\\n"); break;, +				case '\r': sb.append("\\r"); break;, +				case '\t': sb.append("\\t"); break;, +				case '\b': sb.append("\\b"); break;, +				case '\f': sb.append("\\f"); break;, +				default:, +					sb.append(c);, +					break;, +			}, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, +		if (typeName.equals("string")) {, +			cw.add(StringUtils.escapeResStrValue(valueStr));, +		} else {, +		}]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +				.doOnError(e -> LOG.error("Error while searching: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +				.doOnError(e -> LOG.error("Error while searching: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java, +	public synchronized void put(StringRef str, T value) {]
[+++ b/jadx-gui/build.gradle, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		cacheObject.setIndexJob(new IndexJob(wrapper, cacheObject, threadsCount));, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		cacheObject.setIndexJob(new IndexJob(wrapper, cacheObject, threadsCount));, +++ /dev/null, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		cacheObject.setIndexJob(new IndexJob(wrapper, cacheObject, threadsCount));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java, +	public TextSearchIndex(JNodeCache nodeCache) {, +		this.clsNamesIndex = new SimpleIndex<JNode>();, +		this.mthNamesIndex = new SimpleIndex<JNode>();, +		this.fldNamesIndex = new SimpleIndex<JNode>();, +		this.codeIndex = new CodeIndex<CodeNode>();, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +			if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +	public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, +		final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		cacheObject.setIndexJob(new IndexJob(wrapper, cacheObject, threadsCount));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java, +	public TextSearchIndex(JNodeCache nodeCache) {, +		this.clsNamesIndex = new SimpleIndex<JNode>();, +		this.mthNamesIndex = new SimpleIndex<JNode>();, +		this.fldNamesIndex = new SimpleIndex<JNode>();, +		this.codeIndex = new CodeIndex<CodeNode>();, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties]
[+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +		return "JadxArgs{" + "inputFiles=" + inputFiles +, +			       ", outDir=" + outDir +, +			       ", outDirSrc=" + outDirSrc +, +			       ", outDirRes=" + outDirRes +, +			       ", threadsCount=" + threadsCount +, +			       ", cfgOutput=" + cfgOutput +, +			       ", rawCFGOutput=" + rawCFGOutput +, +			       ", fallbackMode=" + fallbackMode +, +			       ", showInconsistentCode=" + showInconsistentCode +, +			       ", useImports=" + useImports +, +			       ", isSkipResources=" + isSkipResources +, +			       ", isSkipSources=" + isSkipSources +, +			       ", isDeobfuscationOn=" + isDeobfuscationOn +, +			       ", isDeobfuscationForceSave=" + isDeobfuscationForceSave +, +			       ", useSourceNameAsClassAlias=" + useSourceNameAsClassAlias +, +			       ", deobfuscationMinLength=" + deobfuscationMinLength +, +			       ", deobfuscationMaxLength=" + deobfuscationMaxLength +, +			       ", escapeUnicode=" + escapeUnicode +, +			       ", replaceConsts=" + replaceConsts +, +			       ", respectBytecodeAccModifiers=" + respectBytecodeAccModifiers +, +			       ", exportAsGradleProject=" + exportAsGradleProject +, +			       '}';, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +		return "JadxArgs{" + "inputFiles=" + inputFiles +, +			       ", outDir=" + outDir +, +			       ", outDirSrc=" + outDirSrc +, +			       ", outDirRes=" + outDirRes +, +			       ", threadsCount=" + threadsCount +, +			       ", cfgOutput=" + cfgOutput +, +			       ", rawCFGOutput=" + rawCFGOutput +, +			       ", fallbackMode=" + fallbackMode +, +			       ", showInconsistentCode=" + showInconsistentCode +, +			       ", useImports=" + useImports +, +			       ", isSkipResources=" + isSkipResources +, +			       ", isSkipSources=" + isSkipSources +, +			       ", isDeobfuscationOn=" + isDeobfuscationOn +, +			       ", isDeobfuscationForceSave=" + isDeobfuscationForceSave +, +			       ", useSourceNameAsClassAlias=" + useSourceNameAsClassAlias +, +			       ", deobfuscationMinLength=" + deobfuscationMinLength +, +			       ", deobfuscationMaxLength=" + deobfuscationMaxLength +, +			       ", escapeUnicode=" + escapeUnicode +, +			       ", replaceConsts=" + replaceConsts +, +			       ", respectBytecodeAccModifiers=" + respectBytecodeAccModifiers +, +			       ", exportAsGradleProject=" + exportAsGradleProject +, +			       '}';, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		return "(short) " + s;, +		return "(byte) " + b;, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +		return "JadxArgs{" + "inputFiles=" + inputFiles +, +			       ", outDir=" + outDir +, +			       ", outDirSrc=" + outDirSrc +, +			       ", outDirRes=" + outDirRes +, +			       ", threadsCount=" + threadsCount +, +			       ", cfgOutput=" + cfgOutput +, +			       ", rawCFGOutput=" + rawCFGOutput +, +			       ", fallbackMode=" + fallbackMode +, +			       ", showInconsistentCode=" + showInconsistentCode +, +			       ", useImports=" + useImports +, +			       ", isSkipResources=" + isSkipResources +, +			       ", isSkipSources=" + isSkipSources +, +			       ", isDeobfuscationOn=" + isDeobfuscationOn +, +			       ", isDeobfuscationForceSave=" + isDeobfuscationForceSave +, +			       ", useSourceNameAsClassAlias=" + useSourceNameAsClassAlias +, +			       ", deobfuscationMinLength=" + deobfuscationMinLength +, +			       ", deobfuscationMaxLength=" + deobfuscationMaxLength +, +			       ", escapeUnicode=" + escapeUnicode +, +			       ", replaceConsts=" + replaceConsts +, +			       ", respectBytecodeAccModifiers=" + respectBytecodeAccModifiers +, +			       ", exportAsGradleProject=" + exportAsGradleProject +, +			       '}';, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		return "(short) " + s;, +		return "(byte) " + b;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +	MethodInfo getCallMth();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +		return "JadxArgs{" + "inputFiles=" + inputFiles +, +			       ", outDir=" + outDir +, +			       ", outDirSrc=" + outDirSrc +, +			       ", outDirRes=" + outDirRes +, +			       ", threadsCount=" + threadsCount +, +			       ", cfgOutput=" + cfgOutput +, +			       ", rawCFGOutput=" + rawCFGOutput +, +			       ", fallbackMode=" + fallbackMode +, +			       ", showInconsistentCode=" + showInconsistentCode +, +			       ", useImports=" + useImports +, +			       ", isSkipResources=" + isSkipResources +, +			       ", isSkipSources=" + isSkipSources +, +			       ", isDeobfuscationOn=" + isDeobfuscationOn +, +			       ", isDeobfuscationForceSave=" + isDeobfuscationForceSave +, +			       ", useSourceNameAsClassAlias=" + useSourceNameAsClassAlias +, +			       ", deobfuscationMinLength=" + deobfuscationMinLength +, +			       ", deobfuscationMaxLength=" + deobfuscationMaxLength +, +			       ", escapeUnicode=" + escapeUnicode +, +			       ", replaceConsts=" + replaceConsts +, +			       ", respectBytecodeAccModifiers=" + respectBytecodeAccModifiers +, +			       ", exportAsGradleProject=" + exportAsGradleProject +, +			       '}';]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.utils.files.ZipSecurity;, +	protected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +	, +	public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.utils.files.ZipSecurity;, +	protected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +	, +	public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +import jadx.core.utils.files.ZipSecurity;, +	private ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +	, +	public static ResourceFileContent createResourceFileContentInstance(String name, ResourceType type, CodeWriter content) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFileContent(name, type, content);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.utils.files.ZipSecurity;, +	protected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +	, +	public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +import jadx.core.utils.files.ZipSecurity;, +	private ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +	, +	public static ResourceFileContent createResourceFileContentInstance(String name, ResourceType type, CodeWriter content) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFileContent(name, type, content);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +		ResourceFile rf = ResourceFile.createResourceFileInstance(jadxRef, name, type);, +		if(rf != null) {, +	}, +		ResourceFile rf = ResourceFile.createResourceFileInstance(jadxRef, name, type);, +		if(rf != null) {, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.utils.files.ZipSecurity;, +	protected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +	, +	public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +import jadx.core.utils.files.ZipSecurity;, +	private ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +	, +	public static ResourceFileContent createResourceFileContentInstance(String name, ResourceType type, CodeWriter content) {, +		if(!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFileContent(name, type, content);, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +		ResourceFile rf = ResourceFile.createResourceFileInstance(jadxRef, name, type);, +		if(rf != null) {, +	}, +		ResourceFile rf = ResourceFile.createResourceFileInstance(jadxRef, name, type);, +		if(rf != null) {, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(ZipSecurity.class);, +	, +			if(isInSubDirectory(currentPath, canonical)) {, +				return true;, +			}, +			LOG.debug("Path traversal attack detected, invalid name: {}", entryName);, +			return false;, +			LOG.debug("Path traversal attack detected, invalid name: {}", entryName);, +		if(compressedSize * MAX_SIZE_DIFF < uncompressedSize) {, +			LOG.debug("Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}", compressedSize, uncompressedSize);, +			return true;, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.core.dex.instructions.args.NamedArg;, +	private static final Logger LOG = LoggerFactory.getLogger(BlockExceptionHandler.class);, +, +		if (handlerAttr == null) {, +		ArgType argType = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();, +		if (me.getType() == InsnType.MOVE_EXCEPTION) {, +			RegisterArg resArg = InsnArg.reg(me.getResult().getRegNum(), argType);, +		} else {, +			// handler arguments not used, +			excHandler.setArg(new NamedArg("unused", argType));, +		}, +		if (handler.getHandlerBlock() == null) {, +			LOG.warn("Exception handler block not set for {}, mth: {}", handler, mth);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.core.dex.instructions.args.NamedArg;, +	private static final Logger LOG = LoggerFactory.getLogger(BlockExceptionHandler.class);, +, +		if (handlerAttr == null) {, +		ArgType argType = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();, +		if (me.getType() == InsnType.MOVE_EXCEPTION) {, +			RegisterArg resArg = InsnArg.reg(me.getResult().getRegNum(), argType);, +		} else {, +			// handler arguments not used, +			excHandler.setArg(new NamedArg("unused", argType));, +		}, +		if (handler.getHandlerBlock() == null) {, +			LOG.warn("Exception handler block not set for {}, mth: {}", handler, mth);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +					throw new JadxRuntimeException("Exception block dominator not found, method:" + mth + ", dom blocks: " + domBlocks);]
[+++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.20.0', +        testCompile 'org.mockito:mockito-core:2.20.1', +        testCompile 'cglib:cglib-nodep:3.2.7', +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.20.0', +        testCompile 'org.mockito:mockito-core:2.20.1', +        testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.20.0', +        testCompile 'org.mockito:mockito-core:2.20.1', +        testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-bin.zip, +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.20.0', +        testCompile 'org.mockito:mockito-core:2.20.1', +        testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-bin.zip, +++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.4', +    testCompile 'org.smali:baksmali:2.2.4', +++ b/build.gradle, +    id 'com.github.ben-manes.versions' version '0.20.0', +        testCompile 'org.mockito:mockito-core:2.20.1', +        testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-bin.zip, +++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.4', +    testCompile 'org.smali:baksmali:2.2.4', +++ b/jadx-gui/build.gradle, +    compile 'io.reactivex.rxjava2:rxjava:2.1.17', +    compile "com.github.akarnokd:rxjava2-swing:0.2.16"]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);]
[+++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/build.gradle, +ext.jadxVersion = file('version').readLines().get(0), +, +subprojects {, +    apply plugin: 'java', +    apply plugin: 'idea', +    apply plugin: 'eclipse', +, +    jar {, +        version = jadxVersion, +    }, +    manifest {, +        mainAttributes("jadx-version" : jadxVersion), +++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/build.gradle, +ext.jadxVersion = file('version').readLines().get(0), +, +subprojects {, +    apply plugin: 'java', +    apply plugin: 'idea', +    apply plugin: 'eclipse', +, +    jar {, +        version = jadxVersion, +    }, +    manifest {, +        mainAttributes("jadx-version" : jadxVersion), +++ b/jadx-cli/build.gradle, +apply plugin: 'application', +, +mainClassName = "jadx.cli.JadxCLI", +, +dependencies {, +    compile(project(":jadx-core")), +    compile 'com.beust:jcommander:1.30', +}, +, +build.dependsOn distZip, +build.dependsOn installApp, +, +startScripts {, +    doLast {, +        // increase default max heap size, +        String var = 'DEFAULT_JVM_OPTS=', +        String args = '-Xmx1400M', +        unixScript.text = unixScript.text.replace(var + '""', var + '"' + args + '"'), +        windowsScript.text = windowsScript.text.replace(var, var + args), +    }, +}, +, +applicationDistribution.with {, +    into('') {, +        from '.', +        include 'README.md', +        include 'NOTICE', +    }, +}, +, +++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/build.gradle, +ext.jadxVersion = file('version').readLines().get(0), +, +subprojects {, +    apply plugin: 'java', +    apply plugin: 'idea', +    apply plugin: 'eclipse', +, +    jar {, +        version = jadxVersion, +    }, +    manifest {, +        mainAttributes("jadx-version" : jadxVersion), +++ b/jadx-cli/build.gradle, +apply plugin: 'application', +, +mainClassName = "jadx.cli.JadxCLI", +, +dependencies {, +    compile(project(":jadx-core")), +    compile 'com.beust:jcommander:1.30', +}, +, +build.dependsOn distZip, +build.dependsOn installApp, +, +startScripts {]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, +		FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, +		FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, +			FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, +		FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, +			FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, +		FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, +			FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +, +	public static void makeDirsForFile(File file) {, +		File dir = file.getParentFile();, +		if (dir != null && !dir.exists()) {, +			// if directory already created in other thread mkdirs will return false,, +			// so check dir existence again, +			if (!dir.mkdirs() && !dir.exists()) {, +				throw new JadxRuntimeException("Can't create directory " + dir);, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, +		FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, +			FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +, +	public static void makeDirsForFile(File file) {, +		File dir = file.getParentFile();, +		if (dir != null && !dir.exists()) {, +			// if directory already created in other thread mkdirs will return false,, +			// so check dir existence again, +			if (!dir.mkdirs() && !dir.exists()) {, +				throw new JadxRuntimeException("Can't create directory " + dir);, +			}, +		}, +	}, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.tests.api.compiler.StaticCompiler;, +import java.util.Arrays;, +import java.util.Iterator;, +import static org.junit.Assert.assertNotEquals;, +	private static final String TEST_DIRECTORY = "src/test/java";, +	private static final String TEST_DIRECTORY2 = "jadx-core/" + TEST_DIRECTORY;, +, +	protected boolean withDebugInfo = true;, +, +			assertTrue("Compilation failed", result);, +		List<File> list;, +		if (!withDebugInfo) {, +			list = compileClass(cls);, +		} else {, +			list = getClassFilesWithInners(cls);, +			if (list.isEmpty()) {, +				list = compileClass(cls);, +			}, +		}, +		assertNotEquals("File list is empty", 0, list.size());, +	private static File createTempDir(String prefix) throws IOException {, +		File baseDir = new File(System.getProperty("java.io.tmpdir"));, +		String baseName = prefix + "-" + System.nanoTime();, +		for (int counter = 1; counter < 1000; counter++) {, +			File tempDir = new File(baseDir, baseName + counter);, +			if (tempDir.mkdir()) {, +				return tempDir;, +			}, +		}, +		throw new IOException("Failed to create temp directory");, +	}, +, +	private List<File> compileClass(Class<?> cls) throws IOException {, +		String fileName = cls.getName();, +		int end = fileName.indexOf('$');, +		if (end != -1) {, +			fileName = fileName.substring(0, end);, +		}, +		fileName = fileName.replace('.', '/') + ".java";, +		File file = new File(TEST_DIRECTORY, fileName);, +		if (!file.exists()) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		BlockNode otherPathBlock;, +		if (followThenBranch) {, +			otherPathBlock = first.getElseBlock();, +			if (!otherPathBlock.equals(result.getElseBlock())) {, +				result.getSkipBlocks().add(otherPathBlock);, +			}, +		} else {, +			otherPathBlock = first.getThenBlock();, +			if (!otherPathBlock.equals(result.getThenBlock())) {, +				result.getSkipBlocks().add(otherPathBlock);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		BlockNode otherPathBlock;, +		if (followThenBranch) {, +			otherPathBlock = first.getElseBlock();, +			if (!otherPathBlock.equals(result.getElseBlock())) {, +				result.getSkipBlocks().add(otherPathBlock);, +			}, +		} else {, +			otherPathBlock = first.getThenBlock();, +			if (!otherPathBlock.equals(result.getThenBlock())) {, +				result.getSkipBlocks().add(otherPathBlock);, +			}, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java, +package jadx.tests.integration.conditions;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestComplexIf extends SmaliTest {, +, +/*, +	public final class TestComplexIf {, +	    private String a;, +	    private int b;, +	    private float c;, +, +	    public final boolean test() {, +	        if (this.a.equals("GT-P6200") || this.a.equals("GT-P6210") || ... ) {, +	            return true;, +	        }, +	        if (this.a.equals("SM-T810") || this.a.equals("SM-T813") || ...) {, +	            return false;, +	        }, +	        return this.c > 160.0f ? true : this.c <= 0.0f && ((this.b & 15) == 4 ? 1 : null) != null;, +	    }, +	}, + */, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNodeFromSmaliWithPkg("conditions", "TestComplexIf");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("if (this.a.equals(\"GT-P6200\") || this.a.equals(\"GT-P6210\") || this.a.equals(\"A100\") " +, +				"|| this.a.equals(\"A101\") || this.a.equals(\"LIFETAB_S786X\") || this.a.equals(\"VS890 4G\")) {"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		BlockNode otherPathBlock;, +		if (followThenBranch) {, +			otherPathBlock = first.getElseBlock();, +			if (!otherPathBlock.equals(result.getElseBlock())) {, +				result.getSkipBlocks().add(otherPathBlock);, +			}, +		} else {, +			otherPathBlock = first.getThenBlock();, +			if (!otherPathBlock.equals(result.getThenBlock())) {, +				result.getSkipBlocks().add(otherPathBlock);, +			}, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java, +package jadx.tests.integration.conditions;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestComplexIf extends SmaliTest {, +, +/*, +	public final class TestComplexIf {, +	    private String a;, +	    private int b;, +	    private float c;, +, +	    public final boolean test() {, +	        if (this.a.equals("GT-P6200") || this.a.equals("GT-P6210") || ... ) {]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +		long stringsEnd = stylesStart == 0 ? chunkEnd : start + stylesStart;, +			is.skipToPos(stringsEnd, "Skip string8 padding");, +			byte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));, +		is.skipToPos(chunkEnd, "Skip string pool padding");, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +		long stringsEnd = stylesStart == 0 ? chunkEnd : start + stylesStart;, +			is.skipToPos(stringsEnd, "Skip string8 padding");, +			byte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));, +		is.skipToPos(chunkEnd, "Skip string pool padding");, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +		checkPos(expectedOffset, error);]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +			//System.out.println("COUNT: "+Integer.toHexString(count));, +		//System.out.println("NAMESPACE BEGIN Line: " + beginLineNumber);, +		int comment = cInt32(bytes, count);, +		//System.out.println("Comment: 0x" + Integer.toHexString(comment));, +		//System.out.println("COUNT: "+Integer.toHexString(count));, +		//System.out.println("NAMESPACE END Line: " + endLineNumber);, +		int comment = cInt32(bytes, count);, +		//System.out.println("Comment: 0x" + Integer.toHexString(comment));, +		//System.out.println("elementLineNumber: " + elementLineNumber);, +		int comment = cInt32(bytes, count);, +		//System.out.println("Comment: 0x" + Integer.toHexString(comment));, +		//System.out.println("COUNT: "+Integer.toHexString(count));, +		//System.out.println("Namespace: 0x" + Integer.toHexString(startNS));, +		//System.out.println("Namespace name: " + strings[startNSName]);, +		//System.out.println("startNS: attributeCount: " + attributeCount);, +		//System.out.println("startNS: idIndex: " + idIndex);, +		//System.out.println("startNS: classIndex: " + classIndex);, +		//System.out.println("startNS: styleIndex: " + styleIndex);, +		//System.out.println("ELEMENT END Line:" + endLineNumber);, +		int comment = cInt32(bytes, count);, +		//System.out.println("Comment: 0x" + Integer.toHexString(comment));]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(args.getOutDir(), "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(args.getOutDir(), "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		} else {, +			LOG.warn("Can't detect out node for switch block: {} in {}",, +					block.toString(), mth.toString());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(args.getOutDir(), "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		} else {, +			LOG.warn("Can't detect out node for switch block: {} in {}",, +					block.toString(), mth.toString());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.ConstStringNode;, +, +          // If this is a 'new StringBuilder(xxx).append(yyy).append(zzz).toString(), , +          // convert it to STRING_CONCAT pseudo instruction., +	      int constrIndex = -1;  //RAF, +	      // Case where new StringBuilder() is called with NO args (the entire, +	      // string is created using .append() calls:, +	        constrIndex = 0;, +	      } else if (chain.size()>2 && chain.get(1).getType()==InsnType.CONSTRUCTOR) {, +	        //RAF Case where the first string element is String arg to the , +	        // new StringBuilder("xxx") constructor, +	        constrIndex = 1;, +	      } else if (chain.size()>3 && chain.get(2).getType()==InsnType.CONSTRUCTOR) {, +	        //RAF Case where the first string element is String.valueOf() arg , +	        // to the new StringBuilder(String.valueOf(zzz)) constructor, +	        constrIndex = 2;, +	      }, +, +	      if (constrIndex != -1) {  // If we found a CONSTRUCTOR, is it a StringBuilder?, +	        ConstructorInsn constr = (ConstructorInsn) chain.get(constrIndex);, +	        if (constr.getClassType().getFullName().equals(Consts.CLASS_STRING_BUILDER)) {, +	          int len = chain.size(),  argInd = 1;, +	          InsnNode argInsn;, +	          if (constrIndex > 0) {  // There was an arg to the StringBuilder constr, +	            InsnWrapArg iwa;, +	            if (constrIndex==2 , +	                && (argInsn = chain.get(1)).getType()==InsnType.INVOKE, +	                && ((InvokeNode)argInsn).getCallMth().getName().compareTo("valueOf")==0) {, +	              // The argument of new StringBuilder() is a String.valueOf(chainElement0), +	              iwa = (InsnWrapArg)argInsn.getArg(0);, +	              argInd = 3;  // Cause for loop below to skip to after the constructor, +	            } else {, +	              ConstStringNode csn = (ConstStringNode)chain.get(0);, +	              iwa = new InsnWrapArg(csn);, +	              argInd = 2;  // Cause for loop below to skip to after the constructor, +	            }, +	            concatInsn.addArg(iwa);, +	          }, +, +	          for (; argInd < len; argInd++) {  // Add the .append(xxx) arg string to concat , +	            concatInsn.addArg(chain.get(argInd).getArg(1));, +	        } // end of if constructor is for StringBuilder, +	      } // end of if we found a constructor early in the chain, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			makeRegionIndent(code, c);, +			makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			makeRegionIndent(code, c);, +			makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java, +package jadx.core.dex.nodes;, +, +import java.util.List;, +, +public interface IBranchRegion extends IRegion {, +, +	/**, +	 * Return list of branches in this region., +	 * NOTE: Contains 'null' elements for indicate empty branches., +	 */, +	List<IContainer> getBranches();, +, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			makeRegionIndent(code, c);, +			makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java, +package jadx.core.dex.nodes;, +, +import java.util.List;, +, +public interface IBranchRegion extends IRegion {, +, +	/**, +	 * Return list of branches in this region., +	 * NOTE: Contains 'null' elements for indicate empty branches., +	 */, +	List<IContainer> getBranches();, +, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java, +import jadx.core.dex.nodes.IBranchRegion;, +public final class SwitchRegion extends AbstractRegion implements IBranchRegion {, +	public List<IContainer> getBranches() {, +		List<IContainer> branches = new ArrayList<IContainer>(cases.size() + 1);, +		branches.addAll(cases);, +		branches.add(defCase);, +		return Collections.unmodifiableList(branches);, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			makeRegionIndent(code, c);, +			makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java, +package jadx.core.dex.nodes;, +, +import java.util.List;, +, +public interface IBranchRegion extends IRegion {, +, +	/**, +	 * Return list of branches in this region., +	 * NOTE: Contains 'null' elements for indicate empty branches., +	 */, +	List<IContainer> getBranches();, +, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/SwitchRegion.java, +import jadx.core.dex.nodes.IBranchRegion;, +public final class SwitchRegion extends AbstractRegion implements IBranchRegion {, +	public List<IContainer> getBranches() {, +		List<IContainer> branches = new ArrayList<IContainer>(cases.size() + 1);, +		branches.addAll(cases);, +		branches.add(defCase);, +		return Collections.unmodifiableList(branches);, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +import jadx.core.dex.nodes.IBranchRegion;, +public final class TryCatchRegion extends AbstractRegion implements IBranchRegion {, +	public List<IContainer> getBranches() {, +		return getSubBlocks();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			makeRegionIndent(code, c);, +			makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java, +package jadx.core.dex.nodes;, +, +import java.util.List;, +, +public interface IBranchRegion extends IRegion {, +, +	/**, +	 * Return list of branches in this region., +	 * NOTE: Contains 'null' elements for indicate empty branches., +	 */, +	List<IContainer> getBranches();, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.List;, +			List<Object> nodes = new ArrayList<Object>(ERROR_NODES);, +			Collections.sort(nodes, new Comparator<Object>() {, +				@Override, +				public int compare(Object o1, Object o2) {, +					return String.valueOf(o1).compareTo(String.valueOf(o2));, +				}, +			});, +			for (Object node : nodes) {]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +		//BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +		//bxp.parse();, +		//System.exit(4);]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +		if (!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +		if (!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +	public ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +		return ResContainer.textResource(getName(), content);, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +		if (!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +	public ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +		return ResContainer.textResource(getName(), content);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.android.Res9patchStreamDecoder;, +	public interface ResourceDecoder<T> {, +		T decode(long size, InputStream is) throws IOException;, +	public static <T> T decodeStream(ResourceFile rf, ResourceDecoder<T> decoder) throws JadxException {, +			return decodeStream(rf, (size, is) -> loadContent(jadxRef, rf, is));, +			return ResContainer.textResource(rf.getName(), cw);, +	                                        InputStream inputStream) throws IOException {, +				CodeWriter content = jadxRef.getXmlParser().parse(inputStream);, +				return ResContainer.textResource(rf.getName(), content);, +				return new ResTableParser().decodeFiles(inputStream);, +				return decodeImage(rf, inputStream);, +				return ResContainer.resourceFileLink(rf);, +, +	private static ResContainer decodeImage(ResourceFile rf, InputStream inputStream) {, +		String name = rf.getName();, +		if (name.endsWith(".9.png")) {, +			Res9patchStreamDecoder decoder = new Res9patchStreamDecoder();, +			ByteArrayOutputStream os = new ByteArrayOutputStream();, +			try {, +				decoder.decode(inputStream, os);, +				return ResContainer.decodedData(rf.getName(), os.toByteArray());, +			} catch (Exception e) {, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +			}, +		}, +		return ResContainer.resourceFileLink(rf);, +		ResourceFile rf = ResourceFile.createResourceFile(jadxRef, name, type);, +		ResourceFile rf = ResourceFile.createResourceFile(jadxRef, name, type);, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, +		if (!ZipSecurity.isValidZipEntryName(name)) {, +			return null;, +		}, +		return new ResourceFile(decompiler, name, type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +	public ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +		return ResContainer.textResource(getName(), content);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.android.Res9patchStreamDecoder;, +	public interface ResourceDecoder<T> {, +		T decode(long size, InputStream is) throws IOException;, +	public static <T> T decodeStream(ResourceFile rf, ResourceDecoder<T> decoder) throws JadxException {, +			return decodeStream(rf, (size, is) -> loadContent(jadxRef, rf, is));, +			return ResContainer.textResource(rf.getName(), cw);, +	                                        InputStream inputStream) throws IOException {, +				CodeWriter content = jadxRef.getXmlParser().parse(inputStream);, +				return ResContainer.textResource(rf.getName(), content);, +				return new ResTableParser().decodeFiles(inputStream);, +				return decodeImage(rf, inputStream);, +				return ResContainer.resourceFileLink(rf);, +, +	private static ResContainer decodeImage(ResourceFile rf, InputStream inputStream) {, +		String name = rf.getName();, +		if (name.endsWith(".9.png")) {, +			Res9patchStreamDecoder decoder = new Res9patchStreamDecoder();, +			ByteArrayOutputStream os = new ByteArrayOutputStream();, +			try {, +				decoder.decode(inputStream, os);, +				return ResContainer.decodedData(rf.getName(), os.toByteArray());, +			} catch (Exception e) {, +				LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +			}, +		}, +		return ResContainer.resourceFileLink(rf);, +		ResourceFile rf = ResourceFile.createResourceFile(jadxRef, name, type);, +		ResourceFile rf = ResourceFile.createResourceFile(jadxRef, name, type);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java]
[+++ b/jadx-cli/build.gradle, +    compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/build.gradle, +    compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxArgsValidateException;, +		try {, +		} catch (JadxArgsValidateException e) {, +			LOG.error("Incorrect arguments: {}", e.getMessage());, +			System.exit(1);, +		}, +++ b/jadx-cli/build.gradle, +    compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxArgsValidateException;, +		try {, +		} catch (JadxArgsValidateException e) {, +			LOG.error("Incorrect arguments: {}", e.getMessage());, +			System.exit(1);, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.apk, .dex, .jar or .class)"), +	@Parameter(names = {"-j", "--threads-count"}, description = "processing threads count"), +	protected int threadsCount = JadxArgs.DEFAULT_THREADS_COUNT;, +, +	@Parameter(names = {"--no-imports"}, description = "disable use of imports, always write entire package name"), +	@Parameter(names = "--no-replace-consts", description = "don't replace constant value with matching constant field"), +	@Parameter(names = {"--version"}, description = "print jadx version"), +	protected boolean printVersion = false;, +, +			makeJCommander().parse(args);, +	private JCommander makeJCommander() {, +		return JCommander.newBuilder().addObject(this).build();, +	}, +, +		if (printHelp) {, +		if (printVersion) {, +			System.out.println(JadxDecompiler.getVersion());, +			return false;, +		}, +			if (verbose) {, +		JCommander jc = makeJCommander();, +			opt.append("  ").append(p.getNames());, +	public boolean isEscapeUnicode() {, +		return escapeUnicode;, +	}, +, +	public boolean isCfgOutput() {, +		return cfgOutput;, +	}, +, +	public boolean isRawCfgOutput() {, +		return rawCfgOutput;, +	}, +, +++ b/jadx-cli/build.gradle, +    compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxArgsValidateException;, +		try {, +		} catch (JadxArgsValidateException e) {, +			LOG.error("Incorrect arguments: {}", e.getMessage());, +			System.exit(1);, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.apk, .dex, .jar or .class)"), +	@Parameter(names = {"-j", "--threads-count"}, description = "processing threads count"), +	protected int threadsCount = JadxArgs.DEFAULT_THREADS_COUNT;, +, +	@Parameter(names = {"--no-imports"}, description = "disable use of imports, always write entire package name"), +	@Parameter(names = "--no-replace-consts", description = "don't replace constant value with matching constant field"), +	@Parameter(names = {"--version"}, description = "print jadx version"), +	protected boolean printVersion = false;, +, +			makeJCommander().parse(args);, +	private JCommander makeJCommander() {, +		return JCommander.newBuilder().addObject(this).build();, +	}, +, +		if (printHelp) {, +		if (printVersion) {, +			System.out.println(JadxDecompiler.getVersion());, +			return false;, +		}, +			if (verbose) {, +		JCommander jc = makeJCommander();, +			opt.append("  ").append(p.getNames());, +	public boolean isEscapeUnicode() {, +		return escapeUnicode;, +	}, +, +	public boolean isCfgOutput() {, +		return cfgOutput;, +	}, +, +	public boolean isRawCfgOutput() {, +		return rawCfgOutput;, +	}, +, +++ b/jadx-cli/src/main/resources/logback.xml]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import jadx.core.dex.nodes.FieldNode;, +	public static class KeyValueMap {, +		public Object get(Object key) {, +			return map.get(key);, +		}, +, +		void put(Object key, Object value) {, +			map.put(key, value);, +		}, +	}, +, +	private Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +, +	public KeyValueMap getMap(FieldNode field) {, +		return fieldsMap.get(field);, +	}, +, +	public void add(FieldNode field, Object key, Object value) {, +		KeyValueMap map = getMap(field);, +		if (map == null) {, +			map = new KeyValueMap();, +			fieldsMap.put(field, map);, +		}, +		map.put(key, value);, +		return "Enum fields map: " + fieldsMap;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import jadx.core.dex.nodes.FieldNode;, +	public static class KeyValueMap {, +		public Object get(Object key) {, +			return map.get(key);, +		}, +, +		void put(Object key, Object value) {, +			map.put(key, value);, +		}, +	}, +, +	private Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +, +	public KeyValueMap getMap(FieldNode field) {, +		return fieldsMap.get(field);, +	}, +, +	public void add(FieldNode field, Object key, Object value) {, +		KeyValueMap map = getMap(field);, +		if (map == null) {, +			map = new KeyValueMap();, +			fieldsMap.put(field, map);, +		}, +		map.put(key, value);, +		return "Enum fields map: " + fieldsMap;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +import jadx.core.dex.info.AccessInfo;, +		EnumMapAttr.KeyValueMap valueMap = getEnumMap(mth, enumMapField);, +		if (valueMap == null) {, +		for (Object key : keys) {, +			Object newKey = valueMap.get(key);, +			if (newKey == null) {, +		// replace confirmed, +		if (!insn.replaceArg(arg, invArg)) {, +			return null;, +		}, +		for (int i = 0; i < keys.length; i++) {, +			keys[i] = valueMap.get(keys[i]);, +		}, +		enumMapField.add(AFlag.DONT_GENERATE);, +		checkAndHideClass(enumMapField.getParentClass());, +	private static EnumMapAttr.KeyValueMap getEnumMap(MethodNode mth, FieldNode field) {, +			return mapAttr.getMap(field);, +		mapAttr = new EnumMapAttr();, +		syntheticClass.addAttr(mapAttr);, +, +					addToEnumMap(mth, mapAttr, insn);, +		return mapAttr.getMap(field);, +	private static void addToEnumMap(MethodNode mth, EnumMapAttr mapAttr, InsnNode aputInsn) {, +		InsnArg litArg = aputInsn.getArg(2);, +		EnumMapInfo mapInfo = checkEnumMapAccess(mth, aputInsn);, +		FieldNode field = mapInfo.getMapField();, +		if (field == null || !enumArg.isInsnWrap()) {, +		mapAttr.add(field, literal, fieldNode);, +	/**, +	 * If all static final synthetic fields have DONT_GENERATE => hide whole class, +	 */, +	private static void checkAndHideClass(ClassNode cls) {, +		for (FieldNode field : cls.getFields()) {, +			AccessInfo af = field.getAccessFlags();, +			if (af.isSynthetic() && af.isStatic() && af.isFinal(), +					&& !field.contains(AFlag.DONT_GENERATE)) {, +				return;, +			}, +		}, +		cls.add(AFlag.DONT_GENERATE);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import jadx.core.dex.nodes.FieldNode;, +	public static class KeyValueMap {, +		public Object get(Object key) {, +			return map.get(key);]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +				passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoApplyVisitor());, +			}, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +				passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoApplyVisitor());, +			}, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +			CodeWriter cw = new CodeWriter();, +			cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, +			cw.startLine(Utils.getStackTrace(e.getCause()));, +			return cw;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +			CodeWriter cw = new CodeWriter();, +			cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, +			cw.startLine(Utils.getStackTrace(e.getCause()));, +			return cw;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	public synchronized CodeWriter parse(InputStream inputStream) throws IOException {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +			CodeWriter cw = new CodeWriter();, +			cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, +			cw.startLine(Utils.getStackTrace(e.getCause()));, +			return cw;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	public synchronized CodeWriter parse(InputStream inputStream) throws IOException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +import java.util.Arrays;, +		byte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));, +				strings[i] = extractString8(strArray, stringsOffset[i]);, +	private static String extractString8(byte[] strArray, int offset) {, +		int start = offset + skipStrLen8(strArray, offset);, +		int len = strArray[start++];, +		if (len == 0) {, +			return "";, +		}, +		if ((len & 0x80) != 0) {, +			len = ((len & 0x7F) << 8) | (strArray[start++] & 0xFF);, +		}, +		byte[] arr = Arrays.copyOfRange(strArray, start, start + len);, +		return new String(arr, ParserStream.STRING_CHARSET_UTF8);, +	}, +, +		int start = offset + skipStrLen16(strArray, offset);, +		byte[] arr = Arrays.copyOfRange(strArray, start, end);, +		return new String(arr, ParserStream.STRING_CHARSET_UTF16);, +	}, +, +	private static int skipStrLen8(byte[] strArray, int offset) {, +		return (strArray[offset] & 0x80) == 0 ? 1 : 2;, +	}, +, +	private static int skipStrLen16(byte[] strArray, int offset) {, +		return (strArray[offset + 1] & 0x80) == 0 ? 2 : 4;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +			CodeWriter cw = new CodeWriter();, +			cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, +			cw.startLine(Utils.getStackTrace(e.getCause()));, +			return cw;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	public synchronized CodeWriter parse(InputStream inputStream) throws IOException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +import java.util.Arrays;, +		byte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));, +				strings[i] = extractString8(strArray, stringsOffset[i]);, +	private static String extractString8(byte[] strArray, int offset) {, +		int start = offset + skipStrLen8(strArray, offset);, +		int len = strArray[start++];, +		if (len == 0) {, +			return "";, +		}, +		if ((len & 0x80) != 0) {, +			len = ((len & 0x7F) << 8) | (strArray[start++] & 0xFF);, +		}, +		byte[] arr = Arrays.copyOfRange(strArray, start, start + len);, +		return new String(arr, ParserStream.STRING_CHARSET_UTF8);, +	}, +, +		int start = offset + skipStrLen16(strArray, offset);, +		byte[] arr = Arrays.copyOfRange(strArray, start, end);, +		return new String(arr, ParserStream.STRING_CHARSET_UTF16);, +	}, +, +	private static int skipStrLen8(byte[] strArray, int offset) {, +		return (strArray[offset] & 0x80) == 0 ? 1 : 2;, +	}, +, +	private static int skipStrLen16(byte[] strArray, int offset) {, +		return (strArray[offset + 1] & 0x80) == 0 ? 2 : 4;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +	private static final int[] EMPTY_INT_ARRAY = new int[0];, +	private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];, +, +			return EMPTY_INT_ARRAY;, +			return EMPTY_BYTE_ARRAY;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +			CodeWriter cw = new CodeWriter();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +				&& cls.getMethods().isEmpty(), +				&& cls.getInnerClasses().isEmpty()) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (!simplePath.isEmpty()) {, +			BlockNode lastBlock = simplePath.get(simplePath.size() - 1);, +			if (lastBlock.contains(AFlag.RETURN), +					|| lastBlock.getSuccessors().isEmpty()) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		if (!simplePath.isEmpty()) {, +			BlockNode lastBlock = simplePath.get(simplePath.size() - 1);, +			if (lastBlock.contains(AFlag.RETURN), +					|| lastBlock.getSuccessors().isEmpty()) {, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop2.java, +package jadx.tests.integration.loops;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.List;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestBreakInLoop2 extends IntegrationTest {, +, +	public static class TestCls {, +		public void test(List<Integer> data) throws Exception {, +			for (; ; ) {, +				try {, +					funcB(data);, +					break;, +				} catch (Exception ex) {, +					if (funcC()) {, +						throw ex;, +					}, +					data.clear();, +				}, +				Thread.sleep(100);, +			}, +		}, +, +		private boolean funcB(List<Integer> data) {, +			return false;, +		}, +, +		private boolean funcC() {, +			return true;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("while (true) {"));, +		assertThat(code, containsOne("break;"));, +		assertThat(code, containsOne("throw ex;"));, +		assertThat(code, containsOne("data.clear();"));, +		assertThat(code, containsOne("Thread.sleep(100);"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if class not public (must be accessed using inheritance), +			ClassNode classNode = cls.dex().resolveClass(classInfo);, +			if (classNode != null && !classNode.getAccessFlags().isPublic()) {, +				return shortName;, +			if (classInfo.getPackage().equals(useCls.getPackage())) {, +				fullName = classInfo.getNameWithoutPackage();, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if class not public (must be accessed using inheritance), +			ClassNode classNode = cls.dex().resolveClass(classInfo);, +			if (classNode != null && !classNode.getAccessFlags().isPublic()) {, +				return shortName;, +			if (classInfo.getPackage().equals(useCls.getPackage())) {, +				fullName = classInfo.getNameWithoutPackage();, +			}, +++ b/jadx-samples/src/main/java/jadx/samples/TestImports.java, +package jadx.samples;, +, +import jadx.samples.otherpkg.A;, +, +/**, + * Tests:, + * - class B not imported, + */, +public class TestImports extends AbstractTest {, +, +	public class C extends A {, +		public B getB() {, +			return null;, +		}, +	}, +, +	@Override, +	public boolean testRun() {, +		return true;, +	}, +, +	public static void main(String[] args) {, +		new TestImports().testRun();, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if class not public (must be accessed using inheritance), +			ClassNode classNode = cls.dex().resolveClass(classInfo);, +			if (classNode != null && !classNode.getAccessFlags().isPublic()) {, +				return shortName;, +			if (classInfo.getPackage().equals(useCls.getPackage())) {, +				fullName = classInfo.getNameWithoutPackage();, +			}, +++ b/jadx-samples/src/main/java/jadx/samples/TestImports.java, +package jadx.samples;, +, +import jadx.samples.otherpkg.A;, +, +/**, + * Tests:, + * - class B not imported, + */, +public class TestImports extends AbstractTest {, +, +	public class C extends A {, +		public B getB() {, +			return null;, +		}, +	}, +, +	@Override, +	public boolean testRun() {, +		return true;, +	}, +, +	public static void main(String[] args) {, +		new TestImports().testRun();, +	}, +}, +++ b/jadx-samples/src/main/java/jadx/samples/otherpkg/A.java, +package jadx.samples.otherpkg;, +, +public class A {, +	protected class B {, +, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, +	private Object attachAnnotation(Object obj, CodePosition pos) {, +		if (annotations.isEmpty()) {, +			annotations = new HashMap<CodePosition, Object>();, +		return annotations.put(pos, obj);, +		if (sourceLine == 0) {, +			return;, +		}, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new TreeMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, +	private Object attachAnnotation(Object obj, CodePosition pos) {, +		if (annotations.isEmpty()) {, +			annotations = new HashMap<CodePosition, Object>();, +		return annotations.put(pos, obj);, +		if (sourceLine == 0) {, +			return;, +		}, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new TreeMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		code.attachSourceLine(mth.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, +	private Object attachAnnotation(Object obj, CodePosition pos) {, +		if (annotations.isEmpty()) {, +			annotations = new HashMap<CodePosition, Object>();, +		return annotations.put(pos, obj);, +		if (sourceLine == 0) {, +			return;, +		}, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new TreeMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		code.attachSourceLine(mth.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		code.attachSourceLine(region.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, +	private Object attachAnnotation(Object obj, CodePosition pos) {, +		if (annotations.isEmpty()) {, +			annotations = new HashMap<CodePosition, Object>();, +		return annotations.put(pos, obj);, +		if (sourceLine == 0) {, +			return;, +		}, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new TreeMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		code.attachSourceLine(mth.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		code.attachSourceLine(region.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +		setSourceLine(invoke.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, +	private Object attachAnnotation(Object obj, CodePosition pos) {, +		if (annotations.isEmpty()) {, +			annotations = new HashMap<CodePosition, Object>();, +		return annotations.put(pos, obj);, +		if (sourceLine == 0) {, +			return;, +		}, +	private void attachSourceLine(int decompiledLine, int sourceLine) {, +		if (lineMap.isEmpty()) {, +			lineMap = new TreeMap<Integer, Integer>();, +		}, +		lineMap.put(decompiledLine, sourceLine);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		code.attachSourceLine(mth.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		code.attachSourceLine(region.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +		setSourceLine(invoke.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		setLine(addr, line);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +			List<Object> keys = sw.getKeys().get(i);, +			for (Object k : keys) {, +				if (k instanceof IndexInsnNode) {, +					code.add(sfield((FieldInfo) ((IndexInsnNode) k).getIndex()));, +				}, +				else {, +					code.add(TypeGen.literalToString((Integer) k, arg.getType()));, +				}, +	private String sfield(FieldInfo field) {, +		String thisClass = mth.getParentClass().getFullName();, +		if (field.getDeclClass().getFullName().equals(thisClass)) {, +			return field.getName();, +		} else {, +			return useClass(field.getDeclClass()) + '.' + field.getName();, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +			List<Object> keys = sw.getKeys().get(i);, +			for (Object k : keys) {, +				if (k instanceof IndexInsnNode) {, +					code.add(sfield((FieldInfo) ((IndexInsnNode) k).getIndex()));, +				}, +				else {, +					code.add(TypeGen.literalToString((Integer) k, arg.getType()));, +				}, +	private String sfield(FieldInfo field) {, +		String thisClass = mth.getParentClass().getFullName();, +		if (field.getDeclClass().getFullName().equals(thisClass)) {, +			return field.getName();, +		} else {, +			return useClass(field.getDeclClass()) + '.' + field.getName();, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		Object[] keys;, +			keys = new Object[targets.length];, +			keys = new Object[targets.length];, +			for (int i = 0; i < keys.length; i++), +				keys[i] = ss.getKeys()[i];				, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +			List<Object> keys = sw.getKeys().get(i);, +			for (Object k : keys) {, +				if (k instanceof IndexInsnNode) {, +					code.add(sfield((FieldInfo) ((IndexInsnNode) k).getIndex()));, +				}, +				else {, +					code.add(TypeGen.literalToString((Integer) k, arg.getType()));, +				}, +	private String sfield(FieldInfo field) {, +		String thisClass = mth.getParentClass().getFullName();, +		if (field.getDeclClass().getFullName().equals(thisClass)) {, +			return field.getName();, +		} else {, +			return useClass(field.getDeclClass()) + '.' + field.getName();, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		Object[] keys;, +			keys = new Object[targets.length];, +			keys = new Object[targets.length];, +			for (int i = 0; i < keys.length; i++), +				keys[i] = ss.getKeys()[i];				, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java, +	private final Object[] keys;, +	public SwitchNode(InsnArg arg, Object[] keys, int[] targets, int def) {, +	public Object[] getKeys() {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +			List<Object> keys = sw.getKeys().get(i);, +			for (Object k : keys) {, +				if (k instanceof IndexInsnNode) {, +					code.add(sfield((FieldInfo) ((IndexInsnNode) k).getIndex()));, +				}, +				else {, +					code.add(TypeGen.literalToString((Integer) k, arg.getType()));, +				}, +	private String sfield(FieldInfo field) {, +		String thisClass = mth.getParentClass().getFullName();, +		if (field.getDeclClass().getFullName().equals(thisClass)) {, +			return field.getName();, +		} else {, +			return useClass(field.getDeclClass()) + '.' + field.getName();, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		Object[] keys;, +			keys = new Object[targets.length];, +			keys = new Object[targets.length];, +			for (int i = 0; i < keys.length; i++), +				keys[i] = ss.getKeys()[i];				, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java, +	private final Object[] keys;]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +			ConstructorInsn constrInsn = f.getConstrInsn();, +			if (constrInsn.getArgsCount() > f.getStartArg()) {, +				MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, +				igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +			ConstructorInsn constrInsn = f.getConstrInsn();, +			if (constrInsn.getArgsCount() > f.getStartArg()) {, +				MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, +				igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +			ConstructorInsn constrInsn = f.getConstrInsn();, +			if (constrInsn.getArgsCount() > f.getStartArg()) {, +				MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, +				igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		private final ConstructorInsn constrInsn;, +		private final int startArg;, +		public EnumField(String name, ConstructorInsn co, int startArg) {, +			this.constrInsn = co;, +			this.startArg = startArg;, +		public ConstructorInsn getConstrInsn() {, +			return constrInsn;, +		}, +, +		public int getStartArg() {, +			return startArg;, +			return name + "(" + constrInsn + ") " + cls;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +			ConstructorInsn constrInsn = f.getConstrInsn();, +			if (constrInsn.getArgsCount() > f.getStartArg()) {, +				MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, +				igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		private final ConstructorInsn constrInsn;, +		private final int startArg;, +		public EnumField(String name, ConstructorInsn co, int startArg) {, +			this.constrInsn = co;, +			this.startArg = startArg;, +		public ConstructorInsn getConstrInsn() {, +			return constrInsn;, +		}, +, +		public int getStartArg() {, +			return startArg;, +			return name + "(" + constrInsn + ") " + cls;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.utils.InsnUtils;, +		return InsnUtils.getConstValueByInsn(dex, parInsn);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +			ConstructorInsn constrInsn = f.getConstrInsn();, +			if (constrInsn.getArgsCount() > f.getStartArg()) {, +				MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, +				igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		private final ConstructorInsn constrInsn;, +		private final int startArg;, +		public EnumField(String name, ConstructorInsn co, int startArg) {, +			this.constrInsn = co;, +			this.startArg = startArg;, +		public ConstructorInsn getConstrInsn() {, +			return constrInsn;, +		}, +, +		public int getStartArg() {, +			return startArg;, +			return name + "(" + constrInsn + ") " + cls;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.utils.InsnUtils;, +		return InsnUtils.getConstValueByInsn(dex, parInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +			TypeInfo typeInfo = var.getTypeInfo();, +			ArgType type = typeInfo.getType();, +				boolean changed = tryAllTypes(var, type);, +				if (!changed) {, +					mth.addComment("JADX WARNING: type inference failed for: " + var + ", bounds: " + typeInfo.getBounds());, +				}, +	private boolean tryAllTypes(SSAVar var, ArgType type) {, +				return true;, +		return false;]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		if (saveSources) {, +			appendSourcesSave(executor, sourcesOutDir);, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +				writer.add("=\"").add(StringUtils.escapeXML(entry.getKey())).add("\"");, +			writer.add(StringUtils.escapeXML(decodedAttr));, +			writer.add(str != null ? StringUtils.escapeXML(str) : "null");]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +// TODO: run after code shrinker at final stage, +		ClassInfo classInfo = cls.getClassInfo();, +				if (f.getDeclClass().equals(classInfo)) {, +					FieldNode fieldNode = cls.searchField(f);, +					if (fieldNode != null, +							&& fieldNode.getAccessFlags().isSynthetic(), +							&& fieldNode.getType().isArray(), +							&& fieldNode.getType().getArrayRootElement().equals(classInfo.getType())) {, +		}, +				if (!clsInfo.equals(classInfo) && !constrCls.getAccessFlags().isEnum()) {, +					InsnArg constrArg = iArg;, +					} else if (iArg.isRegister()) {, +				if (!co.getClassType().equals(classInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +// TODO: run after code shrinker at final stage, +		ClassInfo classInfo = cls.getClassInfo();, +				if (f.getDeclClass().equals(classInfo)) {, +					FieldNode fieldNode = cls.searchField(f);, +					if (fieldNode != null, +							&& fieldNode.getAccessFlags().isSynthetic(), +							&& fieldNode.getType().isArray(), +							&& fieldNode.getType().getArrayRootElement().equals(classInfo.getType())) {, +		}, +				if (!clsInfo.equals(classInfo) && !constrCls.getAccessFlags().isEnum()) {, +					InsnArg constrArg = iArg;, +					} else if (iArg.isRegister()) {, +				if (!co.getClassType().equals(classInfo)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsWithConsts.java, +package jadx.tests.integration.enums;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsLines;, +import static org.junit.Assert.assertThat;, +, +public class TestEnumsWithConsts extends IntegrationTest {, +, +	public static class TestCls {, +, +		public static final int C1 = 1;, +		public static final int C2 = 2;, +		public static final int C4 = 4;, +, +		public static final String S = "NORTH";, +, +		public enum Direction {, +			NORTH,, +			SOUTH,, +			EAST,, +			WEST, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsLines(1, "public enum Direction {",, +				indent(1) + "NORTH,",, +				indent(1) + "SOUTH,",, +				indent(1) + "EAST,",, +				indent(1) + "WEST",, +				"}"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getExceptionHandlersCount() {, +		return exceptionHandlers.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getExceptionHandlersCount() {, +		return exceptionHandlers.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.utils.BlockUtils;, +		List<InsnNode> toRemove = new ArrayList<InsnNode>();, +			toRemove.clear();, +					toRemove.add(insn);, +			if (!toRemove.isEmpty()) {, +				InstructionRemover.removeAll(mth, block, toRemove);, +			}, +		if (insn.getType() != InsnType.CONST) {, +			return false;, +		}, +		if (!arg.isLiteral()) {, +			return false;, +		}, +		SSAVar sVar = insn.getResult().getSVar();, +		if (mth.getExceptionHandlersCount() != 0) {, +			for (RegisterArg useArg : sVar.getUseList()) {, +				InsnNode parentInsn = useArg.getParentInsn();, +				if (parentInsn != null) {, +					// TODO: speed up expensive operations, +					BlockNode useBlock = BlockUtils.getBlockByInsn(mth, parentInsn);, +					if (!BlockUtils.isCleanPathExists(block, useBlock)) {, +						return false;, +					}, +				}, +			}, +		}, +		return replaceConst(mth, sVar, lit);, +	private static boolean replaceConst(MethodNode mth, SSAVar sVar, long literal) {, +		List<RegisterArg> use = new ArrayList<RegisterArg>(sVar.getUseList());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getExceptionHandlersCount() {, +		return exceptionHandlers.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.utils.BlockUtils;, +		List<InsnNode> toRemove = new ArrayList<InsnNode>();, +			toRemove.clear();, +					toRemove.add(insn);, +			if (!toRemove.isEmpty()) {, +				InstructionRemover.removeAll(mth, block, toRemove);, +			}, +		if (insn.getType() != InsnType.CONST) {, +			return false;, +		}, +		if (!arg.isLiteral()) {, +			return false;, +		}, +		SSAVar sVar = insn.getResult().getSVar();, +		if (mth.getExceptionHandlersCount() != 0) {, +			for (RegisterArg useArg : sVar.getUseList()) {, +				InsnNode parentInsn = useArg.getParentInsn();, +				if (parentInsn != null) {, +					// TODO: speed up expensive operations, +					BlockNode useBlock = BlockUtils.getBlockByInsn(mth, parentInsn);, +					if (!BlockUtils.isCleanPathExists(block, useBlock)) {, +						return false;, +					}, +				}, +			}, +		}, +		return replaceConst(mth, sVar, lit);, +	private static boolean replaceConst(MethodNode mth, SSAVar sVar, long literal) {, +		List<RegisterArg> use = new ArrayList<RegisterArg>(sVar.getUseList());, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static boolean isCleanPathExists(BlockNode start, BlockNode end) {, +		if (start == end || start.getCleanSuccessors().contains(end)) {, +			return true;, +		}, +		return traverseCleanSuccessorsUntil(start, end, new BitSet());, +	}]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles, args.isSkipSources());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles, args.isSkipSources());, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +	public static void addFilesFrom(File file, List<InputFile> list, boolean... skipSources) throws IOException, DecodeException {, +		inputFile.searchDexFiles(skipSources[0]);, +	private void searchDexFiles(boolean skipSources) throws IOException, DecodeException {, +		if (skipSources) return;, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			Iterator<?> it = ((List) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			Iterator<?> it = ((List) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private int clsDeclLine = 0;, +		addClassDeclaration(code);, +		addClassBody(code);, +	public void addClassDeclaration(CodeWriter clsCode) {, +		addGenericMap(clsCode, cls.getGenericMap());, +	public boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {, +	public void addClassBody(CodeWriter clsCode) throws CodegenException {, +		clsDeclLine = clsCode.getLine();, +		clsCode.incIndent();, +		addFields(clsCode);, +		addInnerClasses(clsCode, cls);, +		addMethods(clsCode);, +		clsCode.decIndent();, +	private void addInnerClasses(CodeWriter code, ClassNode cls) throws CodegenException {, +		for (ClassNode innerCls : cls.getInnerClasses()) {, +			if (!innerCls.isAnonymous()) {, +				ClassGen inClGen = new ClassGen(innerCls, getParentGen(), fallback);, +				code.newLine();, +				inClGen.addClassCode(code);, +	private void addMethods(CodeWriter code) {, +		for (MethodNode mth : cls.getMethods()) {, +			if (!mth.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					if (code.getLine() != clsDeclLine) {, +						code.newLine();, +					}, +					addMethod(code, mth);, +				} catch (Exception e) {, +					String msg = ErrorsCounter.methodError(mth, "Method generation error", e);, +					code.startLine("/* " + msg + CodeWriter.NL + Utils.getStackTrace(e) + " */");, +				}, +			}, +		}, +	}, +, +	private void addMethod(CodeWriter code, MethodNode mth) throws CodegenException {, +		if (mth.getAccessFlags().isAbstract() || mth.getAccessFlags().isNative()) {, +	private void addFields(CodeWriter code) throws CodegenException {, +		addEnumFields(code);, +		for (FieldNode f : cls.getFields()) {, +	private void addEnumFields(CodeWriter code) throws CodegenException {, +							igen = new InsnGen(mthGen, false);, +					new ClassGen(f.getCls(), this, fallback).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			Iterator<?> it = ((List) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private int clsDeclLine = 0;, +		addClassDeclaration(code);, +		addClassBody(code);, +	public void addClassDeclaration(CodeWriter clsCode) {, +		addGenericMap(clsCode, cls.getGenericMap());, +	public boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {, +	public void addClassBody(CodeWriter clsCode) throws CodegenException {, +		clsDeclLine = clsCode.getLine();, +		clsCode.incIndent();, +		addFields(clsCode);, +		addInnerClasses(clsCode, cls);, +		addMethods(clsCode);, +		clsCode.decIndent();, +	private void addInnerClasses(CodeWriter code, ClassNode cls) throws CodegenException {, +		for (ClassNode innerCls : cls.getInnerClasses()) {, +			if (!innerCls.isAnonymous()) {, +				ClassGen inClGen = new ClassGen(innerCls, getParentGen(), fallback);, +				code.newLine();, +				inClGen.addClassCode(code);, +	private void addMethods(CodeWriter code) {, +		for (MethodNode mth : cls.getMethods()) {, +			if (!mth.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					if (code.getLine() != clsDeclLine) {, +						code.newLine();, +					}, +					addMethod(code, mth);, +				} catch (Exception e) {, +					String msg = ErrorsCounter.methodError(mth, "Method generation error", e);, +					code.startLine("/* " + msg + CodeWriter.NL + Utils.getStackTrace(e) + " */");, +				}, +			}, +		}, +	}, +, +	private void addMethod(CodeWriter code, MethodNode mth) throws CodegenException {, +		if (mth.getAccessFlags().isAbstract() || mth.getAccessFlags().isNative()) {, +	private void addFields(CodeWriter code) throws CodegenException {, +		addEnumFields(code);, +		for (FieldNode f : cls.getFields()) {, +	private void addEnumFields(CodeWriter code) throws CodegenException {, +							igen = new InsnGen(mthGen, false);, +					new ClassGen(f.getCls(), this, fallback).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	CodeWriter add(CodeWriter code) {, +		buf.append(code);, +	public int getLine() {, +		return line;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +import javax.swing.SwingConstants;, +import java.util.HashMap;, +import java.util.Map;, +import org.jetbrains.annotations.Nullable;, +		private Map<Integer, Component> componentCache = new HashMap<Integer, Component>();, +, +		public ResultsTableCellRenderer() {, +			int id = (row << 2) | column;, +			Component comp = componentCache.get(id);, +			if (comp == null && (obj instanceof JNode)) {, +				comp = makeCell((JNode) obj, column);, +				componentCache.put(id, comp);, +			if (comp != null) {, +				updateSelection(comp, isSelected);, +			}, +			return comp;, +		}, +		private void updateSelection(Component comp, boolean isSelected) {, +				comp.setBackground(selectedBackground);, +				comp.setForeground(selectedForeground);, +				comp.setBackground(ContentArea.BACKGROUND);, +		}, +, +		@Nullable, +		protected Component makeCell(JNode node, int column) {, +			if (column == 0) {, +				JLabel label = new JLabel(node.makeLongString() + "  ", node.getIcon(), SwingConstants.LEFT);, +				label.setOpaque(true);, +				label.setToolTipText(label.getText());, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +import javax.swing.SwingConstants;, +import java.util.HashMap;, +import java.util.Map;, +import org.jetbrains.annotations.Nullable;, +		private Map<Integer, Component> componentCache = new HashMap<Integer, Component>();, +, +		public ResultsTableCellRenderer() {, +			int id = (row << 2) | column;, +			Component comp = componentCache.get(id);, +			if (comp == null && (obj instanceof JNode)) {, +				comp = makeCell((JNode) obj, column);, +				componentCache.put(id, comp);, +			if (comp != null) {, +				updateSelection(comp, isSelected);, +			}, +			return comp;, +		}, +		private void updateSelection(Component comp, boolean isSelected) {, +				comp.setBackground(selectedBackground);, +				comp.setForeground(selectedForeground);, +				comp.setBackground(ContentArea.BACKGROUND);, +		}, +, +		@Nullable, +		protected Component makeCell(JNode node, int column) {, +			if (column == 0) {, +				JLabel label = new JLabel(node.makeLongString() + "  ", node.getIcon(), SwingConstants.LEFT);, +				label.setOpaque(true);, +				label.setToolTipText(label.getText());, +, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +		return "<html><body><nobr>" + name, +				+ "<span style='color:#888888;'> : " + typeStr(type) + "</span>", +				+ "</nobr></body></html>";]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					String s = makeCondition(arg);, +					if (arg.isCompare()) {, +						sb.append(s);, +					} else {, +						sb.append('(').append(s).append(')');, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					String s = makeCondition(arg);, +					if (arg.isCompare()) {, +						sb.append(s);, +					} else {, +						sb.append('(').append(s).append(')');, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +		boolean internalEquals(Object obj) {, +			return type == ((PrimitiveArg) obj).type;, +		}, +, +		@Override, +			this.hash = object.hashCode();, +		boolean internalEquals(Object obj) {, +			return object.equals(((ObjectArg) obj).object);, +		}, +, +		@Override, +		boolean internalEquals(Object obj) {, +			return super.internalEquals(obj), +					&& Arrays.equals(generics, ((GenericObjectArg) obj).generics);, +		}, +, +		@Override, +		boolean internalEquals(Object obj) {, +			return arrayElement.equals(((ArrayArg) obj).arrayElement);, +		}, +, +		@Override, +		boolean internalEquals(Object obj) {, +			return Arrays.equals(possibleTypes, ((UnknownArg) obj).possibleTypes);, +		}, +, +		@Override, +	abstract boolean internalEquals(Object obj);, +, +		return internalEquals(obj);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					String s = makeCondition(arg);, +					if (arg.isCompare()) {, +						sb.append(s);, +					} else {, +						sb.append('(').append(s).append(')');, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +		boolean internalEquals(Object obj) {, +			return type == ((PrimitiveArg) obj).type;, +		}, +, +		@Override, +			this.hash = object.hashCode();, +		boolean internalEquals(Object obj) {, +			return object.equals(((ObjectArg) obj).object);, +		}, +, +		@Override, +		boolean internalEquals(Object obj) {, +			return super.internalEquals(obj), +					&& Arrays.equals(generics, ((GenericObjectArg) obj).generics);, +		}, +, +		@Override, +		boolean internalEquals(Object obj) {, +			return arrayElement.equals(((ArrayArg) obj).arrayElement);, +		}, +, +		@Override, +		boolean internalEquals(Object obj) {, +			return Arrays.equals(possibleTypes, ((UnknownArg) obj).possibleTypes);, +		}, +, +		@Override, +	abstract boolean internalEquals(Object obj);, +, +		return internalEquals(obj);, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java]
[+++ b/build.gradle, +    id "com.github.kt3k.coveralls" version "2.3.1", +    id "info.solidsoft.pitest" version "1.1.4", +//    id "com.github.ben-manes.versions" version "0.8", +        testCompile 'org.hamcrest:hamcrest-library:1.3', +        testCompile 'org.spockframework:spock-core:1.0-groovy-2.4', +    gradleVersion = '2.3', +++ b/build.gradle, +    id "com.github.kt3k.coveralls" version "2.3.1", +    id "info.solidsoft.pitest" version "1.1.4", +//    id "com.github.ben-manes.versions" version "0.8", +        testCompile 'org.hamcrest:hamcrest-library:1.3', +        testCompile 'org.spockframework:spock-core:1.0-groovy-2.4', +    gradleVersion = '2.3', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    id "com.github.kt3k.coveralls" version "2.3.1", +    id "info.solidsoft.pitest" version "1.1.4", +//    id "com.github.ben-manes.versions" version "0.8", +        testCompile 'org.hamcrest:hamcrest-library:1.3', +        testCompile 'org.spockframework:spock-core:1.0-groovy-2.4', +    gradleVersion = '2.3', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, +			passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, +			passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import jadx.core.dex.instructions.args.LiteralArg;, +, +		if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {, +			// inverted, +			this.condition = IfCondition.invert(condition);, +			addArg(els);, +			addArg(th);, +		} else {, +			this.condition = condition;, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, +			passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import jadx.core.dex.instructions.args.LiteralArg;, +, +		if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {, +			// inverted, +			this.condition = IfCondition.invert(condition);, +			addArg(els);, +			addArg(th);, +		} else {, +			this.condition = condition;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +	// all dominators, +	private BitSet doms;, +	// dominance frontier, +	private BitSet domFrontier;, +	// immediate dominator, +	private BlockNode idom;, +	// blocks on which dominates this block, +	public BitSet getDomFrontier() {, +		return domFrontier;, +	}, +, +	public void setDomFrontier(BitSet domFrontier) {, +		this.domFrontier = domFrontier;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, +			passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import jadx.core.dex.instructions.args.LiteralArg;, +, +		if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {, +			// inverted, +			this.condition = IfCondition.invert(condition);, +			addArg(els);, +			addArg(th);, +		} else {, +			this.condition = condition;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +	// all dominators, +	private BitSet doms;, +	// dominance frontier, +	private BitSet domFrontier;, +	// immediate dominator, +	private BlockNode idom;, +	// blocks on which dominates this block, +	public BitSet getDomFrontier() {, +		return domFrontier;, +	}, +, +	public void setDomFrontier(BitSet domFrontier) {, +		this.domFrontier = domFrontier;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IRegion.java, +	boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, +			passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import jadx.core.dex.instructions.args.LiteralArg;, +, +		if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {, +			// inverted, +			this.condition = IfCondition.invert(condition);, +			addArg(els);, +			addArg(th);, +		} else {, +			this.condition = condition;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +	// all dominators, +	private BitSet doms;, +	// dominance frontier, +	private BitSet domFrontier;, +	// immediate dominator, +	private BlockNode idom;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +				LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, +				if (labelAttr != null) {, +					code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +				LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, +				if (labelAttr != null) {, +					code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +	// TODO: avoid name collision with variables names, +	public String getLoopLabel(LoopLabelAttr attr) {, +		String name = "loop" + attr.getLoop().getId();, +		varNames.add(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +				LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, +				if (labelAttr != null) {, +					code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +	// TODO: avoid name collision with variables names, +	public String getLoopLabel(LoopLabelAttr attr) {, +		String name = "loop" + attr.getLoop().getId();, +		varNames.add(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +		LoopLabelAttr labelAttr = region.getInfo().getStart().get(AType.LOOP_LABEL);, +		if (labelAttr != null) {, +			code.startLine(mgen.getNameGen().getLoopLabel(labelAttr)).add(':');, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +				LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, +				if (labelAttr != null) {, +					code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +	// TODO: avoid name collision with variables names, +	public String getLoopLabel(LoopLabelAttr attr) {, +		String name = "loop" + attr.getLoop().getId();, +		varNames.add(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +		LoopLabelAttr labelAttr = region.getInfo().getStart().get(AType.LOOP_LABEL);, +		if (labelAttr != null) {, +			code.startLine(mgen.getNameGen().getLoopLabel(labelAttr)).add(':');, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +	public static final int FIELDS_COUNT = 18;, +, +	public static final AType<LoopLabelAttr> LOOP_LABEL = new AType<LoopLabelAttr>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +				LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, +				if (labelAttr != null) {, +					code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +	// TODO: avoid name collision with variables names, +	public String getLoopLabel(LoopLabelAttr attr) {, +		String name = "loop" + attr.getLoop().getId();, +		varNames.add(name);, +		return name;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +		LoopLabelAttr labelAttr = region.getInfo().getStart().get(AType.LOOP_LABEL);, +		if (labelAttr != null) {, +			code.startLine(mgen.getNameGen().getLoopLabel(labelAttr)).add(':');, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +	public static final int FIELDS_COUNT = 18;, +, +	public static final AType<LoopLabelAttr> LOOP_LABEL = new AType<LoopLabelAttr>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +import java.util.IdentityHashMap;, +		attributes = new IdentityHashMap<AType<?>, IAttribute>(AType.FIELDS_COUNT);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +				LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.FilledNewArrayNode;, +import java.util.Arrays;, +				filledNewArray((FilledNewArrayNode) insn, code);, +			case FILL_ARRAY:, +				assert isFallback();, +				FillArrayNode arrayNode = (FillArrayNode) insn;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +				code.add('{').add(arrStr.substring(1, arrStr.length() - 1)).add('}');, +				break;, +, +	private void filledNewArray(FilledNewArrayNode insn, CodeWriter code) throws CodegenException {, +		useType(code, insn.getArrayType());, +		int c = insn.getArgsCount();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.FilledNewArrayNode;, +import java.util.Arrays;, +				filledNewArray((FilledNewArrayNode) insn, code);, +			case FILL_ARRAY:, +				assert isFallback();, +				FillArrayNode arrayNode = (FillArrayNode) insn;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +				code.add('{').add(arrStr.substring(1, arrStr.length() - 1)).add('}');, +				break;, +, +	private void filledNewArray(FilledNewArrayNode insn, CodeWriter code) throws CodegenException {, +		useType(code, insn.getArrayType());, +		int c = insn.getArgsCount();, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		return "r" + arg.getRegNum();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.FilledNewArrayNode;, +import java.util.Arrays;, +				filledNewArray((FilledNewArrayNode) insn, code);, +			case FILL_ARRAY:, +				assert isFallback();, +				FillArrayNode arrayNode = (FillArrayNode) insn;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +				code.add('{').add(arrStr.substring(1, arrStr.length() - 1)).add('}');, +				break;, +, +	private void filledNewArray(FilledNewArrayNode insn, CodeWriter code) throws CodegenException {, +		useType(code, insn.getArrayType());, +		int c = insn.getArgsCount();, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		return "r" + arg.getRegNum();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +import java.util.ArrayList;, +import java.util.List;, +, +	private final int size;, +		this.size = payload.getSize();, +	public int getSize() {, +		return size;, +	}, +, +	public List<LiteralArg> getLiteralArgs() {, +		List<LiteralArg> list = new ArrayList<LiteralArg>(size);, +		Object array = data;, +		if (array instanceof int[]) {, +			for (int b : (int[]) array) {, +				list.add(InsnArg.lit(b, elemType));, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		List<RegisterArg> args = new LinkedList<RegisterArg>();, +		incrInsn.getRegisterArgs(args);, +		for (RegisterArg iArg : args) {, +			if (assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		List<RegisterArg> args = new LinkedList<RegisterArg>();, +		incrInsn.getRegisterArgs(args);, +		for (RegisterArg iArg : args) {, +			if (assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java, +package jadx.tests.integration.arith;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestArith3 extends IntegrationTest {, +, +	public static class TestCls {, +		private int vp;, +, +		private void test(byte[] buffer) {, +			int n = ((buffer[3] & 255) + 4) + ((buffer[2] & 15) << 8);, +			while (n + 4 < buffer.length) {, +				int c = buffer[n] & 255;, +				int p = (buffer[n + 2] & 255) + ((buffer[n + 1] & 31) << 8);, +				int len = (buffer[n + 4] & 255) + ((buffer[n + 3] & 15) << 8);, +				switch (c) {, +					case 27:, +						this.vp = p;, +						break;, +				}, +				n += len + 5;, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("while (n + 4 < buffer.length) {"));, +		assertThat(code, containsOne("n += len + 5;"));, +		assertThat(code, not(containsString("; n += len + 5) {")));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		List<RegisterArg> args = new LinkedList<RegisterArg>();, +		incrInsn.getRegisterArgs(args);, +		for (RegisterArg iArg : args) {, +			if (assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java, +package jadx.tests.integration.arith;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestArith3 extends IntegrationTest {, +, +	public static class TestCls {, +		private int vp;, +, +		private void test(byte[] buffer) {, +			int n = ((buffer[3] & 255) + 4) + ((buffer[2] & 15) << 8);, +			while (n + 4 < buffer.length) {, +				int c = buffer[n] & 255;, +				int p = (buffer[n + 2] & 255) + ((buffer[n + 1] & 31) << 8);, +				int len = (buffer[n + 4] & 255) + ((buffer[n + 3] & 15) << 8);, +				switch (c) {, +					case 27:, +						this.vp = p;, +						break;, +				}, +				n += len + 5;, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("while (n + 4 < buffer.length) {"));, +		assertThat(code, containsOne("n += len + 5;"));]
[+++ b/.travis.yml]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ForceReturnAttr.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/ForceReturnAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/MethodParameters.java]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--respect-bytecode-access-modifiers"}, description = "don't change original access modifiers"), +	protected boolean respectBytecodeAccessModifiers = false;, +, +		args.setRespectBytecodeAccModifiers(respectBytecodeAccessModifiers);, +	public boolean isRespectBytecodeAccessModifiers() {, +		return respectBytecodeAccessModifiers;, +	}, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--respect-bytecode-access-modifiers"}, description = "don't change original access modifiers"), +	protected boolean respectBytecodeAccessModifiers = false;, +, +		args.setRespectBytecodeAccModifiers(respectBytecodeAccessModifiers);, +	public boolean isRespectBytecodeAccessModifiers() {, +		return respectBytecodeAccessModifiers;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean respectBytecodeAccModifiers = false;, +	public boolean isRespectBytecodeAccModifiers() {, +		return respectBytecodeAccModifiers;, +	}, +, +	public void setRespectBytecodeAccModifiers(boolean respectBytecodeAccModifiers) {, +		this.respectBytecodeAccModifiers = respectBytecodeAccModifiers;, +	}, +, +		sb.append(", respectBytecodeAccModifiers=").append(respectBytecodeAccModifiers);, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--respect-bytecode-access-modifiers"}, description = "don't change original access modifiers"), +	protected boolean respectBytecodeAccessModifiers = false;, +, +		args.setRespectBytecodeAccModifiers(respectBytecodeAccessModifiers);, +	public boolean isRespectBytecodeAccessModifiers() {, +		return respectBytecodeAccessModifiers;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean respectBytecodeAccModifiers = false;, +	public boolean isRespectBytecodeAccModifiers() {, +		return respectBytecodeAccModifiers;, +	}, +, +	public void setRespectBytecodeAccModifiers(boolean respectBytecodeAccModifiers) {, +		this.respectBytecodeAccModifiers = respectBytecodeAccModifiers;, +	}, +, +		sb.append(", respectBytecodeAccModifiers=").append(respectBytecodeAccModifiers);, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--respect-bytecode-access-modifiers"}, description = "don't change original access modifiers"), +	protected boolean respectBytecodeAccessModifiers = false;, +, +		args.setRespectBytecodeAccModifiers(respectBytecodeAccessModifiers);, +	public boolean isRespectBytecodeAccessModifiers() {, +		return respectBytecodeAccessModifiers;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean respectBytecodeAccModifiers = false;, +	public boolean isRespectBytecodeAccModifiers() {, +		return respectBytecodeAccModifiers;, +	}, +, +	public void setRespectBytecodeAccModifiers(boolean respectBytecodeAccModifiers) {, +		this.respectBytecodeAccModifiers = respectBytecodeAccModifiers;, +	}, +, +		sb.append(", respectBytecodeAccModifiers=").append(respectBytecodeAccModifiers);, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.FixAccessModifiers;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean showInconsistentCode;, +	public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, +		this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +	public ClassGen(ClassNode cls, ClassGen parentClsGen) {, +		this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	}, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, +		this.showInconsistentCode = showBadCode;, +			ClassGen inClGen = new ClassGen(innerCls, getParentGen());, +					badCode = false;, +				new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean showInconsistentCode;, +	public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, +		this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +	public ClassGen(ClassNode cls, ClassGen parentClsGen) {, +		this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	}, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, +		this.showInconsistentCode = showBadCode;, +			ClassGen inClGen = new ClassGen(innerCls, getParentGen());, +					badCode = false;, +				new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +		ClassGen clsGen = new ClassGen(cls, args);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean showInconsistentCode;, +	public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, +		this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +	public ClassGen(ClassNode cls, ClassGen parentClsGen) {, +		this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	}, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, +		this.showInconsistentCode = showBadCode;, +			ClassGen inClGen = new ClassGen(innerCls, getParentGen());, +					badCode = false;, +				new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +		ClassGen clsGen = new ClassGen(cls, args);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			new ClassGen(cls, mgen.getClassGen().getParentGen()).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean showInconsistentCode;, +	public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, +		this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +	public ClassGen(ClassNode cls, ClassGen parentClsGen) {, +		this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	}, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, +		this.showInconsistentCode = showBadCode;, +			ClassGen inClGen = new ClassGen(innerCls, getParentGen());, +					badCode = false;, +				new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +		ClassGen clsGen = new ClassGen(cls, args);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			new ClassGen(cls, mgen.getClassGen().getParentGen()).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true, true);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean showInconsistentCode;, +	public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, +		this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +	public ClassGen(ClassNode cls, ClassGen parentClsGen) {, +		this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	}, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, +		this.showInconsistentCode = showBadCode;, +			ClassGen inClGen = new ClassGen(innerCls, getParentGen());, +					badCode = false;, +				new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +		ClassGen clsGen = new ClassGen(cls, args);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			new ClassGen(cls, mgen.getClassGen().getParentGen()).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		ClassGen clsGen = new ClassGen(mth.getParentClass(), null, true, true);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +		if (mth.getBasicBlocks() != null) {, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +	private final boolean showInconsistentCode;, +	public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, +		this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, +	public ClassGen(ClassNode cls, ClassGen parentClsGen) {, +		this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, +	}, +, +	public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, +		this.showInconsistentCode = showBadCode;, +			ClassGen inClGen = new ClassGen(innerCls, getParentGen());, +					badCode = false;, +				new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java]
[+++ b/.editorconfig, +continuation_indent_size = 8  #IntelliJ Idea specific workaround, +max_line_length = 120]
[+++ b/build.gradle, +    compile 'ch.qos.logback:logback-classic:1.0.13', +    gradleVersion = '1.6', +++ b/build.gradle, +    compile 'ch.qos.logback:logback-classic:1.0.13', +    gradleVersion = '1.6', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    compile 'ch.qos.logback:logback-classic:1.0.13', +    gradleVersion = '1.6', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +			case CODE:, +			case LIB:, +			case FONT:, +			case UNKNOWN:, +				return ResContainer.singleBinaryFile(rf.getName(), inputStream);, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +			case CODE:, +			case LIB:, +			case FONT:, +			case UNKNOWN:, +				return ResContainer.singleBinaryFile(rf.getName(), inputStream);, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +import java.io.IOException;, +import org.apache.commons.io.IOUtils;, +	@Nullable, +	private InputStream binary;, +	public static ResContainer singleBinaryFile(String name, InputStream content) {, +		ResContainer resContainer = new ResContainer(name, Collections.emptyList());, +		try {, +			resContainer.binary = new ByteArrayInputStream(IOUtils.toByteArray(content));, +		}, +		catch(IOException e) {, +			LOG.warn("Contents of the binary resource '{}' not saved, got exception {}", name, e);, +		}, +		return resContainer;, +	}, +, +	@Nullable, +	public InputStream getBinary() {, +		return binary;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +			case CODE:, +			case LIB:, +			case FONT:, +			case UNKNOWN:, +				return ResContainer.singleBinaryFile(rf.getName(), inputStream);, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +import java.io.IOException;, +import org.apache.commons.io.IOUtils;, +	@Nullable, +	private InputStream binary;, +	public static ResContainer singleBinaryFile(String name, InputStream content) {, +		ResContainer resContainer = new ResContainer(name, Collections.emptyList());, +		try {, +			resContainer.binary = new ByteArrayInputStream(IOUtils.toByteArray(content));, +		}, +		catch(IOException e) {, +			LOG.warn("Contents of the binary resource '{}' not saved, got exception {}", name, e);, +		}, +		return resContainer;, +	}, +, +	@Nullable, +	public InputStream getBinary() {, +		return binary;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java, +import java.io.FileOutputStream;, +import java.io.InputStream;, +import org.apache.commons.io.IOUtils;, +import org.mockito.internal.util.io.IOUtil;, +		InputStream binary = rc.getBinary();, +		if(binary != null) {, +			try {, +				outFile.getParentFile().mkdirs();, +				FileOutputStream binaryFileStream = new FileOutputStream(outFile);, +				IOUtils.copy(binary, binaryFileStream);, +				binaryFileStream.close();, +				binary.close();, +			}, +			catch(IOException e) {, +				LOG.warn("Resource '{}' not saved, got exception {}", rc.getName(), e);, +			}, +			return;, +		}]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +				LOG.debug("Created new settings.");, +				settings = new JadxSettings();]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +				return new ResTableParser(), +					.decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +				return new ResTableParser(), +					.decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	, +	public void updateContent(String newData) {, +		offset = newData.length();, +		buf = new StringBuilder(newData);, +		line = newData.split(NL).length + 1;, +		code = newData;, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +				return new ResTableParser(), +					.decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	, +	public void updateContent(String newData) {, +		offset = newData.length();, +		buf = new StringBuilder(newData);, +		line = newData.split(NL).length + 1;, +		code = newData;, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private RootNode rootNode;, +	private String appPackageName;, +, +	public BinaryXMLParser(RootNode rootNode) {, +		this.rootNode = rootNode;, +			ConstStorage constStorage = rootNode.getConstValues();, +		currentTag = deobfClassName(currentTag);, +		String shortNsName = null;, +			shortNsName = getAttributeNS(attributeNS);, +			writer.add(shortNsName).add(':');, +			memorizePackageName(attrName, decodedAttr);, +			if(isDeobfCandidateAttr(shortNsName, attrName)) {, +				decodedAttr = deobfClassName(decodedAttr);, +			}, +			decodeAttribute(attributeNS, attrValDataType, attrValData,, +					shortNsName, attrName);, +	private void decodeAttribute(int attributeNS, int attrValDataType, int attrValData,, +			String shortNsName, String attrName) {, +		, +			memorizePackageName(attrName, str);, +			if(isDeobfCandidateAttr(shortNsName, attrName)) {, +				str = deobfClassName(str);, +			}, +	, +	private String deobfClassName(String className) {, +		String newName = XmlDeobf.deobfClassName(rootNode, className,, +				appPackageName);, +		if(newName != null) {, +			return newName;, +		}, +		return className;, +	}, +	, +	private boolean isDeobfCandidateAttr(String shortNsName, String attrName) {, +		String fullName;, +		if(shortNsName != null) {, +			fullName = shortNsName + ":" + attrName;, +		}, +		else {, +			return false;, +		}, +		return "android:name".equals(fullName);, +	}, +	, +	private void memorizePackageName(String attrName, String attrValue) {, +		if("manifest".equals(currentTag) && "package".equals(attrName)) {, +			appPackageName = attrValue;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +				return new ResTableParser(), +					.decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	, +	public void updateContent(String newData) {, +		offset = newData.length();, +		buf = new StringBuilder(newData);, +		line = newData.split(NL).length + 1;, +		code = newData;, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private RootNode rootNode;, +	private String appPackageName;, +, +	public BinaryXMLParser(RootNode rootNode) {, +		this.rootNode = rootNode;, +			ConstStorage constStorage = rootNode.getConstValues();, +		currentTag = deobfClassName(currentTag);, +		String shortNsName = null;, +			shortNsName = getAttributeNS(attributeNS);, +			writer.add(shortNsName).add(':');, +			memorizePackageName(attrName, decodedAttr);, +			if(isDeobfCandidateAttr(shortNsName, attrName)) {, +				decodedAttr = deobfClassName(decodedAttr);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +import org.jetbrains.annotations.Nullable;, +, +	@Nullable, +	public FieldArg(FieldInfo field, @Nullable InsnArg reg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +import org.jetbrains.annotations.Nullable;, +, +	@Nullable, +	public FieldArg(FieldInfo field, @Nullable InsnArg reg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java, +import org.jetbrains.annotations.NotNull;, +, +	public InsnWrapArg(@NotNull InsnNode insn) {, +	public int hashCode() {, +		return wrappedInsn.hashCode();, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (!(o instanceof InsnWrapArg)) {, +			return false;, +		}, +		InsnWrapArg that = (InsnWrapArg) o;, +		InsnNode thisInsn = wrappedInsn;, +		InsnNode thatInsn = that.wrappedInsn;, +		if (!thisInsn.isSame(thatInsn)) {, +			return false;, +		}, +		int count = thisInsn.getArgsCount();, +		for (int i = 0; i < count; i++) {, +			if (!thisInsn.getArg(i).equals(thatInsn.getArg(i))) {, +				return false;, +			}, +		}, +		return true;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +import org.jetbrains.annotations.Nullable;, +, +	@Nullable, +	public FieldArg(FieldInfo field, @Nullable InsnArg reg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java, +import org.jetbrains.annotations.NotNull;, +, +	public InsnWrapArg(@NotNull InsnNode insn) {, +	public int hashCode() {, +		return wrappedInsn.hashCode();, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (!(o instanceof InsnWrapArg)) {, +			return false;, +		}, +		InsnWrapArg that = (InsnWrapArg) o;, +		InsnNode thisInsn = wrappedInsn;, +		InsnNode thatInsn = that.wrappedInsn;, +		if (!thisInsn.isSame(thatInsn)) {, +			return false;, +		}, +		int count = thisInsn.getArgsCount();, +		for (int i = 0; i < count; i++) {, +			if (!thisInsn.getArg(i).equals(thatInsn.getArg(i))) {, +				return false;, +			}, +		}, +		return true;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/NamedArg.java, +import org.jetbrains.annotations.NotNull;, +, +	@NotNull, +	public NamedArg(@NotNull String name, @NotNull ArgType type) {, +	@NotNull, +	public void setName(@NotNull String name) {, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (!(o instanceof NamedArg)) {, +			return false;, +		}, +		return name.equals(((NamedArg) o).name);, +, +	}, +, +	@Override, +	public int hashCode() {, +		return name.hashCode();]
[+++ b/.travis.yml, +# override install to skip 'gradle assemble', +install:, +  - true, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				return new InsnNode(InsnType.NOP, 0);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				return new InsnNode(InsnType.NOP, 0);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +import java.util.EnumSet;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Set;, +, +		removeEmptyBlocks(mth);, +		if (insn.getType() != InsnType.IF) {, +			return false;, +		}, +		return targetBlock == curBlock;, +			block.getInstructions().removeIf(insn -> {, +				InsnType insnType = insn.getType();, +				return insnType == InsnType.GOTO || insnType == InsnType.NOP;, +			});, +	private void removeEmptyBlocks(MethodNode mth) {, +		mth.getBasicBlocks().removeIf(block ->, +				block.getInstructions().isEmpty(), +						&& block.getPredecessors().isEmpty(), +						&& block.getSuccessors().isEmpty(), +		);, +	}]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private boolean checkForUpdates = false;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private boolean checkForUpdates = false;, +++ b/version, +0.6.1]
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +		if (resCls == null) {, +			// We are in an APK without code therefore we don't have to update an 'R' class with the resources, +			return null;, +		}, +	private static void addResourceFields(ClassNode resCls, ResourceStorage resStorage, boolean rClsExists) {, +			for (ClassNode innerClass : resCls.getInnerClasses()) {, +				ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + "$" + name,, +				resCls.addInnerClass(newTypeCls);, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +		if (resCls == null) {, +			// We are in an APK without code therefore we don't have to update an 'R' class with the resources, +			return null;, +		}, +	private static void addResourceFields(ClassNode resCls, ResourceStorage resStorage, boolean rClsExists) {, +			for (ClassNode innerClass : resCls.getInnerClasses()) {, +				ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + "$" + name,, +				resCls.addInnerClass(newTypeCls);, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		LOG.warn("No dex files found in {}", file);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public static final String INDENT = "\t";, +	public boolean isEmpty() {, +		return buf.length() == 0;, +	}, +, +	@Override, +	public int hashCode() {, +		return buf.toString().hashCode();, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (!(o instanceof CodeWriter)) {, +			return false;, +		}, +		CodeWriter that = (CodeWriter) o;, +		return buf.toString().equals(that.buf.toString());, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public static final String INDENT = "\t";, +	public boolean isEmpty() {, +		return buf.length() == 0;, +	}, +, +	@Override, +	public int hashCode() {, +		return buf.toString().hashCode();, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (!(o instanceof CodeWriter)) {, +			return false;, +		}, +		CodeWriter that = (CodeWriter) o;, +		return buf.toString().equals(that.buf.toString());, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public CodeWriter arg(InsnNode insn, int arg) throws CodegenException {, +	public CodeWriter arg(InsnArg arg) throws CodegenException {, +	public CodeWriter arg(InsnArg arg, boolean wrap) throws CodegenException {, +		if (arg.isRegister()) {, +			code.add(mgen.makeArgName((RegisterArg) arg));, +		} else if (arg.isLiteral()) {, +			code.add(lit((LiteralArg) arg));, +		} else if (arg.isInsnWrap()) {, +			code.add(((NamedArg) arg).getName());, +				code.add(sfield(f.getField()));, +				code.add(ifield(f.getField(), regArg));, +		return code;, +			return arg(arg).toString();, +		CodeWriter argStr = arg(arg);, +			if (fn != null && fn.getAccessFlags().isFinal()) {, +	}, +				if (wrap) {, +				}, +				if (wrap) {, +				}, +				if (insn.getArgsCount() != 0) {, +				} else {, +				}, +				for (int i = 0; i < dim - 1; i++) {, +				}, +			if (i + 1 < c) {, +		}, +					CodeWriter argStr = arg(arg);, +		CodeWriter v1 = arg(insn.getArg(0));, +		CodeWriter v2 = arg(insn.getArg(1));, +			CodeWriter res = arg(insn.getResult());, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public static final String INDENT = "\t";, +	public boolean isEmpty() {, +		return buf.length() == 0;, +	}, +, +	@Override, +	public int hashCode() {, +		return buf.toString().hashCode();, +	}, +, +	@Override, +	public boolean equals(Object o) {, +		if (this == o) {, +			return true;, +		}, +		if (!(o instanceof CodeWriter)) {, +			return false;, +		}, +		CodeWriter that = (CodeWriter) o;, +		return buf.toString().equals(that.buf.toString());, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public CodeWriter arg(InsnNode insn, int arg) throws CodegenException {]
[+++ b/.gitlab-ci.yml, +    - sed -i " 1 s/.*/&-b$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				RegisterArg callArg = getCallMthArg(callMth, i - startArgNum);, +				if (callArg != null && callArg.contains(AFlag.SKIP_ARG)) {, +					continue;, +				}, +	private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num) {, +		if (callMth == null) {, +			return null;, +		}, +		List<RegisterArg> args = callMth.getArguments(false);, +		if (args != null && num < args.size()) {, +			return args.get(num);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				RegisterArg callArg = getCallMthArg(callMth, i - startArgNum);, +				if (callArg != null && callArg.contains(AFlag.SKIP_ARG)) {, +					continue;, +				}, +	private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num) {, +		if (callMth == null) {, +			return null;, +		}, +		List<RegisterArg> args = callMth.getArguments(false);, +		if (args != null && num < args.size()) {, +			return args.get(num);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.SSAVar;, +			// remove synthetic constructor for inner classes, +					List<RegisterArg> args = mth.getArguments(false);, +					if (constr.isThis() && !args.isEmpty()) {, +						// remove first arg for non-static class (references to outer class), +						if (args.get(0).getType().equals(cls.getParentClass().getClassInfo().getType())) {, +							args.get(0).add(AFlag.SKIP_ARG);, +						}, +						// remove unused args, +						for (RegisterArg arg : args) {, +							SSAVar sVar = arg.getSVar();, +							if (sVar != null && sVar.getUseCount() == 0) {, +								arg.add(AFlag.SKIP_ARG);, +							}, +						}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				RegisterArg callArg = getCallMthArg(callMth, i - startArgNum);, +				if (callArg != null && callArg.contains(AFlag.SKIP_ARG)) {, +					continue;, +				}, +	private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num) {, +		if (callMth == null) {, +			return null;, +		}, +		List<RegisterArg> args = callMth.getArguments(false);, +		if (args != null && num < args.size()) {, +			return args.get(num);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.SSAVar;, +			// remove synthetic constructor for inner classes, +					List<RegisterArg> args = mth.getArguments(false);, +					if (constr.isThis() && !args.isEmpty()) {, +						// remove first arg for non-static class (references to outer class), +						if (args.get(0).getType().equals(cls.getParentClass().getClassInfo().getType())) {, +							args.get(0).add(AFlag.SKIP_ARG);, +						}, +						// remove unused args, +						for (RegisterArg arg : args) {, +							SSAVar sVar = arg.getSVar();, +							if (sVar != null && sVar.getUseCount() == 0) {, +								arg.add(AFlag.SKIP_ARG);, +							}, +						}, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInvoke1.java, +package jadx.tests.integration.invoke;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.io.IOException;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestInvoke1 extends IntegrationTest {, +, +	public static class TestCls {, +, +		private A is;, +, +		private C test(int start) throws IOException {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if this class from same package, +			if(classInfo.getPackage().equals(cls.getPackage())), +				return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if this class from same package, +			if(classInfo.getPackage().equals(cls.getPackage())), +				return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if this class from same package, +			if(classInfo.getPackage().equals(cls.getPackage())), +				return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.ConstClassInsn;, +import jadx.core.dex.instructions.ConstStringInsn;, +			case CONST_STR:, +				String str = ((ConstStringInsn) insn).getString();, +				code.add(StringUtils.unescapeString(str));, +				break;, +, +			case CONST_CLASS:, +				ArgType clsType = ((ConstClassInsn) insn).getClsType();, +				code.add(useType(clsType)).add(".class");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if this class from same package, +			if(classInfo.getPackage().equals(cls.getPackage())), +				return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.ConstClassInsn;, +import jadx.core.dex.instructions.ConstStringInsn;, +			case CONST_STR:, +				String str = ((ConstStringInsn) insn).getString();, +				code.add(StringUtils.unescapeString(str));, +				break;, +, +			case CONST_CLASS:, +				ArgType clsType = ((ConstClassInsn) insn).getClsType();, +				code.add(useType(clsType)).add(".class");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassInsn.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.InsnNode;, +, +public class ConstClassInsn extends InsnNode {, +, +	private final ArgType clsType;, +, +	public ConstClassInsn(ArgType clsType) {, +		super(InsnType.CONST_CLASS, 0);, +		this.clsType = clsType;, +	}, +, +	public ArgType getClsType() {, +		return clsType;, +	}, +, +	@Override, +	public String toString() {, +		return super.toString() + " " + clsType;, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			// don't add import if this class from same package, +			if(classInfo.getPackage().equals(cls.getPackage())), +				return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.ConstClassInsn;, +import jadx.core.dex.instructions.ConstStringInsn;, +			case CONST_STR:, +				String str = ((ConstStringInsn) insn).getString();, +				code.add(StringUtils.unescapeString(str));, +				break;, +, +			case CONST_CLASS:, +				ArgType clsType = ((ConstClassInsn) insn).getClsType();, +				code.add(useType(clsType)).add(".class");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassInsn.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.InsnNode;, +, +public class ConstClassInsn extends InsnNode {, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			if (jadxArgs.processArgs(args)) {, +	static void processAndSave(JadxCLIArgs inputArgs) {, +		JadxDecompiler jadx = new JadxDecompiler(inputArgs.toJadxArgs());, +		jadx.load();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			if (jadxArgs.processArgs(args)) {, +	static void processAndSave(JadxCLIArgs inputArgs) {, +		JadxDecompiler jadx = new JadxDecompiler(inputArgs.toJadxArgs());, +		jadx.load();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import java.util.stream.Collectors;, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, +public class JadxCLIArgs {, +	protected List<String> files = new ArrayList<>(1);, +	protected String outDir;, +	protected String outDirSrc;, +	protected String outDirRes;, +	protected int threadsCount = JadxArgs.DEFAULT_THREADS_COUNT;, +	public JadxArgs toJadxArgs() {, +		JadxArgs args = new JadxArgs();, +		args.setInputFiles(files.stream().map(FileUtils::toFile).collect(Collectors.toList()));, +		args.setOutDir(FileUtils.toFile(outDir));, +		args.setOutDirSrc(FileUtils.toFile(outDirSrc));, +		args.setOutDirRes(FileUtils.toFile(outDirRes));, +		args.setThreadsCount(threadsCount);, +		args.setSkipSources(skipSources);, +		args.setSkipResources(skipResources);, +		args.setFallbackMode(fallbackMode);, +		args.setShowInconsistentCode(showInconsistentCode);, +		args.setCfgOutput(cfgOutput);, +		args.setRawCFGOutput(rawCfgOutput);, +		args.setReplaceConsts(replaceConsts);, +		args.setDeobfuscationOn(deobfuscationOn);, +		args.setDeobfuscationForceSave(deobfuscationForceSave);, +		args.setDeobfuscationMinLength(deobfuscationMinLength);, +		args.setDeobfuscationMaxLength(deobfuscationMaxLength);, +		args.setUseSourceNameAsClassAlias(deobfuscationUseSourceNameAsAlias);, +		args.setEscapeUnicode(escapeUnicode);, +		args.setExportAsGradleProject(exportAsGradleProject);, +		args.setUseImports(useImports);, +		return args;, +	}, +, +	public List<String> getFiles() {, +		return files;, +	public String getOutDir() {, +		return outDir;, +	public String getOutDirSrc() {, +		return outDirSrc;, +	public String getOutDirRes() {, +		return outDirRes;, +	public boolean isUseImports() {, +	public boolean isDeobfuscationUseSourceNameAsAlias() {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			if (jadxArgs.processArgs(args)) {, +	static void processAndSave(JadxCLIArgs inputArgs) {, +		JadxDecompiler jadx = new JadxDecompiler(inputArgs.toJadxArgs());, +		jadx.load();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import java.util.stream.Collectors;, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, +public class JadxCLIArgs {, +	protected List<String> files = new ArrayList<>(1);, +	protected String outDir;, +	protected String outDirSrc;, +	protected String outDirRes;, +	protected int threadsCount = JadxArgs.DEFAULT_THREADS_COUNT;, +	public JadxArgs toJadxArgs() {, +		JadxArgs args = new JadxArgs();, +		args.setInputFiles(files.stream().map(FileUtils::toFile).collect(Collectors.toList()));, +		args.setOutDir(FileUtils.toFile(outDir));, +		args.setOutDirSrc(FileUtils.toFile(outDirSrc));, +		args.setOutDirRes(FileUtils.toFile(outDirRes));, +		args.setThreadsCount(threadsCount);, +		args.setSkipSources(skipSources);, +		args.setSkipResources(skipResources);, +		args.setFallbackMode(fallbackMode);, +		args.setShowInconsistentCode(showInconsistentCode);, +		args.setCfgOutput(cfgOutput);, +		args.setRawCFGOutput(rawCfgOutput);, +		args.setReplaceConsts(replaceConsts);, +		args.setDeobfuscationOn(deobfuscationOn);, +		args.setDeobfuscationForceSave(deobfuscationForceSave);, +		args.setDeobfuscationMinLength(deobfuscationMinLength);, +		args.setDeobfuscationMaxLength(deobfuscationMaxLength);, +		args.setUseSourceNameAsClassAlias(deobfuscationUseSourceNameAsAlias);, +		args.setEscapeUnicode(escapeUnicode);, +		args.setExportAsGradleProject(exportAsGradleProject);, +		args.setUseImports(useImports);, +		return args;, +	}, +, +	public List<String> getFiles() {, +		return files;, +	public String getOutDir() {, +		return outDir;, +	public String getOutDirSrc() {]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			boolean aliasFromPreset = false;, +			String aliasToUse = null;, +			for(MethodInfo mth : o.getMethods()){, +				if(mth.isAliasFromPreset()) {, +					aliasToUse = mth.getAlias();, +					aliasFromPreset = true;, +				}, +			}, +			for(MethodInfo mth : o.getMethods()){, +				if(aliasToUse == null) {, +					aliasToUse = mth.getAlias();, +				mth.setAlias(aliasToUse);, +				mth.setAliasFromPreset(aliasFromPreset);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		addLineIndent();, +		addLineIndent();, +		addLineIndent();, +	private CodeWriter addLineIndent() {, +	public CodeWriter addIndent() {, +		add(INDENT);, +		return this;, +	}, +, +	public int getLine() {, +		return line;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		addLineIndent();, +		addLineIndent();, +		addLineIndent();, +	private CodeWriter addLineIndent() {, +	public CodeWriter addIndent() {, +		add(INDENT);, +		return this;, +	}, +, +	public int getLine() {, +		return line;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		code.incIndent();, +		code.decIndent();, +		boolean addBreak = true;, +			if (!RegionUtils.hasExitEdge(c)) {, +				addBreak = false;, +		}, +		if (addBreak) {, +			code.startLine().addIndent().add("break;");, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		addLineIndent();, +		addLineIndent();, +		addLineIndent();, +	private CodeWriter addLineIndent() {, +	public CodeWriter addIndent() {, +		add(INDENT);, +		return this;, +	}, +, +	public int getLine() {, +		return line;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		code.incIndent();, +		code.decIndent();, +		boolean addBreak = true;, +			if (!RegionUtils.hasExitEdge(c)) {, +				addBreak = false;, +		}, +		if (addBreak) {, +			code.startLine().addIndent().add("break;");, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +public abstract class InternalJadxTest extends TestUtils {, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +		addLineIndent();, +		addLineIndent();, +		addLineIndent();, +	private CodeWriter addLineIndent() {, +	public CodeWriter addIndent() {, +		add(INDENT);, +		return this;, +	}, +, +	public int getLine() {, +		return line;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		code.incIndent();, +		code.decIndent();, +		boolean addBreak = true;, +			if (!RegionUtils.hasExitEdge(c)) {, +				addBreak = false;, +		}, +		if (addBreak) {, +			code.startLine().addIndent().add("break;");, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +public abstract class InternalJadxTest extends TestUtils {, +++ b/jadx-core/src/test/java/jadx/api/TestUtils.java, +package jadx.api;, +, +import jadx.core.codegen.CodeWriter;, +, +public class TestUtils {, +, +	public static String indent(int indent) {, +		StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT.length());, +		for (int i = 0; i < indent; i++) {, +			sb.append(CodeWriter.INDENT);, +		}, +		return sb.toString();]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +				passes.add(DotGraphVisitor.dumpRaw(outDir));, +				passes.add(DotGraphVisitor.dump(outDir));, +				passes.add(DotGraphVisitor.dumpRegions(outDir));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +				passes.add(DotGraphVisitor.dumpRaw(outDir));, +				passes.add(DotGraphVisitor.dump(outDir));, +				passes.add(DotGraphVisitor.dumpRegions(outDir));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +	public static DotGraphVisitor dump(File outDir) {, +		return new DotGraphVisitor(outDir, false, false);, +	}, +, +	public static DotGraphVisitor dumpRaw(File outDir) {, +		return new DotGraphVisitor(outDir, false, true);, +	}, +, +	public static DotGraphVisitor dumpRegions(File outDir) {, +		return new DotGraphVisitor(outDir, true, false);, +	}, +, +	public static DotGraphVisitor dumpRawRegions(File outDir) {, +		return new DotGraphVisitor(outDir, true, true);, +	}, +, +	private DotGraphVisitor(File outDir, boolean useRegions, boolean rawInsn) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return dexBuf.strings().get(index);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +				String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +				String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +import java.util.ArrayList;, +	public static IfCondition merge(Mode mode, IfCondition a, IfCondition b) {, +		if (a.getMode() == mode) {, +			IfCondition n = new IfCondition(a);, +			n.addArg(b);, +			return n;, +		} else if (b.getMode() == mode) {, +			IfCondition n = new IfCondition(b);, +			n.addArg(a);, +			return n;, +		} else {, +			return new IfCondition(mode, Arrays.asList(a, b));, +	public static enum Mode {, +	private final Mode mode;, +		this.mode = Mode.COMPARE;, +	private IfCondition(Mode mode, List<IfCondition> args) {, +	private IfCondition(IfCondition c) {, +		this.mode = c.mode;, +		this.compare = c.compare;, +		this.args = new ArrayList<IfCondition>(c.args);, +	}, +, +	public Mode getMode() {, +	public void addArg(IfCondition c) {, +		args.add(c);, +	}, +, +		return mode == Mode.COMPARE;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +				String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +import java.util.ArrayList;, +	public static IfCondition merge(Mode mode, IfCondition a, IfCondition b) {, +		if (a.getMode() == mode) {, +			IfCondition n = new IfCondition(a);, +			n.addArg(b);, +			return n;, +		} else if (b.getMode() == mode) {, +			IfCondition n = new IfCondition(b);, +			n.addArg(a);, +			return n;, +		} else {, +			return new IfCondition(mode, Arrays.asList(a, b));, +	public static enum Mode {, +	private final Mode mode;, +		this.mode = Mode.COMPARE;, +	private IfCondition(Mode mode, List<IfCondition> args) {, +	private IfCondition(IfCondition c) {, +		this.mode = c.mode;, +		this.compare = c.compare;, +		this.args = new ArrayList<IfCondition>(c.args);, +	}, +, +	public Mode getMode() {, +	public void addArg(IfCondition c) {, +		args.add(c);, +	}, +, +		return mode == Mode.COMPARE;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import static jadx.core.dex.regions.IfCondition.Mode;, +					IfCondition nestedCondition = IfCondition.fromIfNode(nestedIfInsn);, +						condition = IfCondition.merge(Mode.OR, ifRegion.getCondition(), nestedCondition);, +						condition = IfCondition.merge(Mode.AND, ifRegion.getCondition(), nestedCondition);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +				String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +import java.util.ArrayList;, +	public static IfCondition merge(Mode mode, IfCondition a, IfCondition b) {, +		if (a.getMode() == mode) {, +			IfCondition n = new IfCondition(a);, +			n.addArg(b);, +			return n;, +		} else if (b.getMode() == mode) {, +			IfCondition n = new IfCondition(b);, +			n.addArg(a);, +			return n;, +		} else {, +			return new IfCondition(mode, Arrays.asList(a, b));, +	public static enum Mode {, +	private final Mode mode;, +		this.mode = Mode.COMPARE;, +	private IfCondition(Mode mode, List<IfCondition> args) {, +	private IfCondition(IfCondition c) {, +		this.mode = c.mode;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +				checkInsn(mth, insn, toRemove);, +	private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {, +		if (insn.contains(AFlag.DONT_INLINE)) {, +			return;, +		}, +		InsnType insnType = insn.getType();, +		if (insnType != InsnType.CONST && insnType != InsnType.MOVE) {, +			return;, +			return;, +			return;, +		replaceConst(mth, insn, lit, toRemove);, +	private static void replaceConst(MethodNode mth, InsnNode constInsn, long literal, List<InsnNode> toRemove) {, +		SSAVar ssaVar = constInsn.getResult().getSVar();, +		List<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());, +		for (RegisterArg arg : useList) {, +			if (replaceArg(mth, arg, literal, constInsn, toRemove)) {, +				replaceCount++;, +		}, +		if (replaceCount == useList.size()) {, +			toRemove.add(constInsn);, +		}, +	}, +, +	private static boolean replaceArg(MethodNode mth, RegisterArg arg, long literal, InsnNode constInsn, List<InsnNode> toRemove) {, +		InsnNode useInsn = arg.getParentInsn();, +		if (useInsn == null) {, +			return false;, +		}, +		InsnType insnType = useInsn.getType();, +		if (insnType == InsnType.PHI || insnType == InsnType.MERGE) {, +			return false;, +		}, +		ArgType argType = arg.getInitType();, +		LiteralArg litArg = InsnArg.lit(literal, argType);, +		if (!useInsn.replaceArg(arg, litArg)) {, +			return false;, +		// arg replaced, made some optimizations, +		FieldNode fieldNode = null;, +			fieldNode = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +			fieldNode = mth.getParentClass().getConstField((int) literal, false);, +		if (fieldNode != null) {, +			litArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0));, +		}, +, +		if (insnType == InsnType.RETURN) {, +			useInsn.setSourceLine(constInsn.getSourceLine());, +		} else if (insnType == InsnType.MOVE) {, +			try {, +				replaceConst(mth, useInsn, literal, toRemove);, +			} catch (StackOverflowError e) {, +				throw new JadxOverflowException("Stack overflow at const inline visitor");, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +				checkInsn(mth, insn, toRemove);, +	private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {, +		if (insn.contains(AFlag.DONT_INLINE)) {, +			return;, +		}, +		InsnType insnType = insn.getType();, +		if (insnType != InsnType.CONST && insnType != InsnType.MOVE) {, +			return;, +			return;, +			return;, +		replaceConst(mth, insn, lit, toRemove);, +	private static void replaceConst(MethodNode mth, InsnNode constInsn, long literal, List<InsnNode> toRemove) {, +		SSAVar ssaVar = constInsn.getResult().getSVar();, +		List<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());, +		for (RegisterArg arg : useList) {, +			if (replaceArg(mth, arg, literal, constInsn, toRemove)) {, +				replaceCount++;, +		}, +		if (replaceCount == useList.size()) {, +			toRemove.add(constInsn);, +		}, +	}, +, +	private static boolean replaceArg(MethodNode mth, RegisterArg arg, long literal, InsnNode constInsn, List<InsnNode> toRemove) {, +		InsnNode useInsn = arg.getParentInsn();, +		if (useInsn == null) {, +			return false;, +		}, +		InsnType insnType = useInsn.getType();, +		if (insnType == InsnType.PHI || insnType == InsnType.MERGE) {, +			return false;, +		}, +		ArgType argType = arg.getInitType();, +		LiteralArg litArg = InsnArg.lit(literal, argType);, +		if (!useInsn.replaceArg(arg, litArg)) {, +			return false;, +		// arg replaced, made some optimizations, +		FieldNode fieldNode = null;, +			fieldNode = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +			fieldNode = mth.getParentClass().getConstField((int) literal, false);, +		if (fieldNode != null) {, +			litArg.wrapInstruction(new IndexInsnNode(InsnType.SGET, fieldNode.getFieldInfo(), 0));, +		}, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), +	protected String outDirNameSrc;, +, +	@Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), +	protected String outDirNameRes;, +, +	private File outputDirSrc;, +	private File outputDirRes;, +			if(outDirNameSrc != null) {, +				outputDirSrc = new File(outDirNameSrc);, +			}, +			if(outDirNameRes != null) {, +				outputDirRes = new File(outDirNameRes);, +			}, +				if(outputDirSrc == null) {, +					outputDirSrc = new File(outputDir, "source");, +				if(outputDirRes == null) {, +					outputDirRes = new File(outputDir, "res");, +				}, +			}, +			, +	@Override, +	public File getOutDirSrc() {, +		return outputDirSrc;, +	}, +, +	@Override, +	public File getOutDirRes() {, +		return outputDirRes;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), +	protected String outDirNameSrc;, +, +	@Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), +	protected String outDirNameRes;, +, +	private File outputDirSrc;, +	private File outputDirRes;, +			if(outDirNameSrc != null) {, +				outputDirSrc = new File(outDirNameSrc);, +			}, +			if(outDirNameRes != null) {, +				outputDirRes = new File(outDirNameRes);, +			}, +				if(outputDirSrc == null) {, +					outputDirSrc = new File(outputDir, "source");, +				if(outputDirRes == null) {, +					outputDirRes = new File(outputDir, "res");, +				}, +			}, +			, +	@Override, +	public File getOutDirSrc() {, +		return outputDirSrc;, +	}, +, +	@Override, +	public File getOutDirRes() {, +		return outputDirRes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	, +	File getOutDirSrc();, +	, +	File getOutDirRes();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), +	protected String outDirNameSrc;, +, +	@Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), +	protected String outDirNameRes;, +, +	private File outputDirSrc;, +	private File outputDirRes;, +			if(outDirNameSrc != null) {, +				outputDirSrc = new File(outDirNameSrc);, +			}, +			if(outDirNameRes != null) {, +				outputDirRes = new File(outDirNameRes);, +			}, +				if(outputDirSrc == null) {, +					outputDirSrc = new File(outputDir, "source");, +				if(outputDirRes == null) {, +					outputDirRes = new File(outputDir, "res");, +				}, +			}, +			, +	@Override, +	public File getOutDirSrc() {, +		return outputDirSrc;, +	}, +, +	@Override, +	public File getOutDirRes() {, +		return outputDirRes;, +	}]
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.ZipSecurity;, +		if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {, +			return;, +		}, +		if(!ZipSecurity.isValidZipEntryName(fileName)) {, +			return;, +		}, +++ b/.DS_Store, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.ZipSecurity;, +		if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {, +			return;, +		}, +		if(!ZipSecurity.isValidZipEntryName(fileName)) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +import jadx.core.utils.files.ZipSecurity;, +++ b/.DS_Store, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.ZipSecurity;, +		if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {, +			return;, +		}, +		if(!ZipSecurity.isValidZipEntryName(fileName)) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +import jadx.core.utils.files.ZipSecurity;, +++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +	private static final int MAX_SIZE_DIFF = 10;, +			LOG.error("Path traversal attack detected, invalid name: {}", entryName);, +			LOG.error("Path traversal attack detected, invalid name: {}", entryName);, +			LOG.error("Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",, +					compressedSize, uncompressedSize, entry.getName());]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainDropTarget.java, +package jadx.gui.ui;, +, +import java.awt.datatransfer.DataFlavor;, +import java.awt.datatransfer.Transferable;, +import java.awt.dnd.DnDConstants;, +import java.awt.dnd.DropTargetDragEvent;, +import java.awt.dnd.DropTargetDropEvent;, +import java.awt.dnd.DropTargetEvent;, +import java.awt.dnd.DropTargetListener;, +import java.io.File;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +/**, + * Enables drop support from external applications for the {@link MainWindow} (load dropped APK file), + */, +public class MainDropTarget implements DropTargetListener {, +, +	private static final Logger LOG = LoggerFactory.getLogger(MainDropTarget.class);, +, +	private final MainWindow mainWindow;, +, +	public MainDropTarget(MainWindow mainWindow) {, +		super();, +		this.mainWindow = mainWindow;, +	}, +, +	protected void processDrag(DropTargetDragEvent dtde) {, +		if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {, +			dtde.acceptDrag(DnDConstants.ACTION_COPY);, +		} else {, +			dtde.rejectDrag();, +		}, +	}, +, +	@Override, +	public void dragEnter(DropTargetDragEvent dtde) {, +		processDrag(dtde);, +	}, +, +	@Override, +	public void dragOver(DropTargetDragEvent dtde) {, +		processDrag(dtde);, +	}, +, +	@Override, +	public void dropActionChanged(DropTargetDragEvent dtde) {, +	}, +, +	@Override, +	public void drop(DropTargetDropEvent dtde) {, +		if (!dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {, +			dtde.rejectDrop();, +			return;, +		}, +		dtde.acceptDrop(dtde.getDropAction());, +		try {, +, +			Transferable transferable = dtde.getTransferable();, +			List<File> transferData = (List<File>) transferable.getTransferData(DataFlavor.javaFileListFlavor);, +			if (transferData != null && transferData.size() > 0) {, +				dtde.dropComplete(true);, +				// load first file, +				mainWindow.openFile(transferData.get(0));, +			}, +, +		} catch (Exception e) {, +			LOG.error("File drop operation failed", e);, +		}, +	}, +, +	@Override, +	public void dragExit(DropTargetEvent dte) {, +, +	}, +, +}, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainDropTarget.java, +package jadx.gui.ui;, +, +import java.awt.datatransfer.DataFlavor;, +import java.awt.datatransfer.Transferable;, +import java.awt.dnd.DnDConstants;, +import java.awt.dnd.DropTargetDragEvent;, +import java.awt.dnd.DropTargetDropEvent;, +import java.awt.dnd.DropTargetEvent;, +import java.awt.dnd.DropTargetListener;, +import java.io.File;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +/**, + * Enables drop support from external applications for the {@link MainWindow} (load dropped APK file), + */, +public class MainDropTarget implements DropTargetListener {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import com.android.dex.Dex.Section;, +		Section section = dex.openSection(offset);, +			Section ss = dex.openSection(section.readInt());, +		Section section = dex.openSection(offset);, +			Section anSection = dex.openSection(section.readInt());, +	public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisibility) throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import com.android.dex.Dex.Section;, +		Section section = dex.openSection(offset);, +			Section ss = dex.openSection(section.readInt());, +		Section section = dex.openSection(offset);, +			Section anSection = dex.openSection(section.readInt());, +	public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisibility) throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import com.android.dex.Dex.Section;, +	private final Section section;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import com.android.dex.Dex.Section;, +		Section section = dex.openSection(offset);, +			Section ss = dex.openSection(section.readInt());, +		Section section = dex.openSection(offset);, +			Section anSection = dex.openSection(section.readInt());, +	public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisibility) throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import com.android.dex.Dex.Section;, +	private final Section section;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +import com.android.dex.Dex.Section;, +	protected final Section in;, +	public EncValueParser(DexNode dex, Section in) {, +				return AnnotationsParser.readAnnotation(dex, in, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import com.android.dex.Dex.Section;, +		Section section = dex.openSection(offset);, +			Section ss = dex.openSection(section.readInt());, +		Section section = dex.openSection(offset);, +			Section anSection = dex.openSection(section.readInt());, +	public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisibility) throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import com.android.dex.Dex.Section;, +	private final Section section;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +import com.android.dex.Dex.Section;, +	protected final Section in;, +	public EncValueParser(DexNode dex, Section in) {, +				return AnnotationsParser.readAnnotation(dex, in, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/StaticValuesParser.java, +import com.android.dex.Dex.Section;, +	public StaticValuesParser(DexNode dex, Section in) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, +	public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import com.android.dex.Dex.Section;, +		Section section = dex.openSection(offset);, +			Section ss = dex.openSection(section.readInt());, +		Section section = dex.openSection(offset);, +			Section anSection = dex.openSection(section.readInt());, +	public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisibility) throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import com.android.dex.Dex.Section;, +	private final Section section;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +import com.android.dex.Dex.Section;, +	protected final Section in;, +	public EncValueParser(DexNode dex, Section in) {, +				return AnnotationsParser.readAnnotation(dex, in, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/StaticValuesParser.java, +import com.android.dex.Dex.Section;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	public int getTarget() {, +		return thenBlock == null ? target : thenBlock.getStartOffset();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	public int getTarget() {, +		return thenBlock == null ? target : thenBlock.getStartOffset();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	public int getTarget() {, +		return thenBlock == null ? target : thenBlock.getStartOffset();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/Region.java, +import jadx.core.utils.Utils;, +		int size = blocks.size();, +		sb.append('(');, +		sb.append(size);, +		if (size > 0) {, +			sb.append(':');, +			Utils.listToString(sb, blocks, "|", IContainer::baseString);, +		sb.append(')');, +		return "R" + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	public int getTarget() {, +		return thenBlock == null ? target : thenBlock.getStartOffset();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/Region.java, +import jadx.core.utils.Utils;, +		int size = blocks.size();, +		sb.append('(');, +		sb.append(size);, +		if (size > 0) {, +			sb.append(':');, +			Utils.listToString(sb, blocks, "|", IContainer::baseString);, +		sb.append(')');, +		return "R" + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +				cond = not(new IfCondition(c.invert()));, +				return "!(" + first() + ")";, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	public int getTarget() {, +		return thenBlock == null ? target : thenBlock.getStartOffset();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/Region.java, +import jadx.core.utils.Utils;, +		int size = blocks.size();, +		sb.append('(');, +		sb.append(size);, +		if (size > 0) {, +			sb.append(':');, +			Utils.listToString(sb, blocks, "|", IContainer::baseString);, +		sb.append(')');, +		return "R" + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +				cond = not(new IfCondition(c.invert()));, +				return "!(" + first() + ")";, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +	protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	public int getTarget() {, +		return thenBlock == null ? target : thenBlock.getStartOffset();, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/Region.java, +import jadx.core.utils.Utils;, +		int size = blocks.size();, +		sb.append('(');, +		sb.append(size);, +		if (size > 0) {, +			sb.append(':');, +			Utils.listToString(sb, blocks, "|", IContainer::baseString);]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java, +import java.util.Comparator;, +, +			Comparator<JResource> typeComparator, +				= (r1, r2) -> r1.type.ordinal() - r2.type.ordinal();, +			Comparator<JResource> nameComparator, +				= Comparator.comparing(JResource::getName, String.CASE_INSENSITIVE_ORDER);, +, +			files.sort(typeComparator.thenComparing(nameComparator));, +]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		return NameMapper.removeInvalidCharsMiddle(name);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		return NameMapper.removeInvalidCharsMiddle(name);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +	public static boolean isValidIdentifierStart(int codePoint) {, +		return Character.isJavaIdentifierStart(codePoint);, +	}, +, +	public static boolean isValidIdentifierPart(int codePoint) {, +		return Character.isJavaIdentifierPart(codePoint);, +	}, +, +	/**, +	 * Return modified string with removed:, +	 * <p><ul>, +	 * <li> not printable chars (including unicode), +	 * <li> chars not valid for java identifier part, +	 * </ul><p>, +	 * Note: this 'middle' method must be used with prefixed string:, +	 * <p><ul>, +	 * <li> can leave invalid chars for java identifier start (i.e numbers), +	 * <li> result not checked for reserved words, +	 * </ul><p>, +	 */, +	public static String removeInvalidCharsMiddle(String name) {, +		if (isValidIdentifier(name) && isAllCharsPrintable(name)) {, +			return name;, +		}, +		int len = name.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			int codePoint = name.codePointAt(i);, +			if (isPrintableChar(codePoint) && isValidIdentifierPart(codePoint)) {, +				sb.append((char) codePoint);, +			}, +		}, +		return sb.toString();, +	}, +, +	/**, +	 * Return string with removed invalid chars, see {@link #removeInvalidCharsMiddle}, +	 * <p>, +	 * Prepend prefix if first char is not valid as java identifier start char., +	 */, +	public static String removeInvalidChars(String name, String prefix) {, +		String result = removeInvalidCharsMiddle(name);, +		if (!result.isEmpty()) {, +			int codePoint = result.codePointAt(0);, +			if (!isValidIdentifierStart(codePoint)) {, +				return prefix + result;, +			}, +		}, +		return result;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		return NameMapper.removeInvalidCharsMiddle(name);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +	public static boolean isValidIdentifierStart(int codePoint) {, +		return Character.isJavaIdentifierStart(codePoint);, +	}, +, +	public static boolean isValidIdentifierPart(int codePoint) {, +		return Character.isJavaIdentifierPart(codePoint);, +	}, +, +	/**, +	 * Return modified string with removed:, +	 * <p><ul>, +	 * <li> not printable chars (including unicode), +	 * <li> chars not valid for java identifier part, +	 * </ul><p>, +	 * Note: this 'middle' method must be used with prefixed string:, +	 * <p><ul>, +	 * <li> can leave invalid chars for java identifier start (i.e numbers), +	 * <li> result not checked for reserved words, +	 * </ul><p>, +	 */, +	public static String removeInvalidCharsMiddle(String name) {, +		if (isValidIdentifier(name) && isAllCharsPrintable(name)) {, +			return name;, +		}, +		int len = name.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			int codePoint = name.codePointAt(i);, +			if (isPrintableChar(codePoint) && isValidIdentifierPart(codePoint)) {, +				sb.append((char) codePoint);, +			}, +		}, +		return sb.toString();, +	}, +, +	/**, +	 * Return string with removed invalid chars, see {@link #removeInvalidCharsMiddle}, +	 * <p>, +	 * Prepend prefix if first char is not valid as java identifier start char., +	 */, +	public static String removeInvalidChars(String name, String prefix) {]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new ProcessVariables());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new ProcessVariables());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +import jadx.core.dex.regions.loops.ForLoop;, +import jadx.core.dex.regions.loops.LoopRegion;, +import jadx.core.dex.regions.loops.LoopType;, +	private static class CollectUsageRegionVisitor extends TracedRegionVisitor {, +		private final List<RegisterArg> args;, +		private final Map<Variable, Usage> usageMap;, +, +		public CollectUsageRegionVisitor(Map<Variable, Usage> usageMap) {, +			this.usageMap = usageMap;, +			args = new ArrayList<RegisterArg>();, +			regionProcess(mth, curRegion);, +				if (insn.contains(AFlag.SKIP)) {, +					continue;, +				}, +				args.clear();, +				processInsn(insn, curRegion);, +			}, +		}, +, +		private void regionProcess(MethodNode mth, IRegion region) {, +			if (region instanceof LoopRegion) {, +				LoopRegion loopRegion = (LoopRegion) region;, +				LoopType loopType = loopRegion.getType();, +				if (loopType instanceof ForLoop) {, +					ForLoop forLoop = (ForLoop) loopType;, +					processInsn(forLoop.getInitInsn(), region);, +					processInsn(forLoop.getIncrInsn(), region);, +				}, +			}, +		}, +, +		void processInsn(InsnNode insn, IRegion curRegion) {, +			if (insn == null) {, +				return;, +			}, +, +	@Override, +	public void visit(MethodNode mth) throws JadxException {, +		if (mth.isNoCode()) {, +			return;, +		}, +		final Map<Variable, Usage> usageMap = new LinkedHashMap<Variable, Usage>();, +		for (RegisterArg arg : mth.getArguments(true)) {, +			addToUsageMap(arg, usageMap);, +		}, +, +		// collect all variables usage, +		IRegionVisitor collect = new CollectUsageRegionVisitor(usageMap);, +					if (declareAtAssign(u)) {, +		}, +	private static Usage addToUsageMap(RegisterArg arg, Map<Variable, Usage> usageMap) {, +	private static boolean declareAtAssign(Usage u) {, +		RegisterArg arg = u.getArg();, +		InsnNode parentInsn = arg.getParentInsn();, +		if (!arg.equals(parentInsn.getResult())) {, +			return false;, +		}, +		parentInsn.add(AFlag.DECLARE_VAR);, +		processVar(arg);, +		return true;, +	}, +, +		// workaround for declare variables used in several loops, +		if (region instanceof LoopRegion) {, +			for (IRegion r : u.getAssigns()) {, +				if (!RegionUtils.isRegionContainsRegion(region, r)) {, +					return false;, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new ProcessVariables());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +import jadx.core.dex.regions.loops.ForLoop;, +import jadx.core.dex.regions.loops.LoopRegion;, +import jadx.core.dex.regions.loops.LoopType;, +	private static class CollectUsageRegionVisitor extends TracedRegionVisitor {, +		private final List<RegisterArg> args;, +		private final Map<Variable, Usage> usageMap;, +, +		public CollectUsageRegionVisitor(Map<Variable, Usage> usageMap) {, +			this.usageMap = usageMap;, +			args = new ArrayList<RegisterArg>();, +			regionProcess(mth, curRegion);, +				if (insn.contains(AFlag.SKIP)) {, +					continue;, +				}, +				args.clear();, +				processInsn(insn, curRegion);, +			}, +		}, +, +		private void regionProcess(MethodNode mth, IRegion region) {, +			if (region instanceof LoopRegion) {, +				LoopRegion loopRegion = (LoopRegion) region;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +		return doubleToString(value);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +		return doubleToString(value);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +						progressMonitor.setProgress((int) (done * 100.0 / total));, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +		return doubleToString(value);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +						progressMonitor.setProgress((int) (done * 100.0 / total));, +++ b/jadx-samples/src/main/java/jadx/samples/TestCF4.java, +		assertEquals(c, 'c');, +		assertEquals(c, 'a');]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/EntryConfig.java, +			LOG.warn("Invalid orientation value: {}", orientation);, +			LOG.warn("Invalid touchscreen value: {}", touchscreen);, +			LOG.warn("Invalid density value: {}", density);, +			LOG.warn("Invalid keyboard value: {}", keyboard);, +			LOG.warn("Invalid navigation value: {}", navigation);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, +			} else {, +					List<RegisterArg> args = mth.getArguments(false);, +					if (isRemovedClassInArgs(cls, args)) {, +						modifySyntheticMethod(cls, mth, args);, +					}, +				}, +			}, +		}, +	}, +, +	private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mthArgs) {, +		for (RegisterArg arg : mthArgs) {, +			ArgType argType = arg.getType();, +			if (!argType.isObject()) {, +				continue;, +			}, +			ClassNode argCls = cls.dex().resolveClass(argType);, +			if (argCls == null) {, +				// check if missing class from current top class, +				ClassInfo argClsInfo = ClassInfo.fromType(cls.root(), argType);, +				if (argClsInfo.isInner(), +						&& cls.getFullName().startsWith(argClsInfo.getParentClass().getFullName())) {, +					return true;, +				}, +			} else {, +				if (argCls.contains(AFlag.DONT_GENERATE)) {, +					return true;, +				}, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove synthetic constructor and redirect calls to existing constructor, +	 */, +	private static void modifySyntheticMethod(ClassNode cls, MethodNode mth, List<RegisterArg> args) {, +				RegisterArg firstArg = args.get(0);, +				if (firstArg.getType().equals(cls.getParentClass().getClassInfo().getType())) {, +					firstArg.add(AFlag.SKIP_ARG);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, +			} else {, +					List<RegisterArg> args = mth.getArguments(false);, +					if (isRemovedClassInArgs(cls, args)) {, +						modifySyntheticMethod(cls, mth, args);, +					}, +				}, +			}, +		}, +	}, +, +	private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mthArgs) {, +		for (RegisterArg arg : mthArgs) {, +			ArgType argType = arg.getType();, +			if (!argType.isObject()) {, +				continue;, +			}, +			ClassNode argCls = cls.dex().resolveClass(argType);, +			if (argCls == null) {, +				// check if missing class from current top class, +				ClassInfo argClsInfo = ClassInfo.fromType(cls.root(), argType);, +				if (argClsInfo.isInner(), +						&& cls.getFullName().startsWith(argClsInfo.getParentClass().getFullName())) {, +					return true;, +				}, +			} else {, +				if (argCls.contains(AFlag.DONT_GENERATE)) {, +					return true;, +				}, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove synthetic constructor and redirect calls to existing constructor, +	 */, +	private static void modifySyntheticMethod(ClassNode cls, MethodNode mth, List<RegisterArg> args) {, +				RegisterArg firstArg = args.get(0);, +				if (firstArg.getType().equals(cls.getParentClass().getClassInfo().getType())) {, +					firstArg.add(AFlag.SKIP_ARG);, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +		throw new AssertionError("Smali file not found: " + smaliFile.getAbsolutePath());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, +			} else {, +					List<RegisterArg> args = mth.getArguments(false);, +					if (isRemovedClassInArgs(cls, args)) {, +						modifySyntheticMethod(cls, mth, args);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		ArgType origType = callMth.getArguments(false).get(origPos).getInitType();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		ArgType origType = callMth.getArguments(false).get(origPos).getInitType();, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java, +package jadx.tests.integration.invoke;, +, +import java.util.ArrayList;, +import java.util.List;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestCastInOverloadedInvoke extends IntegrationTest {, +, +	public static class TestCls {, +, +		public void test() {, +			call(new ArrayList<>());, +			call((List<String>) new ArrayList<String>());, +		}, +, +		public void test2(Object obj) {, +			if (obj instanceof String) {, +				call((String) obj);, +			}, +		}, +, +		public void call(String str) {, +		}, +, +		public void call(List<String> list) {, +		}, +, +		public void call(ArrayList<String> list) {, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +// 		TODO: implement more checks for casts in overloaded methods, +//		assertThat(code, containsOne("call(new ArrayList<>());"));, +		assertThat(code, containsOne("call((ArrayList<String>) new ArrayList());"));, +, +// 		TODO: fix generics in constructors, +//		assertThat(code, containsOne("call((List<String>) new ArrayList<String>());"));, +		assertThat(code, containsOne("call((List<String>) new ArrayList());"));, +, +		assertThat(code, containsOne("call((String) obj);"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +		Object result = null;, +			result = decoder.decode(entry.getSize(), inputStream);, +		return result;, +	public static CodeWriter loadToCodeWriter(InputStream is) throws IOException {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +		Object result = null;, +			result = decoder.decode(entry.getSize(), inputStream);, +		return result;, +	public static CodeWriter loadToCodeWriter(InputStream is) throws IOException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.api.ResourcesLoader;, +		is = new ParserStream(inputStream);, +		if (!isBinaryXml()) {, +			return ResourcesLoader.loadToCodeWriter(inputStream);, +		}, +	private boolean isBinaryXml() throws IOException {, +		is.mark(4);, +		int v = is.readInt16(); // version, +		int h = is.readInt16(); // header size, +		if (v == 0x0003 && h == 0x0008) {, +			return true;, +		}, +		is.reset();, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +		Object result = null;, +			result = decoder.decode(entry.getSize(), inputStream);, +		return result;, +	public static CodeWriter loadToCodeWriter(InputStream is) throws IOException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.api.ResourcesLoader;, +		is = new ParserStream(inputStream);, +		if (!isBinaryXml()) {, +			return ResourcesLoader.loadToCodeWriter(inputStream);, +		}, +	private boolean isBinaryXml() throws IOException {, +		is.mark(4);, +		int v = is.readInt16(); // version, +		int h = is.readInt16(); // header size, +		if (v == 0x0003 && h == 0x0008) {, +			return true;, +		}, +		is.reset();, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +	public void mark(int len) throws IOException {, +		if (!input.markSupported()) {, +			throw new IOException("Mark not supported for input stream " + input.getClass());, +		}, +		input.mark(len);, +	}, +, +	public void reset() throws IOException {, +		input.reset();, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java, +	// If set, this is a weak resource and may be overriden by strong resources of the same name/type., +	// This is only useful during linking with other resource tables., +	protected static final int FLAG_WEAK = 0x0004;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java, +	// If set, this is a weak resource and may be overriden by strong resources of the same name/type., +	// This is only useful during linking with other resource tables., +	protected static final int FLAG_WEAK = 0x0004;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +		int size = is.readInt16();, +		if ((flags & FLAG_COMPLEX) != 0 || size == 16) {, +			ri.setParentRef(parentRef);, +		} else {, +			ri.setSimpleValue(parseValue());, +		long start = is.getPos();, +		is.readInt8(); // inputPad0, +		is.readInt16(); // minorVersion must always be 0, +		is.skipToPos(start + size, "Config skip trailing bytes");, +	private char[] unpackLocaleOrRegion(byte in0, byte in1, char base) {, +		long start = is.getPos();, +		StringBuilder sb = new StringBuilder(16);, +		for (int i = 0; i < length; i++) {, +			sb.append((char) ch);, +		is.skipToPos(start + length, "readScriptOrVariantChar");, +		return sb.toString();]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMaxLength = 64;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMaxLength = 64;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertRenameInfo(clsCode, cls);, +	private void insertRenameInfo(CodeWriter code, ClassNode cls) {, +		ClassInfo classInfo = cls.getClassInfo();, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +		}, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMaxLength = 64;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertRenameInfo(clsCode, cls);, +	private void insertRenameInfo(CodeWriter code, ClassNode cls) {, +		ClassInfo classInfo = cls.getClassInfo();, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.SourceFileAttr;, +import org.jetbrains.annotations.NotNull;, +	@NotNull, +	private final int maxLength;, +	private final int minLength;, +	private final PackageNode rootPackage = new PackageNode("");, +	public Deobfuscator(IJadxArgs args, @NotNull List<DexNode> dexNodes, File deobfMapFile) {, +	private void process() {, +				if (!fullName.equals(clsInfo.getFullName())) {, +	}, +	private PackageNode getPackageNode(String fullPkgName, boolean create) {, +			if (result == null && create) {, +		} while (!fullPkgName.isEmpty() && result != null);, +		public final ClassNode cls;, +		public final PackageNode pkg;, +		public final String alias;, +		public DeobfClsInfo(ClassNode cls, PackageNode pkg, String alias) {, +			this.alias = alias;, +			return prefix + (this.alias != null ? this.alias : this.cls.getShortName());, +	private String getNameWithoutPackage(ClassInfo clsInfo) {, +		ClassInfo classInfo = cls.getClassInfo();, +		String pkgFullName = classInfo.getPackage();, +		String fullName = classInfo.getFullName();, +		if (preLoadClsMap.containsKey(fullName)) {, +			String alias = preLoadClsMap.get(fullName);, +			clsMap.put(classInfo, new DeobfClsInfo(cls, pkg, alias));, +		if (clsMap.containsKey(classInfo)) {, +		if (shouldRename(classInfo.getShortName())) {, +			String alias = makeClsAlias(cls);, +			clsMap.put(classInfo, new DeobfClsInfo(cls, pkg, alias));, +	private String makeClsAlias(ClassNode cls) {, +		SourceFileAttr sourceFileAttr = cls.get(AType.SOURCE_FILE);, +		if (sourceFileAttr != null) {, +			String name = sourceFileAttr.getFileName();, +			if (name.endsWith(".java")) {, +				name = name.substring(0, name.length() - ".java".length());, +			}, +			if (NameMapper.isValidIdentifier(name), +					&& !NameMapper.isReserved(name)) {, +				// TODO: check if no class with this name exists or already renamed, +				cls.remove(AType.SOURCE_FILE);, +				return name;, +			}, +		}, +		String clsName = cls.getClassInfo().getShortName();, +		return String.format("C%04d%s", clsIndex++, short4LongName(clsName));, +	}, +, +		}, +	private final Set<String> pkgSet = new TreeSet<String>();, +		// doPkg for all parent packages except root that not hasAliases, +	private void load() throws IOException {, +			l = l.trim();, +				String va[] = splitAndTrim(l);, +				String va[] = splitAndTrim(l);, +	private static String[] splitAndTrim(String str) {, +		String[] v = str.substring(2).split("=");, +		for (int i = 0; i < v.length; i++) {, +			v[i] = v[i].trim();, +		}, +		return v;, +	}, +, +	private void save() throws IOException {, +				list.add(String.format("c %s=%s",, +						deobfClsInfo.cls.getClassInfo().getFullName(), deobfClsInfo.alias));, +	private String getPackageName(String packageName) {, +	private String getClassName(ClassInfo clsInfo) {, +	private String getClassFullName(ClassNode cls) {, +	private String getClassFullName(ClassInfo clsInfo) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMaxLength = 64;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		insertRenameInfo(clsCode, cls);]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, +	public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, +	public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public interface ResourceDecoder {, +				LOG.debug("Error close zip file: {}", zipRef, e);, +					LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, +	public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public interface ResourceDecoder {, +				LOG.debug("Error close zip file: {}", zipRef, e);, +					LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			if (err != null) {, +, +			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), +					.add(mth.toString()), +					.add("\");");, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, +	public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public interface ResourceDecoder {, +				LOG.debug("Error close zip file: {}", zipRef, e);, +					LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			if (err != null) {, +, +			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), +					.add(mth.toString()), +					.add("\");");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : null));, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, +	public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public interface ResourceDecoder {, +				LOG.debug("Error close zip file: {}", zipRef, e);, +					LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			if (err != null) {, +, +			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), +					.add(mth.toString()), +					.add("\");");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +					LOG.warn("Wrong object literal: {} for type: {}", lit, type);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +			LOG.error("jadx error: {}", e.getMessage(), e);, +			LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, +	public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public interface ResourceDecoder {, +				LOG.debug("Error close zip file: {}", zipRef, e);, +					LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			if (err != null) {, +, +			code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), +					.add(mth.toString()), +					.add("\");");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +					LOG.warn("Wrong object literal: {} for type: {}", lit, type);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMinLength = 3;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	protected int deobfuscationMinLength = 3;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private static final int CURRENT_SETTINGS_VERSION = 3;, +			setDeobfuscationMinLength(3);, +			fromVersion++;, +		}, +		if (fromVersion == 2) {, +			if (getDeobfuscationMinLength() == 4) {, +				setDeobfuscationMinLength(3);, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, +		return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, +		return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.utils.StringUtils;, +			String fileName = StringUtils.escape(mth.getMethodInfo().getShortId()), +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, +		return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.utils.StringUtils;, +			String fileName = StringUtils.escape(mth.getMethodInfo().getShortId()), +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static String escape(String str) {, +		int len = str.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			char c = str.charAt(i);, +			switch (c) {, +				case '.':, +				case '/':, +				case ';':, +				case '$':, +				case ' ':, +				case ',':, +				case '<':, +					sb.append('_');, +					break;, +, +				case '[':, +					sb.append('A');, +					break;, +, +				case ']':, +				case '>':, +				case '?':, +				case '*':, +					break;, +, +				default:, +					sb.append(c);, +					break;, +			}, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, +		return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.utils.StringUtils;, +			String fileName = StringUtils.escape(mth.getMethodInfo().getShortId()), +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static String escape(String str) {, +		int len = str.length();, +		StringBuilder sb = new StringBuilder(len);, +		for (int i = 0; i < len; i++) {, +			char c = str.charAt(i);, +			switch (c) {, +				case '.':, +				case '/':, +				case ';':, +				case '$':, +				case ' ':, +				case ',':, +				case '<':, +					sb.append('_');, +					break;, +, +				case '[':, +					sb.append('A');, +					break;, +, +				case ']':, +				case '>':, +				case '?':, +				case '*':, +					break;, +, +				default:, +					sb.append(c);, +					break;, +			}, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.CodeVar;, +		declareVar(code, arg.getSVar().getCodeVar());, +	}, +, +	public void declareVar(CodeWriter code, CodeVar codeVar) {, +		if (codeVar.isFinal()) {, +		useType(code, codeVar.getType());, +		code.add(mgen.getNameGen().assignArg(codeVar));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.CodeVar;, +		declareVar(code, arg.getSVar().getCodeVar());, +	}, +, +	public void declareVar(CodeWriter code, CodeVar codeVar) {, +		if (codeVar.isFinal()) {, +		useType(code, codeVar.getType());, +		code.add(mgen.getNameGen().assignArg(codeVar));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.instructions.args.CodeVar;, +import jadx.core.utils.Utils;, +				mth.addComment("JADX WARN: Incorrect number of args for enum constructor: " + args.size() + " (expected >= 2)");, +	private void addMethodArguments(CodeWriter code, List<RegisterArg> args) {, +		Iterator<RegisterArg> it = args.iterator();, +		while (it.hasNext()) {, +			RegisterArg mthArg = it.next();, +			SSAVar ssaVar = mthArg.getSVar();, +			CodeVar var;, +			if (ssaVar == null) {, +				// null for abstract or interface methods, +				var = CodeVar.fromMthArg(mthArg);, +			} else {, +				var = ssaVar.getCodeVar();, +			}, +			ArgType argType = var.getType();, +				annotationGen.addForParameter(code, paramsAnnotation, i);, +			if (var.isFinal()) {, +				code.add("final ");, +					classGen.useType(code, elType);, +					code.add("...");, +					mth.addComment("JADX INFO: Last argument in varargs method is not array: " + var);, +					classGen.useType(code, argType);, +				classGen.useType(code, argType);, +			code.add(' ');, +			code.add(nameGen.assignArg(var));, +				code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +	private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, +		int size = parents.size();, +		if (size == 0) {, +			return EMPTY_NCLASS_ARRAY;, +		}, +		return parents.toArray(new NClass[size]);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +	private final int regionsLimit;, +		int blocksCount = mth.getBasicBlocks().size();, +		this.processedBlocks = new BitSet(blocksCount);, +		this.regionsLimit = blocksCount * 100;, +			if (regionsCount > regionsLimit) {]
[+++ b/build.gradle, +    gradle.projectsEvaluated {, +        tasks.withType(Compile) {, +            options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", +        }, +++ b/build.gradle, +    gradle.projectsEvaluated {, +        tasks.withType(Compile) {, +            options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", +        }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/build.gradle, +    gradle.projectsEvaluated {, +        tasks.withType(Compile) {, +            options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", +        }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/build.gradle, +    gradle.projectsEvaluated {, +        tasks.withType(Compile) {, +            options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", +        }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +	public int compareTo(JavaPackage o) {, +		return name.compareTo(o.name);, +	public boolean equals(Object o) {, +		if (this == o) return true;, +		if (o == null || getClass() != o.getClass()) return false;, +		JavaPackage that = (JavaPackage) o;, +		if (!name.equals(that.name)) return false;, +		return true;, +	}, +, +	@Override, +	public int hashCode() {, +		return name.hashCode();, +	}, +, +	@Override, +	public String toString() {, +		return name;, +++ b/build.gradle, +    gradle.projectsEvaluated {, +        tasks.withType(Compile) {, +            options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", +        }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +	public int compareTo(JavaPackage o) {, +		return name.compareTo(o.name);, +	public boolean equals(Object o) {, +		if (this == o) return true;, +		if (o == null || getClass() != o.getClass()) return false;, +		JavaPackage that = (JavaPackage) o;, +		if (!name.equals(that.name)) return false;, +		return true;, +	}, +, +	@Override, +	public int hashCode() {, +		return name.hashCode();, +	}, +, +	@Override, +	public String toString() {, +		return name;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +++ b/build.gradle, +    gradle.projectsEvaluated {, +        tasks.withType(Compile) {, +            options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", +        }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +	public int compareTo(JavaPackage o) {, +		return name.compareTo(o.name);, +	public boolean equals(Object o) {, +		if (this == o) return true;, +		if (o == null || getClass() != o.getClass()) return false;, +		JavaPackage that = (JavaPackage) o;, +		if (!name.equals(that.name)) return false;, +		return true;, +	}, +, +	@Override, +	public int hashCode() {, +		return name.hashCode();, +	}, +, +	@Override]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +			attrName = generateNameForNS(attrUrl);, +	private String generateNameForNS(String attrUrl) {, +		for(int i = 1; ; i++) {, +			String attrName = "ns" + i;, +			if(!nsMap.containsValue(attrName)) {, +				// do not add generated value to nsMap, +				// because attrUrl might be used in a neighbor element, but never defined, +				writer.add("xmlns:").add(attrName), +					.add("=\"").add(attrUrl).add("\"");, +				return attrName;, +			}, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +			String obj;, +			if (incompleteType) {, +				obj = slice().replace('/', '.');, +			} else {, +				obj = inclusiveSlice();, +			}, +			return ArgType.object(obj);, +		List<ArgType> list = new LinkedList<ArgType>();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +			String obj;, +			if (incompleteType) {, +				obj = slice().replace('/', '.');, +			} else {, +				obj = inclusiveSlice();, +			}, +			return ArgType.object(obj);, +		List<ArgType> list = new LinkedList<ArgType>();, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +		return obj;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +			String obj;, +			if (incompleteType) {, +				obj = slice().replace('/', '.');, +			} else {, +				obj = inclusiveSlice();, +			}, +			return ArgType.object(obj);, +		List<ArgType> list = new LinkedList<ArgType>();, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +		return obj;, +++ b/jadx-core/src/test/groovy/jadx/tests/TestSignatureParser.groovy, +        "La/b/C<Ld/E<Lf/G;>;>;" | generic("La/b/C;", generic("Ld/E;", object("Lf/G;"))), +        "La<TD;>.c/d;"          | genericInner(generic("La;", genericType("D")), "c.d", null), +    def "method args 2"() {, +        when:, +        def argTypes = new SignatureParser("(La/b/C<TT;>.d/E;)V").consumeMethodArgs(), +        then:, +        argTypes.size() == 1, +        def argType = argTypes.get(0), +        argType.getObject().indexOf('/') == -1, +        argTypes.get(0) == genericInner(generic("La/b/C;", genericType("T")), "d.E", null), +    }, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/DataInputDelegate.java, +/**, + *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>, + *, + *  Licensed under the Apache License, Version 2.0 (the "License");, + *  you may not use this file except in compliance with the License., + *  You may obtain a copy of the License at, + *, + *       http://www.apache.org/licenses/LICENSE-2.0, + *, + *  Unless required by applicable law or agreed to in writing, software, + *  distributed under the License is distributed on an "AS IS" BASIS,, + *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *  See the License for the specific language governing permissions and, + *  limitations under the License., + */, +, +package jadx.core.utils.android;, +, +import java.io.DataInput;, +import java.io.IOException;, +, +/**, + * @author Ryszard Wiśniewski <brut.alll@gmail.com>, + */, +abstract public class DataInputDelegate implements DataInput {, +    protected final DataInput mDelegate;, +, +    public DataInputDelegate(DataInput delegate) {, +        this.mDelegate = delegate;, +    }, +, +    public int skipBytes(int n) throws IOException {, +        return mDelegate.skipBytes(n);, +    }, +, +    public int readUnsignedShort() throws IOException {, +        return mDelegate.readUnsignedShort();, +    }, +, +    public int readUnsignedByte() throws IOException {, +        return mDelegate.readUnsignedByte();, +    }, +, +    public String readUTF() throws IOException {, +        return mDelegate.readUTF();, +    }, +, +    public short readShort() throws IOException {, +        return mDelegate.readShort();, +    }, +, +    public long readLong() throws IOException {, +        return mDelegate.readLong();, +    }, +, +    public String readLine() throws IOException {, +        return mDelegate.readLine();, +    }, +, +    public int readInt() throws IOException {, +        return mDelegate.readInt();, +    }, +, +    public void readFully(byte[] b, int off, int len) throws IOException {, +        mDelegate.readFully(b, off, len);, +    }, +, +    public void readFully(byte[] b) throws IOException {, +        mDelegate.readFully(b);, +    }, +, +    public float readFloat() throws IOException {, +        return mDelegate.readFloat();, +    }, +, +    public double readDouble() throws IOException {, +        return mDelegate.readDouble();, +    }, +, +    public char readChar() throws IOException {, +        return mDelegate.readChar();, +    }, +, +    public byte readByte() throws IOException {, +        return mDelegate.readByte();, +    }, +, +    public boolean readBoolean() throws IOException {, +        return mDelegate.readBoolean();, +    }, +}, +++ b/jadx-core/src/main/java/jadx/core/utils/android/DataInputDelegate.java, +/**, + *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>, + *, + *  Licensed under the Apache License, Version 2.0 (the "License");, + *  you may not use this file except in compliance with the License., + *  You may obtain a copy of the License at, + *]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, +	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, +	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		return startOffset;, +		return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, +	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		return startOffset;, +		return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			case MOVE:, +				InsnArg firstArg = insn.getArg(0);, +				if (firstArg.isLiteral()) {, +					InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, +					constInsn.setResult(insn.getResult());, +					constInsn.addArg(firstArg);, +					constInsn.copyAttributesFrom(insn);, +					return constInsn;, +				}, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, +	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		return startOffset;, +		return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			case MOVE:, +				InsnArg firstArg = insn.getArg(0);, +				if (firstArg.isLiteral()) {, +					InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, +					constInsn.setResult(insn.getResult());, +					constInsn.addArg(firstArg);, +					constInsn.copyAttributesFrom(insn);, +					return constInsn;, +				}, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +		List<BlockNode> filtPreds = BlockUtils.filterPredecessors(sOut);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, +	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		return startOffset;, +		return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			case MOVE:, +				InsnArg firstArg = insn.getArg(0);, +				if (firstArg.isLiteral()) {, +					InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, +					constInsn.setResult(insn.getResult());, +					constInsn.addArg(firstArg);, +					constInsn.copyAttributesFrom(insn);, +					return constInsn;, +				}, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +		List<BlockNode> filtPreds = BlockUtils.filterPredecessors(sOut);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +		if (exitBlock.getInstructions().size() != 1, +				|| exitBlock.contains(AFlag.SYNTHETIC)) {, +			return false;, +		}, +		List<BlockNode> preds = exitBlock.getPredecessors();, +		if (preds.size() < 2) {, +			return false;, +		}, +		preds = BlockUtils.filterPredecessors(exitBlock);, +		if (preds.size() < 2) {, +			return false;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, +	private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +		return startOffset;, +		return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			case MOVE:, +				InsnArg firstArg = insn.getArg(0);, +				if (firstArg.isLiteral()) {, +					InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, +					constInsn.setResult(insn.getResult());, +					constInsn.addArg(firstArg);, +					constInsn.copyAttributesFrom(insn);, +					return constInsn;, +				}, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +		List<BlockNode> filtPreds = BlockUtils.filterPredecessors(sOut);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +		if (exitBlock.getInstructions().size() != 1, +				|| exitBlock.contains(AFlag.SYNTHETIC)) {, +			return false;, +		}, +		List<BlockNode> preds = exitBlock.getPredecessors();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import jadx.core.utils.InsnUtils;, +		boolean typeImmutable = elType.isPrimitive();, +		int regsCount = insn.getRegisterCount();, +		InsnArg[] regs = new InsnArg[regsCount];, +			for (int i = 0; i < regsCount; i++) {, +				regs[i] = InsnArg.reg(r, elType, typeImmutable);, +			for (int i = 0; i < regsCount; i++) {, +				int regNum = InsnUtils.getArg(insn, i);, +				regs[i] = InsnArg.reg(regNum, elType, typeImmutable);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import jadx.core.utils.InsnUtils;, +		boolean typeImmutable = elType.isPrimitive();, +		int regsCount = insn.getRegisterCount();, +		InsnArg[] regs = new InsnArg[regsCount];, +			for (int i = 0; i < regsCount; i++) {, +				regs[i] = InsnArg.reg(r, elType, typeImmutable);, +			for (int i = 0; i < regsCount; i++) {, +				int regNum = InsnUtils.getArg(insn, i);, +				regs[i] = InsnArg.reg(regNum, elType, typeImmutable);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.dex.attributes.AFlag;, +		add(AFlag.DONT_INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import jadx.core.utils.InsnUtils;, +		boolean typeImmutable = elType.isPrimitive();, +		int regsCount = insn.getRegisterCount();, +		InsnArg[] regs = new InsnArg[regsCount];, +			for (int i = 0; i < regsCount; i++) {, +				regs[i] = InsnArg.reg(r, elType, typeImmutable);, +			for (int i = 0; i < regsCount; i++) {, +				int regNum = InsnUtils.getArg(insn, i);, +				regs[i] = InsnArg.reg(regNum, elType, typeImmutable);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.dex.attributes.AFlag;, +		add(AFlag.DONT_INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import org.jetbrains.annotations.Nullable;, +, +, +		private static final PrimitiveType[] EMPTY_POSSIBLES = new PrimitiveType[0];, +, +, +		@Override, +		public boolean contains(PrimitiveType type) {, +			return getPrimitiveType() == type;, +		}, +, +		@Override, +		public ArgType selectFirst() {, +			return null;, +		}, +, +		@Override, +		public PrimitiveType[] getPossibleTypes() {, +			return EMPTY_POSSIBLES;, +		}, +		public static final PrimitiveType[] ARRAY_POSSIBLES = new PrimitiveType[]{PrimitiveType.ARRAY};, +		public boolean isTypeKnown() {, +			return arrayElement.isTypeKnown();, +		}, +, +		@Override, +		public ArgType selectFirst() {, +			return array(arrayElement.selectFirst());, +		}, +, +		@Override, +		public PrimitiveType[] getPossibleTypes() {, +			return ARRAY_POSSIBLES;, +		}, +, +		@Override, +			if (contains(PrimitiveType.OBJECT)) {, +				return OBJECT;, +			} else if (contains(PrimitiveType.ARRAY)) {, +				return array(OBJECT);, +	public abstract boolean contains(PrimitiveType type);, +	public abstract ArgType selectFirst();, +	public abstract PrimitiveType[] getPossibleTypes();, +	@Nullable, +, +		if (a.isArray()) {, +			return mergeArrays((ArrayArg) a, b);, +		} else if (b.isArray()) {, +			return mergeArrays((ArrayArg) b, a);, +		}, +				return null;, +				}, +				if (types.size() == 1) {, +				}, +				if (aObj.equals(Consts.CLASS_OBJECT)) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, +		timer = new Timer(2000, this);, +		if (used > r.maxMemory() * 0.8) {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, +		timer = new Timer(2000, this);, +		if (used > r.maxMemory() * 0.8) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java, +import java.util.concurrent.ConcurrentHashMap;, +, +		public synchronized void addUsage(CodeNode codeNode) {, +			usageList.add(codeNode);, +		}, +	private final Map<JNode, UsageInfo> usageMap = new ConcurrentHashMap<>();, +        UsageInfo usageInfo = usageMap.computeIfAbsent(jNode, key -> new UsageInfo());, +		usageInfo.addUsage(codeNode);]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +		if (getNodeFullName() != null) {, +			menu.addSeparator();, +		}, +		String name = getNodeFullName();, +		if (name != null) {, +			Utils.setClipboardString(name);, +		}, +	}, +, +	@Nullable, +	private String getNodeFullName() {, +				return jClass.getFullName();, +			} else {, +				return node.getName();, +		return null;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +		if (getNodeFullName() != null) {, +			menu.addSeparator();, +		}, +		String name = getNodeFullName();, +		if (name != null) {, +			Utils.setClipboardString(name);, +		}, +	}, +, +	@Nullable, +	private String getNodeFullName() {, +				return jClass.getFullName();, +			} else {, +				return node.getName();, +		return null;, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +		try {, +			LOG.debug("String '{}' copied to clipboard", text);, +		} catch (Exception e) {, +			LOG.error("Failed copy string '{}' to clipboard", text, e);, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final boolean ADD_LINE_NUMBERS = false;, +, +		if (ADD_LINE_NUMBERS) {, +			incIndent(2);, +		}, +	public CodeWriter startLineWithNum(int sourceLine) {, +		if (sourceLine == 0) {, +			startLine();, +			return this;, +		}, +		if (ADD_LINE_NUMBERS) {, +			newLine();, +			attachSourceLine(sourceLine);, +			String ln = "/* " + sourceLine + " */ ";, +			add(ln);, +			if (indentStr.length() > ln.length()) {, +				add(indentStr.substring(ln.length()));, +			}, +		} else {, +			startLine();, +			attachSourceLine(sourceLine);, +		}, +		return this;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final boolean ADD_LINE_NUMBERS = false;, +, +		if (ADD_LINE_NUMBERS) {, +			incIndent(2);, +		}, +	public CodeWriter startLineWithNum(int sourceLine) {, +		if (sourceLine == 0) {, +			startLine();, +			return this;, +		}, +		if (ADD_LINE_NUMBERS) {, +			newLine();, +			attachSourceLine(sourceLine);, +			String ln = "/* " + sourceLine + " */ ";, +			add(ln);, +			if (indentStr.length() > ln.length()) {, +				add(indentStr.substring(ln.length()));, +			}, +		} else {, +			startLine();, +			attachSourceLine(sourceLine);, +		}, +		return this;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.startLineWithNum(insn.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final boolean ADD_LINE_NUMBERS = false;, +, +		if (ADD_LINE_NUMBERS) {, +			incIndent(2);, +		}, +	public CodeWriter startLineWithNum(int sourceLine) {, +		if (sourceLine == 0) {, +			startLine();, +			return this;, +		}, +		if (ADD_LINE_NUMBERS) {, +			newLine();, +			attachSourceLine(sourceLine);, +			String ln = "/* " + sourceLine + " */ ";, +			add(ln);, +			if (indentStr.length() > ln.length()) {, +				add(indentStr.substring(ln.length()));, +			}, +		} else {, +			startLine();, +			attachSourceLine(sourceLine);, +		}, +		return this;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.startLineWithNum(insn.getSourceLine());, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		code.startLineWithNum(mth.getSourceLine());, +		code.add(ai.makeString());, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	private static final boolean ADD_LINE_NUMBERS = false;, +, +		if (ADD_LINE_NUMBERS) {, +			incIndent(2);, +		}, +	public CodeWriter startLineWithNum(int sourceLine) {, +		if (sourceLine == 0) {, +			startLine();, +			return this;, +		}, +		if (ADD_LINE_NUMBERS) {, +			newLine();, +			attachSourceLine(sourceLine);, +			String ln = "/* " + sourceLine + " */ ";]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +		boolean isNew = result.add(cls.getName());, +		if (isNew) {, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (cls.getInterfaces().size() == 1) {, +			} else {, +				parent = cls.getSuperClass();, +			code.add("new ").add(parent == null ? "Object" : useClass(parent)).add("() ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (cls.getInterfaces().size() == 1) {, +			} else {, +				parent = cls.getSuperClass();, +			code.add("new ").add(parent == null ? "Object" : useClass(parent)).add("() ");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +		return clsInfo.isInner(), +				&& getShortName().startsWith(Consts.ANONYMOUS_CLASS_PREFIX), +				&& getDefaultConstructor() != null;, +					&& (mth.getMethodInfo().getArgsCount() == 0, +						|| (mth.getArguments(false) != null && mth.getArguments(false).isEmpty()))) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			if (cls.getInterfaces().size() == 1) {, +			} else {, +				parent = cls.getSuperClass();, +			code.add("new ").add(parent == null ? "Object" : useClass(parent)).add("() ");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +		return clsInfo.isInner(), +				&& getShortName().startsWith(Consts.ANONYMOUS_CLASS_PREFIX), +				&& getDefaultConstructor() != null;, +					&& (mth.getMethodInfo().getArgsCount() == 0, +						|| (mth.getArguments(false) != null && mth.getArguments(false).isEmpty()))) {, +++ b/jadx-samples/src/main/java/jadx/samples/TestInner.java, +	public String func3() {, +		return new Object() {, +			{, +				count += 7;, +			}, +			@Override, +			public String toString() {, +				count += 8;, +				return Integer.toString(count);, +			}, +		}.toString();, +	}, +, +		assertEquals(func3(), "41");, +, +		return TestInner.count == 41;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, +		if(mth.getMethodInfo().isRenamed()) {, +			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, +		if(mth.getMethodInfo().isRenamed()) {, +			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			return StringUtils.escape(shortName.toLowerCase());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, +		if(mth.getMethodInfo().isRenamed()) {, +			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			return StringUtils.escape(shortName.toLowerCase());, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			boolean aliasFromPreset = false;, +			String aliasToUse = null;, +			for(MethodInfo mth : o.getMethods()){, +				if(mth.isAliasFromPreset()) {, +					aliasToUse = mth.getAlias();, +					aliasFromPreset = true;, +				}, +			}, +			for(MethodInfo mth : o.getMethods()){, +				if(aliasToUse == null) {, +					aliasToUse = mth.getAlias();, +				mth.setAlias(aliasToUse);, +				mth.setAliasFromPreset(aliasFromPreset);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, +		if(mth.getMethodInfo().isRenamed()) {, +			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			return StringUtils.escape(shortName.toLowerCase());, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			boolean aliasFromPreset = false;, +			String aliasToUse = null;, +			for(MethodInfo mth : o.getMethods()){, +				if(mth.isAliasFromPreset()) {, +					aliasToUse = mth.getAlias();, +					aliasFromPreset = true;, +				}, +			}, +			for(MethodInfo mth : o.getMethods()){, +				if(aliasToUse == null) {, +					aliasToUse = mth.getAlias();, +				mth.setAlias(aliasToUse);, +				mth.setAliasFromPreset(aliasFromPreset);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.root().getInfoStorage().getCls(type);, +		return dex.root().getInfoStorage().putCls(cls);, +			if(pkg.length() == 0) {, +				parClsName = clsName.substring(0, sep);, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import org.jetbrains.annotations.Nullable;, +								Dex dexBuf = makeDexBuf(entryName, inputStream);, +								if (dexBuf != null) {, +									addDexFile(entryName, dexBuf);, +								}, +	@Nullable, +	private Dex makeDexBuf(String entryName, InputStream inputStream) {, +		try {, +			return new Dex(inputStream);, +		} catch (Exception e) {, +			LOG.error("Failed to load file: {}, error: {}", entryName, e.getMessage(), e);, +			return null;, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/LoopAttr.java, +import jadx.core.dex.nodes.Edge;, +import java.util.LinkedList;, +import java.util.List;, +	 * Return source blocks of exit edges. <br>, +		Set<BlockNode> blocks = getLoopBlocks();, +		for (BlockNode block : blocks) {, +				if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, +	/**, +	 * Return loop exit edges., +	 */, +	public List<Edge> getExitEdges() {, +		List<Edge> edges = new LinkedList<Edge>();, +		Set<BlockNode> blocks = getLoopBlocks();, +		for (BlockNode block : blocks) {, +			for (BlockNode s : block.getSuccessors()) {, +				if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, +					edges.add(new Edge(block, s));, +				}, +			}, +		}, +		return edges;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/LoopAttr.java, +import jadx.core.dex.nodes.Edge;, +import java.util.LinkedList;, +import java.util.List;, +	 * Return source blocks of exit edges. <br>, +		Set<BlockNode> blocks = getLoopBlocks();, +		for (BlockNode block : blocks) {, +				if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, +	/**, +	 * Return loop exit edges., +	 */, +	public List<Edge> getExitEdges() {, +		List<Edge> edges = new LinkedList<Edge>();, +		Set<BlockNode> blocks = getLoopBlocks();, +		for (BlockNode block : blocks) {, +			for (BlockNode s : block.getSuccessors()) {, +				if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, +					edges.add(new Edge(block, s));, +				}, +			}, +		}, +		return edges;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.dex.attributes.AttributeFlag;, +	public boolean isSynthetic() {, +		return getAttributes().contains(AttributeFlag.SYNTHETIC);, +	}, +, +	public boolean isReturnBlock() {, +		return getAttributes().contains(AttributeFlag.RETURN);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/LoopAttr.java, +import jadx.core.dex.nodes.Edge;, +import java.util.LinkedList;, +import java.util.List;, +	 * Return source blocks of exit edges. <br>, +		Set<BlockNode> blocks = getLoopBlocks();, +		for (BlockNode block : blocks) {, +				if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, +	/**, +	 * Return loop exit edges., +	 */, +	public List<Edge> getExitEdges() {, +		List<Edge> edges = new LinkedList<Edge>();, +		Set<BlockNode> blocks = getLoopBlocks();, +		for (BlockNode block : blocks) {, +			for (BlockNode s : block.getSuccessors()) {, +				if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, +					edges.add(new Edge(block, s));, +				}, +			}, +		}, +		return edges;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.dex.attributes.AttributeFlag;, +	public boolean isSynthetic() {, +		return getAttributes().contains(AttributeFlag.SYNTHETIC);, +	}, +, +	public boolean isReturnBlock() {, +		return getAttributes().contains(AttributeFlag.RETURN);, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, +			if (fallback) {, +				mthGen.addFallbackMethodCode(code);, +			} else {, +			}, +			code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, +			if (fallback) {, +				mthGen.addFallbackMethodCode(code);, +			} else {, +			}, +			code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (name == null || fallback) {, +		return name != null ? base + "_" + name : base;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, +			if (fallback) {, +				mthGen.addFallbackMethodCode(code);, +			} else {, +			}, +			code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (name == null || fallback) {, +		return name != null ? base + "_" + name : base;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public void checkInstructions() {, +		List<RegisterArg> list = new ArrayList<RegisterArg>();, +		for (InsnNode insnNode : instructions) {, +			if (insnNode == null) {, +				continue;, +			}, +			list.clear();, +			RegisterArg resultArg = insnNode.getResult();, +			if (resultArg != null) {, +				list.add(resultArg);, +			}, +			insnNode.getRegisterArgs(list);, +			for (int i = 0, listSize = list.size(); i < listSize; i++) {, +				if (list.get(i).getRegNum() >= regsCount) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, +			if (fallback) {, +				mthGen.addFallbackMethodCode(code);, +			} else {, +			}, +			code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (name == null || fallback) {, +		return name != null ? base + "_" + name : base;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public void checkInstructions() {, +		List<RegisterArg> list = new ArrayList<RegisterArg>();, +		for (InsnNode insnNode : instructions) {, +			if (insnNode == null) {, +				continue;, +			}, +			list.clear();, +			RegisterArg resultArg = insnNode.getResult();, +			if (resultArg != null) {, +				list.add(resultArg);, +			}, +			insnNode.getRegisterArgs(list);, +			for (int i = 0, listSize = list.size(); i < listSize; i++) {, +				if (list.get(i).getRegNum() >= regsCount) {, +					throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +		mth.checkInstructions();, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, +			if (fallback) {, +				mthGen.addFallbackMethodCode(code);, +			} else {, +			}, +			code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (name == null || fallback) {, +		return name != null ? base + "_" + name : base;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public void checkInstructions() {, +		List<RegisterArg> list = new ArrayList<RegisterArg>();, +		for (InsnNode insnNode : instructions) {, +			if (insnNode == null) {, +				continue;, +			}, +			list.clear();]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CodePanel.java, +	private static final long serialVersionUID = 5310536092010045565L;, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CodePanel.java, +	private static final long serialVersionUID = 5310536092010045565L;, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +import jadx.gui.utils.NLS;, +import javax.swing.JMenuItem;, +import javax.swing.JPopupMenu;, +import javax.swing.SwingUtilities;, +import java.awt.event.MouseWheelEvent;, +import java.awt.event.MouseWheelListener;, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, +	private static final long serialVersionUID = -8833600618794570904L;, +, +	private final Map<JClass, CodePanel> openTabs = new LinkedHashMap<JClass, CodePanel>();, +, +		addMouseWheelListener(new MouseWheelListener() {, +			public void mouseWheelMoved(MouseWheelEvent e) {, +				int direction = e.getWheelRotation();, +				int index = getSelectedIndex();, +				int maxIndex = getTabCount() - 1;, +				if ((index == 0 && direction < 0), +						|| (index == maxIndex && direction > 0)) {, +					index = maxIndex - index;, +				} else {, +					index += direction;, +				}, +				setSelectedIndex(index);, +			}, +		});, +	}, +, +	MainWindow getMainWindow() {, +		return mainWindow;, +	}, +, +	void showCode(final JClass cls, final int line) {, +		final CodePanel codePanel = getCodePanel(cls);, +		SwingUtilities.invokeLater(new Runnable() {, +			@Override, +			public void run() {, +				setSelectedComponent(codePanel);, +				CodeArea codeArea = codePanel.getCodeArea();, +				codeArea.scrollToLine(line);, +				codeArea.requestFocus();, +			}, +		});, +		add(codePanel);, +		remove(codePanel);, +	private CodePanel getCodePanel(JClass cls) {, +		return panel;, +	}, +	private CodePanel getCodePanel(int index) {, +		Component component = getComponent(index);, +		if (component instanceof CodePanel) {, +			return (CodePanel) component;, +		}, +		return null;, +	}, +, +	CodePanel getSelectedCodePanel() {, +		return (CodePanel) getSelectedComponent();, +, +		final JPanel panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 3, 0));, +				if (SwingUtilities.isMiddleMouseButton(e)) {, +				} else if (SwingUtilities.isRightMouseButton(e)) {, +					JPopupMenu menu = createTabPopupMenu(codePanel);, +					menu.show(panel, e.getX(), e.getY());, +	private JPopupMenu createTabPopupMenu(final CodePanel codePanel) {, +		JPopupMenu menu = new JPopupMenu();, +		JMenuItem closeTab = new JMenuItem(NLS.str("tabs.close"));, +		closeTab.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				closeCodePanel(codePanel);, +			}, +		});, +		menu.add(closeTab);, +, +		if (openTabs.size() > 1) {, +			JMenuItem closeOther = new JMenuItem(NLS.str("tabs.closeOthers"));, +			closeOther.addActionListener(new ActionListener() {, +				@Override, +				public void actionPerformed(ActionEvent e) {, +					List<CodePanel> codePanels = new ArrayList<CodePanel>(openTabs.values());, +					for (CodePanel panel : codePanels) {, +						if (panel != codePanel) {, +							closeCodePanel(panel);, +						}, +					}, +				}, +			});, +			menu.add(closeOther);, +, +			JMenuItem closeAll = new JMenuItem(NLS.str("tabs.closeAll"));, +			closeAll.addActionListener(new ActionListener() {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +							h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +							h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode loopEnd = loop.getEnd();, +		if (!RegionUtils.isRegionContainsBlock(body, loopEnd), +				&& !loopEnd.contains(AType.EXC_HANDLER)) {, +			body.getSubBlocks().add(loopEnd);, +			BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +							h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode loopEnd = loop.getEnd();, +		if (!RegionUtils.isRegionContainsBlock(body, loopEnd), +				&& !loopEnd.contains(AType.EXC_HANDLER)) {, +			body.getSubBlocks().add(loopEnd);, +			BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		b.and(b2.getDomFrontier());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +							h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode loopEnd = loop.getEnd();, +		if (!RegionUtils.isRegionContainsBlock(body, loopEnd), +				&& !loopEnd.contains(AType.EXC_HANDLER)) {, +			body.getSubBlocks().add(loopEnd);, +			BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		b.and(b2.getDomFrontier());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +							h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		BlockNode loopEnd = loop.getEnd();, +		if (!RegionUtils.isRegionContainsBlock(body, loopEnd), +				&& !loopEnd.contains(AType.EXC_HANDLER)) {, +			body.getSubBlocks().add(loopEnd);, +			BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		b.and(b2.getDomFrontier());, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/others/TestIssue13a.java, +package jadx.tests.internal.others;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.lang.reflect.Field;, +import java.util.HashMap;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestIssue13a extends InternalJadxTest {, +, +	public static class TestCls {, +		private static final String TAG = "Parcel";, +		private static final HashMap<ClassLoader, HashMap<String, Parcelable.Creator>>, +				mCreators = new HashMap<ClassLoader, HashMap<String, Parcelable.Creator>>();, +, +		@SuppressWarnings("unchecked"), +		public final <T extends Parcelable> T test(ClassLoader loader) {, +			String name = readString();, +			if (name == null) {, +				return null;, +			}, +			Parcelable.Creator<T> creator;, +			synchronized (mCreators) {, +				HashMap<String, Parcelable.Creator> map = mCreators.get(loader);, +				if (map == null) {, +					map = new HashMap<String, Parcelable.Creator>();, +					mCreators.put(loader, map);, +				}, +				creator = map.get(name);, +				if (creator == null) {, +					try {, +						Class c = loader == null ?, +								Class.forName(name) : Class.forName(name, true, loader);, +						Field f = c.getField("CREATOR");, +						creator = (Parcelable.Creator) f.get(null);, +					} catch (IllegalAccessException e) {, +						Log.e(TAG, "1" + name + ", e: " + e);, +						throw new RuntimeException("2" + name);, +					} catch (ClassNotFoundException e) {, +						Log.e(TAG, "3" + name + ", e: " + e);, +						throw new RuntimeException("4" + name);, +					} catch (ClassCastException e) {, +						throw new RuntimeException("5" + name);, +					} catch (NoSuchFieldException e) {, +						throw new RuntimeException("6" + name);, +					}, +					if (creator == null) {, +						throw new RuntimeException("7" + name);, +					}, +					map.put(name, creator);, +				}, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +import java.util.Collections;, +	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +import java.util.Collections;, +	public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +		if (offset == 0) {, +			return AnnotationsList.EMPTY;, +		}, +		if (size == 0) {, +			return AnnotationsList.EMPTY;, +		}, +			byte v = s.readByte();, +			visibility = VISIBILITIES[v];]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +	private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +	private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +	private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JList<Object> resultsList;, +	private static class ResultsModel extends DefaultListModel<Object> {, +	private static class ResultsCellRenderer implements ListCellRenderer<Object> {, +		public Component getListCellRendererComponent(JList<?> list,, +		resultsList = new JList<Object>(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +	private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JList<Object> resultsList;, +	private static class ResultsModel extends DefaultListModel<Object> {, +	private static class ResultsCellRenderer implements ListCellRenderer<Object> {, +		public Component getListCellRendererComponent(JList<?> list,, +		resultsList = new JList<Object>(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java, +	private static final long serialVersionUID = 0L; // TODO: Generate random serialvers with serialver/eclipse]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +import jadx.core.dex.nodes.BlockNode;, +public class GotoNode extends TargetInsnNode {, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +, +	@Override, +	public void initBlocks(BlockNode curBlock) {, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +import jadx.core.dex.nodes.BlockNode;, +public class GotoNode extends TargetInsnNode {, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +, +	@Override, +	public void initBlocks(BlockNode curBlock) {, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	@Override, +	@Override, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		if (thenBlock == origin) {, +			thenBlock = replace;, +			return true;, +		}, +		if (elseBlock == origin) {, +			elseBlock = replace;, +			return true;, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +import jadx.core.dex.nodes.BlockNode;, +public class GotoNode extends TargetInsnNode {, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		return false;, +	}, +, +	@Override, +	public void initBlocks(BlockNode curBlock) {, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	@Override, +	@Override, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		if (thenBlock == origin) {, +			thenBlock = replace;, +			return true;, +		}, +		if (elseBlock == origin) {, +			elseBlock = replace;, +			return true;, +		}, +		return false;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/SwitchNode.java, +import java.util.List;, +import jadx.core.dex.nodes.BlockNode;, +import static jadx.core.utils.BlockUtils.getBlockByOffset;, +, +public class SwitchNode extends TargetInsnNode {, +	private BlockNode[] targetBlocks;, +	private BlockNode defTargetBlock;, +, +	public BlockNode[] getTargetBlocks() {, +		return targetBlocks;, +	}, +, +	public BlockNode getDefTargetBlock() {, +		return defTargetBlock;, +	}, +, +	@Override, +	public void initBlocks(BlockNode curBlock) {, +		List<BlockNode> successors = curBlock.getSuccessors();, +		int len = targets.length;, +		targetBlocks = new BlockNode[len];, +		for (int i = 0; i < len; i++) {, +			targetBlocks[i] = getBlockByOffset(targets[i], successors);, +		}, +		defTargetBlock = getBlockByOffset(def, successors);, +	}, +, +	@Override, +	public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, +		int count = 0;, +		int len = targetBlocks.length;, +		for (int i = 0; i < len; i++) {, +			if (targetBlocks[i] == origin) {]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +	private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, +		if (!fallback) {, +			throw new CodegenException(insn.getType() + " can be used only in fallback mode");, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +	private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, +		if (!fallback) {, +			throw new CodegenException(insn.getType() + " can be used only in fallback mode");, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +	private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, +		if (!fallback) {, +			throw new CodegenException(insn.getType() + " can be used only in fallback mode");, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (parentInsn == wrappedInsn) {, +			throw new JadxRuntimeException("Can't wrap instruction info itself: " + parentInsn);, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +	private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, +		if (!fallback) {, +			throw new CodegenException(insn.getType() + " can be used only in fallback mode");, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (parentInsn == wrappedInsn) {, +			throw new JadxRuntimeException("Can't wrap instruction info itself: " + parentInsn);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(DebugInfoParser.class);, +				if (i < mthArgs.size()) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +				fallbackOnlyInsn(insn);, +	private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, +		if (!fallback) {, +			throw new CodegenException(insn.getType() + " can be used only in fallback mode");, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java, +import jadx.core.utils.exceptions.JadxRuntimeException;]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	JavaMethod getJavaMethodByNode(MethodNode mth) {, +		JavaMethod javaMethod = methodsMap.get(mth);, +		if (javaMethod != null) {, +			return javaMethod;, +		}, +		// parent class not loaded yet, +		JavaClass javaClass = classesMap.get(mth.getParentClass());, +		if (javaClass != null) {, +			javaClass.decompile();, +			return methodsMap.get(mth);, +		}, +		return null;, +	}, +, +	JavaField getJavaFieldByNode(FieldNode fld) {, +		JavaField javaField = fieldsMap.get(fld);, +		if (javaField != null) {, +			return javaField;, +		}, +		// parent class not loaded yet, +		JavaClass javaClass = classesMap.get(fld.getParentClass());, +		if (javaClass != null) {, +			javaClass.decompile();, +			return fieldsMap.get(fld);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	JavaMethod getJavaMethodByNode(MethodNode mth) {, +		JavaMethod javaMethod = methodsMap.get(mth);, +		if (javaMethod != null) {, +			return javaMethod;, +		}, +		// parent class not loaded yet, +		JavaClass javaClass = classesMap.get(mth.getParentClass());, +		if (javaClass != null) {, +			javaClass.decompile();, +			return methodsMap.get(mth);, +		}, +		return null;, +	}, +, +	JavaField getJavaFieldByNode(FieldNode fld) {, +		JavaField javaField = fieldsMap.get(fld);, +		if (javaField != null) {, +			return javaField;, +		}, +		// parent class not loaded yet, +		JavaClass javaClass = classesMap.get(fld.getParentClass());, +		if (javaClass != null) {, +			javaClass.decompile();, +			return fieldsMap.get(fld);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +			return getRootDecompiler().getJavaMethodByNode(((MethodNode) obj));, +			return getRootDecompiler().getJavaFieldByNode((FieldNode) obj);, +		return getFullName();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	JavaMethod getJavaMethodByNode(MethodNode mth) {, +		JavaMethod javaMethod = methodsMap.get(mth);, +		if (javaMethod != null) {, +			return javaMethod;, +		}, +		// parent class not loaded yet, +		JavaClass javaClass = classesMap.get(mth.getParentClass());, +		if (javaClass != null) {, +			javaClass.decompile();, +			return methodsMap.get(mth);, +		}, +		return null;, +	}, +, +	JavaField getJavaFieldByNode(FieldNode fld) {, +		JavaField javaField = fieldsMap.get(fld);, +		if (javaField != null) {, +			return javaField;, +		}, +		// parent class not loaded yet, +		JavaClass javaClass = classesMap.get(fld.getParentClass());, +		if (javaClass != null) {, +			javaClass.decompile();, +			return fieldsMap.get(fld);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +			return getRootDecompiler().getJavaMethodByNode(((MethodNode) obj));, +			return getRootDecompiler().getJavaFieldByNode((FieldNode) obj);, +		return getFullName();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			List<ClassInfo> sortedImports = new ArrayList<>(imports);, +			sortedImports.sort(Comparator.comparing(classInfo -> classInfo.getAlias().getFullName()));, +			sortedImports.forEach(classInfo -> {, +				ClassNode classNode = cls.root().resolveClass(classInfo);]
[+++ b/jadx-core/src/main/java/jadx/core/utils/exceptions/JadxOverflowException.java, +, +	private static final long serialVersionUID = 2568659798680154204L;, +]
[+++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			ClassInfo extClsInfo = ClassInfo.extCls(mth.root(), type);, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			ClassInfo extClsInfo = ClassInfo.extCls(mth.root(), type);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.api.JadxArgs;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.SourceFileAttr;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.info.MethodInfo;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +				preProcessClass(cls);, +				processClass(cls);, +	private void resolveOverriding(MethodNode mth) {, +		String mthSignature = mth.getMethodInfo().makeSignature(false);, +		ClassNode cls = mth.getParentClass();, +		resolveOverridingInternal(mth.dex(), cls, mthSignature, overrideSet, cls);, +		}, +	private void processClass(ClassNode cls) {, +			clsInfo.rename(cls.dex().root(), fullName);, +			renameField(field);, +		}, +		for (MethodNode mth : cls.getMethods()) {, +			renameMethod(mth);, +		}, +		for (ClassNode innerCls : cls.getInnerClasses()) {, +			processClass(innerCls);, +		}, +	}, +, +	public void renameField(FieldNode field) {, +, +	public void renameMethod(MethodNode mth) {, +			mth.getMethodInfo().setAlias(alias);, +			resolveOverriding(mth);, +	private void preProcessClass(ClassNode cls) {, +		} else {, +			if (!clsMap.containsKey(classInfo), +					&& shouldRename(classInfo.getShortName())) {, +		for (ClassNode innerCls : cls.getInnerClasses()) {, +			preProcessClass(innerCls);, +		}, +	}, +		if (cls.getClassInfo().isInner()) {, +			return null;, +		}, +		} else if (name.endsWith(".kt")) {, +			name = name.substring(0, name.length() - ".kt".length());, +		if (!NameMapper.isValidIdentifier(name) || NameMapper.isReserved(name)) {, +			return null;, +		}, +		for (DeobfClsInfo deobfClsInfo : clsMap.values()) {, +			if (deobfClsInfo.getAlias().equals(name)) {, +				return null;, +			}, +		}, +		ClassNode otherCls = cls.dex().root().searchClassByName(cls.getPackage() + "." + name);, +		if (otherCls != null) {, +			return null;, +		}, +	private String getFieldAlias(FieldNode field) {, +	private String getMethodAlias(MethodNode mth) {, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +			ClassInfo extClsInfo = ClassInfo.extCls(mth.root(), type);]
[+++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +			} else {, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +			} else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +			} else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +++ /dev/null, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +			} else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +++ /dev/null, +++ /dev/null, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +			} else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import javax.swing.ProgressMonitor;, +, +		List<String> excludedPackages = getExcludedPackages();, +		if (excludedPackages.isEmpty()) {, +			for (String exclude : excludedPackages) {, +	public List<String> getExcludedPackages() {, +		String excludedPackages = settings.getExcludedPackages().trim();, +		return Arrays.asList(excludedPackages.split("[ ]+"));, +	}, +, +	public void addExcludedPackage(String packageToExclude) {, +		settings.setExcludedPackages(settings.getExcludedPackages() + ' ' + packageToExclude);, +		settings.sync();, +	}, +, +	public void removeExcludedPackage(String packageToRemoveFromExclusion) {, +		List<String> list = new ArrayList<>(getExcludedPackages());, +		list.remove(packageToRemoveFromExclusion);, +		settings.setExcludedPackages(String.join(" ", list));, +		settings.sync();, +	}, +, +++ b/.travis.yml, +      if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			InsnNode insn = insnByOffset[offset];, +			insn.add(AFlag.TRY_ENTER);, +			} else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import javax.swing.ProgressMonitor;, +, +		List<String> excludedPackages = getExcludedPackages();, +		if (excludedPackages.isEmpty()) {, +			for (String exclude : excludedPackages) {, +	public List<String> getExcludedPackages() {, +		String excludedPackages = settings.getExcludedPackages().trim();, +		return Arrays.asList(excludedPackages.split("[ ]+"));, +	}, +, +	public void addExcludedPackage(String packageToExclude) {, +		settings.setExcludedPackages(settings.getExcludedPackages() + ' ' + packageToExclude);, +		settings.sync();]
[+++ b/build.gradle, +    compileJava {, +        options.compilerArgs << '-Xlint', +    }, +, +    gradleVersion = '1.7', +++ b/build.gradle, +    compileJava {, +        options.compilerArgs << '-Xlint', +    }, +, +    gradleVersion = '1.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    compileJava {, +        options.compilerArgs << '-Xlint', +    }, +, +    gradleVersion = '1.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.7-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +	private final Set<BlockNode> skipBlocks;, +		this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new HashSet<BlockNode>());, +	              Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {, +	public void merge(IfInfo... arr) {, +		for (IfInfo info : arr) {, +			mergedBlocks.addAll(info.getMergedBlocks());, +			skipBlocks.addAll(info.getSkipBlocks());, +		}, +	}, +, +	public Set<BlockNode> getSkipBlocks() {, +		return skipBlocks;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +	private final Set<BlockNode> skipBlocks;, +		this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new HashSet<BlockNode>());, +	              Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {, +	public void merge(IfInfo... arr) {, +		for (IfInfo info : arr) {, +			mergedBlocks.addAll(info.getMergedBlocks());, +			skipBlocks.addAll(info.getSkipBlocks());, +		}, +	}, +, +	public Set<BlockNode> getSkipBlocks() {, +		return skipBlocks;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		result.merge(currentIf, nextThen, nextElse);, +		result.merge(first, second);, +	private static void skipSimplePath(BlockNode block, Set<BlockNode> skipped) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +	private final Set<BlockNode> skipBlocks;, +		this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new HashSet<BlockNode>());, +	              Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {, +	public void merge(IfInfo... arr) {, +		for (IfInfo info : arr) {, +			mergedBlocks.addAll(info.getMergedBlocks());, +			skipBlocks.addAll(info.getSkipBlocks());, +		}, +	}, +, +	public Set<BlockNode> getSkipBlocks() {, +		return skipBlocks;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		result.merge(currentIf, nextThen, nextElse);, +		result.merge(first, second);, +	private static void skipSimplePath(BlockNode block, Set<BlockNode> skipped) {, +++ b/jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions15.java, +package jadx.tests.internal.conditions;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestConditions15 extends InternalJadxTest {, +, +	public static class TestCls {, +, +		private static boolean test(final String name) {, +			if (isEmpty(name)) {, +				return false;, +			}, +			if ("1".equals(name), +					|| "2".equals(name), +					|| "3".equals(name), +					|| "4".equals(name), +					|| "5".equals(name), +					|| "6".equals(name), +					|| "7".equals(name), +					|| "8".equals(name), +					|| "9".equals(name), +					|| "10".equals(name), +					|| "11".equals(name), +					|| "12".equals(name), +					|| "13".equals(name), +					|| "14".equals(name), +					|| "15".equals(name), +					|| "16".equals(name), +					|| "17".equals(name), +					|| "18".equals(name), +					|| "19".equals(name), +					|| "20".equals(name), +					|| "22".equals(name), +					|| "22".equals(name), +					|| "23".equals(name), +					|| "24".equals(name), +					|| "25".equals(name), +					|| "26".equals(name), +					|| "27".equals(name), +					|| "28".equals(name)]
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +			final String resTypeName = resource.getTypeName();, +					resTypeName,, +			final String resName;, +			if ("style".equals(resTypeName)) {, +				resName = resource.getKeyName().replace('.', '_');, +			} else {, +				resName = resource.getKeyName();, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +				if (!dir.exists() && !dir.mkdirs()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +				if (!dir.exists() && !dir.mkdirs()) {, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, +		private final Map<String, JavaClassObject> clsMap = new ConcurrentHashMap<>();, +		private final Map<String, Class<?>> clsCache = new ConcurrentHashMap<>();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +, +	/**, +	 * Resources *, +	 */, +		resourcesNames = resStorage.getResourcesNames();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +, +	/**, +	 * Resources *, +	 */, +		resourcesNames = resStorage.getResourcesNames();, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.core.xmlgen.entry.ValuesParser;, +	private final Map<Integer, String> styleMap = new HashMap<Integer, String>();, +	private final Map<Integer, FieldNode> localStyleMap = new HashMap<Integer, FieldNode>();, +	private final Map<Integer, String> resNames;, +	private ValuesParser valuesParser;, +, +			resNames = root.getResourcesNames();, +, +					valuesParser = new ValuesParser(strings, resNames);, +					die("Type: 0x" + Integer.toHexString(type) + " not yet implemented");, +		if (attrValDataType == TYPE_REFERENCE) {, +			// reference custom processing, +					String resName = resNames.get(attrValData);, +					if (resName != null) {, +						writer.add("@").add(resName);, +					} else {, +			}, +		} else {, +			String str = valuesParser.decodeValue(attrValDataType, attrValData);, +			writer.add(str);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +, +	/**, +	 * Resources *, +	 */, +		resourcesNames = resStorage.getResourcesNames();, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.core.xmlgen.entry.ValuesParser;, +	private final Map<Integer, String> styleMap = new HashMap<Integer, String>();, +	private final Map<Integer, FieldNode> localStyleMap = new HashMap<Integer, FieldNode>();, +	private final Map<Integer, String> resNames;, +	private ValuesParser valuesParser;, +, +			resNames = root.getResourcesNames();, +, +					valuesParser = new ValuesParser(strings, resNames);, +					die("Type: 0x" + Integer.toHexString(type) + " not yet implemented");, +		if (attrValDataType == TYPE_REFERENCE) {, +			// reference custom processing, +					String resName = resNames.get(attrValData);, +					if (resName != null) {, +						writer.add("@").add(resName);, +					} else {, +			}, +		} else {, +			String str = valuesParser.decodeValue(attrValDataType, attrValData);, +			writer.add(str);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, +		writer.add("app package: ").add(resStorage.getAppPackage());, +		writer.startLine();, +, +		ValuesParser vp = new ValuesParser(strings, resStorage.getResourcesNames());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +, +	/**, +	 * Resources *, +	 */, +		resourcesNames = resStorage.getResourcesNames();, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.core.xmlgen.entry.ValuesParser;, +	private final Map<Integer, String> styleMap = new HashMap<Integer, String>();, +	private final Map<Integer, FieldNode> localStyleMap = new HashMap<Integer, FieldNode>();, +	private final Map<Integer, String> resNames;, +	private ValuesParser valuesParser;, +, +			resNames = root.getResourcesNames();, +, +					valuesParser = new ValuesParser(strings, resNames);, +					die("Type: 0x" + Integer.toHexString(type) + " not yet implemented");, +		if (attrValDataType == TYPE_REFERENCE) {, +			// reference custom processing, +					String resName = resNames.get(attrValData);, +					if (resName != null) {, +						writer.add("@").add(resName);, +					} else {, +			}, +		} else {]
[+++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		passes = null;, +		codeGen = null;, +		init();, +, +		root = new RootNode(args);, +		root.initClassPath();, +, +		initVisitors();, +	}, +, +	private void initVisitors() {, +		for (IDexTreeVisitor pass : passes) {, +			try {, +				pass.init(root);, +			} catch (Exception e) {, +				LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		passes = null;, +		codeGen = null;, +		init();, +, +		root = new RootNode(args);, +		root.initClassPath();, +, +		initVisitors();, +	}, +, +	private void initVisitors() {, +		for (IDexTreeVisitor pass : passes) {, +			try {, +				pass.init(root);, +			} catch (Exception e) {, +				LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +		if (map.isEmpty()) {, +			return null;, +		}, +		return cls.getShortName();, +		return cls.getFullName();, +		return cls.getPackage();, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		passes = null;, +		codeGen = null;, +		init();, +, +		root = new RootNode(args);, +		root.initClassPath();, +, +		initVisitors();, +	}, +, +	private void initVisitors() {, +		for (IDexTreeVisitor pass : passes) {, +			try {, +				pass.init(root);, +			} catch (Exception e) {, +				LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +		if (map.isEmpty()) {, +			return null;, +		}, +		return cls.getShortName();, +		return cls.getFullName();, +		return cls.getPackage();, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +		this.name = name;, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		passes = null;, +		codeGen = null;, +		init();, +, +		root = new RootNode(args);, +		root.initClassPath();, +, +		initVisitors();, +	}, +, +	private void initVisitors() {, +		for (IDexTreeVisitor pass : passes) {, +			try {, +				pass.init(root);, +			} catch (Exception e) {, +				LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +		if (map.isEmpty()) {, +			return null;]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables7.java, +package jadx.tests.integration.variables;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.containsString;, +, +import java.util.ArrayList;, +import java.util.List;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +public class TestVariables7 extends IntegrationTest {, +, +	public static class TestCls {, +, +		public void test() {, +			List list;, +			synchronized (this) {, +				list = new ArrayList();, +			}, +			for (Object o : list) {, +				System.out.println(o);, +			}, +		}, +	}, +, +	@Test, +	@NotYetImplemented, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("     list = new ArrayList"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, +			passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, +			passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +import jadx.core.dex.nodes.parser.FieldInitAttr.InitType;, +			FieldInitAttr fv = f.get(AType.FIELD_INIT);, +					if (fv.getValueType() == InitType.CONST) {, +					} else if (fv.getValueType() == InitType.INSN) {, +						InsnGen insnGen = makeInsnGen(fv.getInsnMth());, +						addInsnBody(insnGen, code, fv.getInsn());, +					}, +					igen = makeInsnGen(enumFields.getStaticMethod());, +	private InsnGen makeInsnGen(MethodNode mth) {, +		MethodGen mthGen = new MethodGen(this, mth);, +		return new InsnGen(mthGen, false);, +	}, +, +	private void addInsnBody(InsnGen insnGen, CodeWriter code, InsnNode insn) {, +		try {, +			insnGen.makeInsn(insn, code, InsnGen.Flags.BODY_ONLY_NOWRAP);, +		} catch (Exception e) {, +			ErrorsCounter.classError(cls, "Failed to generate init code", e);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, +			passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +import jadx.core.dex.nodes.parser.FieldInitAttr.InitType;, +			FieldInitAttr fv = f.get(AType.FIELD_INIT);, +					if (fv.getValueType() == InitType.CONST) {, +					} else if (fv.getValueType() == InitType.INSN) {, +						InsnGen insnGen = makeInsnGen(fv.getInsnMth());, +						addInsnBody(insnGen, code, fv.getInsn());, +					}, +					igen = makeInsnGen(enumFields.getStaticMethod());, +	private InsnGen makeInsnGen(MethodNode mth) {, +		MethodGen mthGen = new MethodGen(this, mth);, +		return new InsnGen(mthGen, false);, +	}, +, +	private void addInsnBody(InsnGen insnGen, CodeWriter code, InsnNode insn) {, +		try {, +			insnGen.makeInsn(insn, code, InsnGen.Flags.BODY_ONLY_NOWRAP);, +		} catch (Exception e) {, +			ErrorsCounter.classError(cls, "Failed to generate init code", e);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +						FieldInitAttr valueAttr = fn.get(AType.FIELD_INIT);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, +			passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +import jadx.core.dex.nodes.parser.FieldInitAttr.InitType;, +			FieldInitAttr fv = f.get(AType.FIELD_INIT);, +					if (fv.getValueType() == InitType.CONST) {, +					} else if (fv.getValueType() == InitType.INSN) {, +						InsnGen insnGen = makeInsnGen(fv.getInsnMth());, +						addInsnBody(insnGen, code, fv.getInsn());, +					}, +					igen = makeInsnGen(enumFields.getStaticMethod());, +	private InsnGen makeInsnGen(MethodNode mth) {, +		MethodGen mthGen = new MethodGen(this, mth);, +		return new InsnGen(mthGen, false);, +	}, +, +	private void addInsnBody(InsnGen insnGen, CodeWriter code, InsnNode insn) {, +		try {, +			insnGen.makeInsn(insn, code, InsnGen.Flags.BODY_ONLY_NOWRAP);, +		} catch (Exception e) {, +			ErrorsCounter.classError(cls, "Failed to generate init code", e);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +						FieldInitAttr valueAttr = fn.get(AType.FIELD_INIT);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +	public static final AType<FieldInitAttr> FIELD_INIT = new AType<FieldInitAttr>();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, +			passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +import jadx.core.dex.nodes.parser.FieldInitAttr.InitType;]
[+++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +        jcenter(), +    }, +}, +, +plugins {, +    id "com.github.kt3k.coveralls" version "2.0.1", +    id "info.solidsoft.pitest" version "1.1.1", +//    id "com.github.ben-manes.versions" version "0.6", +}, +ext.jadxVersion = file('version').readLines().get(0), +version = jadxVersion, +, +    apply plugin: 'com.github.kt3k.coveralls', +        testCompile 'org.mockito:mockito-core:1.10.13', +/* Sonar runner configuration */, +sonarRunner {, +    toolVersion = '2.4', +task pitest(overwrite: true, dependsOn: 'jadx-core:pitest') {, +task cleanBuildDir(type: Delete) {, +build.dependsOn(dist, samples), +, +clean.dependsOn(cleanBuildDir), +, +    gradleVersion = '2.2.1', +++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +        jcenter(), +    }, +}, +, +plugins {, +    id "com.github.kt3k.coveralls" version "2.0.1", +    id "info.solidsoft.pitest" version "1.1.1", +//    id "com.github.ben-manes.versions" version "0.6", +}, +ext.jadxVersion = file('version').readLines().get(0), +version = jadxVersion, +, +    apply plugin: 'com.github.kt3k.coveralls', +        testCompile 'org.mockito:mockito-core:1.10.13', +/* Sonar runner configuration */, +sonarRunner {, +    toolVersion = '2.4', +task pitest(overwrite: true, dependsOn: 'jadx-core:pitest') {, +task cleanBuildDir(type: Delete) {, +build.dependsOn(dist, samples), +, +clean.dependsOn(cleanBuildDir), +, +    gradleVersion = '2.2.1', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +        jcenter(), +    }, +}, +, +plugins {, +    id "com.github.kt3k.coveralls" version "2.0.1", +    id "info.solidsoft.pitest" version "1.1.1", +//    id "com.github.ben-manes.versions" version "0.6", +}, +ext.jadxVersion = file('version').readLines().get(0), +version = jadxVersion, +, +    apply plugin: 'com.github.kt3k.coveralls', +        testCompile 'org.mockito:mockito-core:1.10.13', +/* Sonar runner configuration */, +sonarRunner {, +    toolVersion = '2.4', +task pitest(overwrite: true, dependsOn: 'jadx-core:pitest') {, +task cleanBuildDir(type: Delete) {, +build.dependsOn(dist, samples), +, +clean.dependsOn(cleanBuildDir), +, +    gradleVersion = '2.2.1', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-bin.zip, +++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +        jcenter(), +    }, +}, +, +plugins {, +    id "com.github.kt3k.coveralls" version "2.0.1", +    id "info.solidsoft.pitest" version "1.1.1", +//    id "com.github.ben-manes.versions" version "0.6"]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import java.io.InputStream;, +					try (InputStream is = resources.nextElement().openStream()) {, +						Manifest manifest = new Manifest(is);, +			}]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +		code.add(callMth.getAlias());, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoVisitor());, +			}, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoVisitor());]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java, +	public InsnContainer(List<InsnNode> insns) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java, +	public InsnContainer(List<InsnNode> insns) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import java.util.Iterator;, +import java.util.LinkedList;, +		handlers = new LinkedList<ExceptionHandler>();, +		for (Iterator<ExceptionHandler> it = handlers.iterator(); it.hasNext(); ) {, +			ExceptionHandler h = it.next();, +			if (h == handler) {, +				it.remove();, +		} else {, +			for (InsnNode insn : insns) {, +			}, +			for (BlockNode block : mth.getBasicBlocks()) {, +		}, +	}, +		setFinalBlock(new InsnContainer(finalBlockInsns));, +			for (BlockNode ehb : h.getBlocks()) {, +		}, +			if (attr == ca) {, +	}, +		for (InsnNode insn : tryBlock.getInsns()) {, +		}, +		for (ExceptionHandler eh : handlers) {, +		}, +		return handlers.hashCode();, +		if (this == obj) {, +		if (obj == null || getClass() != obj.getClass()) {, +			return false;, +		}, +		TryCatchBlock other = (TryCatchBlock) obj;, +		return handlers.equals(other.handlers);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java, +	public InsnContainer(List<InsnNode> insns) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import java.util.Iterator;, +import java.util.LinkedList;, +		handlers = new LinkedList<ExceptionHandler>();, +		for (Iterator<ExceptionHandler> it = handlers.iterator(); it.hasNext(); ) {, +			ExceptionHandler h = it.next();, +			if (h == handler) {, +				it.remove();, +		} else {, +			for (InsnNode insn : insns) {, +			}, +			for (BlockNode block : mth.getBasicBlocks()) {, +		}, +	}, +		setFinalBlock(new InsnContainer(finalBlockInsns));, +			for (BlockNode ehb : h.getBlocks()) {, +		}, +			if (attr == ca) {, +	}, +		for (InsnNode insn : tryBlock.getInsns()) {, +		}, +		for (ExceptionHandler eh : handlers) {, +		}, +		return handlers.hashCode();, +		if (this == obj) {, +		if (obj == null || getClass() != obj.getClass()) {, +			return false;, +		}, +		TryCatchBlock other = (TryCatchBlock) obj;, +		return handlers.equals(other.handlers);, +	}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestTryCatch.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatch extends InternalJadxTest {, +, +	public static class TestCls {, +		private void f() {, +			try {, +				Thread.sleep(50);, +			} catch (InterruptedException e) {, +				// ignore, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("try {"));, +		assertThat(code, containsString("Thread.sleep(50);"));, +		assertThat(code, containsString("} catch (InterruptedException e) {"));, +	}]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import java.awt.Component;, +import java.awt.FlowLayout;, +import javax.swing.BorderFactory;, +import javax.swing.ImageIcon;, +import javax.swing.JButton;, +import javax.swing.JLabel;, +import javax.swing.JMenuItem;, +import javax.swing.JPanel;, +import javax.swing.JPopupMenu;, +import javax.swing.JTabbedPane;, +import javax.swing.SwingUtilities;, +import javax.swing.plaf.basic.BasicButtonUI;, +import javax.swing.text.BadLocationException;, +import jadx.gui.treemodel.JCertificate;, +import jadx.gui.treemodel.JClass;, +		JMenuItem copyRootClassName = new JMenuItem(NLS.str("tabs.copy_class_name"));, +		copyRootClassName.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent actionEvent) {, +				copyRootClassName();, +			}, +		});, +		menu.add(copyRootClassName);, +, +	public void copyRootClassName(){, +		ContentPanel selectedPanel = getSelectedCodePanel();, +		JNode node = selectedPanel.getNode();, +		JClass jClass = node.getRootClass();, +		if (jClass != null){, +			String name = jClass.getFullName();, +			Utils.setClipboardString(name);, +		}, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import java.awt.Component;, +import java.awt.FlowLayout;, +import javax.swing.BorderFactory;, +import javax.swing.ImageIcon;, +import javax.swing.JButton;, +import javax.swing.JLabel;, +import javax.swing.JMenuItem;, +import javax.swing.JPanel;, +import javax.swing.JPopupMenu;, +import javax.swing.JTabbedPane;, +import javax.swing.SwingUtilities;, +import javax.swing.plaf.basic.BasicButtonUI;, +import javax.swing.text.BadLocationException;, +import jadx.gui.treemodel.JCertificate;, +import jadx.gui.treemodel.JClass;, +		JMenuItem copyRootClassName = new JMenuItem(NLS.str("tabs.copy_class_name"));, +		copyRootClassName.addActionListener(new ActionListener() {, +			@Override, +			public void actionPerformed(ActionEvent actionEvent) {, +				copyRootClassName();, +			}, +		});, +		menu.add(copyRootClassName);, +, +	public void copyRootClassName(){, +		ContentPanel selectedPanel = getSelectedCodePanel();, +		JNode node = selectedPanel.getNode();, +		JClass jClass = node.getRootClass();, +		if (jClass != null){, +			String name = jClass.getFullName();, +			Utils.setClipboardString(name);, +		}, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import java.awt.Font;, +import java.awt.Toolkit;, +import java.awt.datatransfer.Clipboard;, +import java.awt.datatransfer.StringSelection;, +import java.awt.datatransfer.Transferable;, +, +import javax.swing.Action;, +import javax.swing.Icon;, +import javax.swing.ImageIcon;, +import javax.swing.JComponent;, +import javax.swing.KeyStroke;, +, +	public static void setClipboardString(String text){, +		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();, +		Transferable transferable = new StringSelection(text);, +		clipboard.setContents(transferable, null);, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.Collections;, +import java.util.HashSet;, +	private final Set<String> reservedClsNames = new HashSet<>();, +				Collections.addAll(reservedClsNames, cls.getPackage().split("\\."));, +			}, +		}, +		for (DexNode dexNode : dexNodes) {, +			for (ClassNode cls : dexNode.getClasses()) {, +			if (!clsMap.containsKey(classInfo)) {, +				String clsShortName = classInfo.getShortName();, +				if (shouldRename(clsShortName) || reservedClsNames.contains(clsShortName)) {, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		if (cls.getAccessFlags().isSynthetic(), +				&& cls.getFields().isEmpty(), +				&& cls.getMethods().isEmpty()) {, +			cls.getAttributes().add(AttributeFlag.DONT_GENERATE);, +			return false;, +		}, +, +			// remove synthetic constructor for inner non-static classes, +			if (af.isSynthetic() && af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +				List<InsnNode> insns = mth.getBasicBlocks().get(0).getInstructions();, +				if (insns.size() == 1 && insns.get(0).getType() == InsnType.CONSTRUCTOR) {, +					ConstructorInsn constr = (ConstructorInsn) insns.get(0);, +					if (constr.isThis() && mth.getArguments(false).size() >= 1) {, +						mth.removeFirstArgument();, +						mth.getAttributes().add(AttributeFlag.DONT_GENERATE);, +					}, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		if (cls.getAccessFlags().isSynthetic(), +				&& cls.getFields().isEmpty(), +				&& cls.getMethods().isEmpty()) {, +			cls.getAttributes().add(AttributeFlag.DONT_GENERATE);, +			return false;, +		}, +, +			// remove synthetic constructor for inner non-static classes, +			if (af.isSynthetic() && af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +				List<InsnNode> insns = mth.getBasicBlocks().get(0).getInstructions();, +				if (insns.size() == 1 && insns.get(0).getType() == InsnType.CONSTRUCTOR) {, +					ConstructorInsn constr = (ConstructorInsn) insns.get(0);, +					if (constr.isThis() && mth.getArguments(false).size() >= 1) {, +						mth.removeFirstArgument();, +						mth.getAttributes().add(AttributeFlag.DONT_GENERATE);, +					}, +				}, +			}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestInnerClass2.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.util.Timer;, +import java.util.TimerTask;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestInnerClass2 extends InternalJadxTest {, +, +	public static class TestCls {, +		private static class TerminateTask extends TimerTask {, +			@Override, +			public void run() {, +				System.err.println("Test timed out");, +			}, +		}, +, +		public void test() {, +			new Timer().schedule(new TerminateTask(), 1000);, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("new Timer().schedule(new TerminateTask(), 1000);"));, +		assertThat(code, not(containsString("synthetic")));, +		assertThat(code, not(containsString("this")));, +		assertThat(code, not(containsString("null")));, +		assertThat(code, not(containsString("AnonymousClass")));, +	}, +}]
[+++ b/.travis.yml, +    - env: JDK=openjdk11, +      jdk: openjdk11]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +		boolean replaced = false;, +			replaced = true;, +			replaced = true;, +		return replaced;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +		boolean replaced = false;, +			replaced = true;, +			replaced = true;, +		return replaced;, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase2.java, +package jadx.tests.integration.switches;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +, +public class TestSwitchReturnFromCase2 extends IntegrationTest {, +, +	public static class TestCls {, +		public boolean test(int a) {, +			switch (a % 4) {, +				case 2:, +				case 3:, +					if (a == 2) {, +						return true;, +					}, +					return true;, +			}, +			return false;, +		}, +, +		public void check() {, +			assertTrue(test(2));, +			assertTrue(test(3));, +			assertTrue(test(15));, +			assertFalse(test(1));, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("switch (a % 4) {"));, +	}, +}]
[+++ b/build.gradle, +    gradleVersion = '1.8', +++ b/build.gradle, +    gradleVersion = '1.8', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    gradleVersion = '1.8', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip]
[+++ b/.travis.yml, +    - TERM=dumb ./gradlew jacocoTestReport, +    - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/.travis.yml, +    - TERM=dumb ./gradlew jacocoTestReport, +    - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/.travis.yml, +    - TERM=dumb ./gradlew jacocoTestReport, +    - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/build.gradle, +allprojects {, +        mavenCentral(), +            xml.enabled = true, +++ b/.travis.yml, +    - TERM=dumb ./gradlew jacocoTestReport, +    - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/build.gradle, +allprojects {, +        mavenCentral(), +            xml.enabled = true, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-2.14.1-bin.zip, +++ b/.travis.yml, +    - TERM=dumb ./gradlew jacocoTestReport, +    - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/build.gradle, +allprojects {, +        mavenCentral(), +            xml.enabled = true, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-2.14.1-bin.zip, +++ b/jadx-core/build.gradle, +++ b/.travis.yml, +    - TERM=dumb ./gradlew jacocoTestReport, +    - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/build.gradle, +allprojects {, +        mavenCentral(), +            xml.enabled = true, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-2.14.1-bin.zip, +++ b/jadx-core/build.gradle, +++ b/jadx-gui/build.gradle]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	// change default types priority, +			PrimitiveType.INT,, +			PrimitiveType.OBJECT, PrimitiveType.ARRAY,, +			PrimitiveType.BOOLEAN, PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	// change default types priority, +			PrimitiveType.INT,, +			PrimitiveType.OBJECT, PrimitiveType.ARRAY,, +			PrimitiveType.BOOLEAN, PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR);, +++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java, +package jadx.tests.integration.types;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.Arrays;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertThat;, +, +public class TestTypeResolver4 extends IntegrationTest {, +, +	public static class TestCls {, +, +		private static String test(byte[] strArray, int offset) {, +			int len = strArray.length;, +			int start = offset + f(strArray, offset);, +			int end = start;, +			while (end + 1 < len && (strArray[end] != 0 || strArray[end + 1] != 0)) {, +				end += 2;, +			}, +			byte[] arr = Arrays.copyOfRange(strArray, start, end);, +			return new String(arr);, +		}, +, +		private static int f(byte[] strArray, int offset) {, +			return 0;, +		}, +, +		public void check() {, +			String test = test(("1234" + "utfstr\0\0" + "4567").getBytes(), 4);, +			assertThat(test, is("utfstr"));, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("(strArray[end] != (byte) 0 || strArray[end + 1] != (byte) 0)"));, +	}, +, +	@Test, +	public void test2() {, +		noDebugInfo();, +		getClassNode(TestCls.class);, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.loadResources(getResources());, +		root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.loadResources(getResources());, +		root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return ResourcesLoader.loadContent(decompiler, this);, +	ZipRef getZipRef() {, +		return zipRef;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.loadResources(getResources());, +		root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return ResourcesLoader.loadContent(decompiler, this);, +	ZipRef getZipRef() {, +		return zipRef;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public static interface ResourceDecoder {, +		Object decode(long size, InputStream is) throws IOException;, +	}, +, +	public static Object decodeStream(ResourceFile rf, ResourceDecoder decoder) throws JadxException {, +		ZipRef zipRef = rf.getZipRef();, +			if (entry == null) {, +				throw new IOException("Zip entry not found: " + zipRef);, +			return decoder.decode(entry.getSize(), inputStream);, +		} catch (Exception e) {, +			throw new JadxException("Error load: " + zipRef, e);, +	}, +, +	static CodeWriter loadContent(final JadxDecompiler jadxRef, final ResourceFile rf) {, +		try {, +			return (CodeWriter) decodeStream(rf, new ResourceDecoder() {, +				@Override, +				public Object decode(long size, InputStream is) throws IOException {, +					if (size > LOAD_SIZE_LIMIT) {, +						return new CodeWriter().add("File too big, size: ", +								+ String.format("%.2f KB", size / 1024.));, +					}, +					return loadContent(jadxRef, rf.getType(), is);, +				}, +			});, +		} catch (JadxException e) {, +			LOG.error("Decode error", e);, +		}, +	private static CodeWriter loadContent(JadxDecompiler jadxRef, ResourceType type,, +			LOG.debug("Not a zip file: {}", file.getAbsolutePath());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.loadResources(getResources());, +		root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return ResourcesLoader.loadContent(decompiler, this);, +	ZipRef getZipRef() {, +		return zipRef;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +	public static interface ResourceDecoder {, +		Object decode(long size, InputStream is) throws IOException;, +	}, +, +	public static Object decodeStream(ResourceFile rf, ResourceDecoder decoder) throws JadxException {, +		ZipRef zipRef = rf.getZipRef();, +			if (entry == null) {, +				throw new IOException("Zip entry not found: " + zipRef);, +			return decoder.decode(entry.getSize(), inputStream);, +		} catch (Exception e) {, +			throw new JadxException("Error load: " + zipRef, e);, +	}, +, +	static CodeWriter loadContent(final JadxDecompiler jadxRef, final ResourceFile rf) {, +		try {, +			return (CodeWriter) decodeStream(rf, new ResourceDecoder() {, +				@Override, +				public Object decode(long size, InputStream is) throws IOException {, +					if (size > LOAD_SIZE_LIMIT) {, +						return new CodeWriter().add("File too big, size: ", +								+ String.format("%.2f KB", size / 1024.));, +					}, +					return loadContent(jadxRef, rf.getType(), is);, +				}, +			});, +		} catch (JadxException e) {, +			LOG.error("Decode error", e);, +		}, +	private static CodeWriter loadContent(JadxDecompiler jadxRef, ResourceType type,, +			LOG.debug("Not a zip file: {}", file.getAbsolutePath());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import com.android.dx.rop.code.AccessFlags;, +	// empty synthetic class, +	public ClassNode(DexNode dex, ClassInfo clsInfo) {, +		this.dex = dex;, +		this.clsInfo = clsInfo;, +		this.interfaces = Collections.emptyList();, +		this.methods = Collections.emptyList();]
[+++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/build.gradle, +	id 'org.ec4j.editorconfig' version '0.0.3', +editorconfig {, +	excludes = ['gradle/', +				, 'jadx-test-app/test-app' // ignore issues in submodule, +				, '**/out/' // IntelliJ Idea build dirs, +				, '**/certificate-test/' // binary test files (.RSA), +				, '**/*.svg', +				, '**/*.arsc', +	], +}, +, +check.dependsOn editorconfigCheck, +, +test.dependsOn(samples), +++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/build.gradle, +	id 'org.ec4j.editorconfig' version '0.0.3', +editorconfig {, +	excludes = ['gradle/', +				, 'jadx-test-app/test-app' // ignore issues in submodule, +				, '**/out/' // IntelliJ Idea build dirs, +				, '**/certificate-test/' // binary test files (.RSA), +				, '**/*.svg', +				, '**/*.arsc', +	], +}, +, +check.dependsOn editorconfigCheck, +, +test.dependsOn(samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		InsnArg activeReg = activeRegisters[var.getRegNum()];, +		if (activeReg instanceof RegisterArg) {, +			SSAVar ssaVar = ((RegisterArg) activeReg).getSVar();, +			if (ssaVar != null && ssaVar.getStartAddr() != -1) {, +				InsnNode parentInsn = ssaVar.getAssign().getParentInsn();, +				if (parentInsn != null && parentInsn.getOffset() >= 0) {, +					addr = parentInsn.getOffset();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		InsnArg activeReg = activeRegisters[var.getRegNum()];, +		if (activeReg instanceof RegisterArg) {, +			SSAVar ssaVar = ((RegisterArg) activeReg).getSVar();, +			if (ssaVar != null && ssaVar.getStartAddr() != -1) {, +				InsnNode parentInsn = ssaVar.getAssign().getParentInsn();, +				if (parentInsn != null && parentInsn.getOffset() >= 0) {, +					addr = parentInsn.getOffset();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +				ArgType argType = castArg.getType();, +				// Don't removes CHECK_CAST for wrapped INVOKE if invoked method returns different type, +					InsnNode wrapInsn = ((InsnWrapArg) castArg).getWrapInsn();, +						argType = ((InvokeNode) wrapInsn).getCallMth().getReturnType();, +				ArgType castToType = (ArgType) ((IndexInsnNode) insn).getIndex();, +				if (!ArgType.isCastNeeded(argType, castToType)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		InsnArg activeReg = activeRegisters[var.getRegNum()];, +		if (activeReg instanceof RegisterArg) {, +			SSAVar ssaVar = ((RegisterArg) activeReg).getSVar();, +			if (ssaVar != null && ssaVar.getStartAddr() != -1) {, +				InsnNode parentInsn = ssaVar.getAssign().getParentInsn();, +				if (parentInsn != null && parentInsn.getOffset() >= 0) {, +					addr = parentInsn.getOffset();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +				ArgType argType = castArg.getType();, +				// Don't removes CHECK_CAST for wrapped INVOKE if invoked method returns different type, +					InsnNode wrapInsn = ((InsnWrapArg) castArg).getWrapInsn();, +						argType = ((InvokeNode) wrapInsn).getCallMth().getReturnType();, +				ArgType castToType = (ArgType) ((IndexInsnNode) insn).getIndex();, +				if (!ArgType.isCastNeeded(argType, castToType)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +				LOG.debug("Fixing incorrect switch cases order, method: {}", mth);]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), +	protected boolean xmlTest = false;, +, +	public boolean isXMLTest() {, +		return xmlTest;, +	}, +, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), +	protected boolean xmlTest = false;, +, +	public boolean isXMLTest() {, +		return xmlTest;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean isXMLTest() {, +		return false;, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), +	protected boolean xmlTest = false;, +, +	public boolean isXMLTest() {, +		return xmlTest;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean isXMLTest() {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean isXMLTest();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), +	protected boolean xmlTest = false;, +, +	public boolean isXMLTest() {, +		return xmlTest;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean isXMLTest() {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean isXMLTest();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.BinaryXMLParser;, +		if(this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				BinaryXMLParser bxp = new BinaryXMLParser(InputFile.loadXMLBuffer(inf.getFile()), "./AndroidManifest.xml");, +				//BinaryXMLParser bxp = new BinaryXMLParser(InputFile.loadXMLBuffer(inf.getFile()), "AndroidManifest.xml");, +				bxp.parse();, +			} catch(IOException ioe) {, +				LOG.info("Decompiling AndroidManifest.xml failed!");, +			}, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), +	protected boolean xmlTest = false;, +, +	public boolean isXMLTest() {, +		return xmlTest;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean isXMLTest() {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean isXMLTest();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.BinaryXMLParser;, +		if(this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				BinaryXMLParser bxp = new BinaryXMLParser(InputFile.loadXMLBuffer(inf.getFile()), "./AndroidManifest.xml");, +				//BinaryXMLParser bxp = new BinaryXMLParser(InputFile.loadXMLBuffer(inf.getFile()), "AndroidManifest.xml");, +				bxp.parse();, +			} catch(IOException ioe) {, +				LOG.info("Decompiling AndroidManifest.xml failed!");]
[+++ b/build.gradle, +    id 'org.sonarqube' version '2.6.2', +    id 'com.github.ben-manes.versions' version '0.17.0', +        compile 'org.slf4j:slf4j-api:1.7.25', +        testCompile 'ch.qos.logback:logback-classic:1.2.3', +        testCompile 'org.mockito:mockito-core:2.15.0', +        testCompile 'org.spockframework:spock-core:1.1-groovy-2.4', +        testCompile 'cglib:cglib-nodep:3.2.6', +    jacoco {, +        toolVersion = "0.8.0", +    }, +dependencyUpdates.resolutionStrategy = {, +    componentSelection { rules ->, +        rules.all { ComponentSelection selection ->, +            boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'atlassian'].any { qualifier ->, +                selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/, +            }, +            if (rejected) {, +                selection.reject('Release candidate'), +            }, +        }, +    }, +}, +, +++ b/build.gradle, +    id 'org.sonarqube' version '2.6.2', +    id 'com.github.ben-manes.versions' version '0.17.0', +        compile 'org.slf4j:slf4j-api:1.7.25', +        testCompile 'ch.qos.logback:logback-classic:1.2.3', +        testCompile 'org.mockito:mockito-core:2.15.0', +        testCompile 'org.spockframework:spock-core:1.1-groovy-2.4', +        testCompile 'cglib:cglib-nodep:3.2.6', +    jacoco {, +        toolVersion = "0.8.0", +    }, +dependencyUpdates.resolutionStrategy = {, +    componentSelection { rules ->, +        rules.all { ComponentSelection selection ->, +            boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'atlassian'].any { qualifier ->, +                selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/, +            }, +            if (rejected) {, +                selection.reject('Release candidate'), +            }, +        }, +    }, +}, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    id 'org.sonarqube' version '2.6.2', +    id 'com.github.ben-manes.versions' version '0.17.0', +        compile 'org.slf4j:slf4j-api:1.7.25', +        testCompile 'ch.qos.logback:logback-classic:1.2.3', +        testCompile 'org.mockito:mockito-core:2.15.0', +        testCompile 'org.spockframework:spock-core:1.1-groovy-2.4', +        testCompile 'cglib:cglib-nodep:3.2.6', +    jacoco {, +        toolVersion = "0.8.0", +    }, +dependencyUpdates.resolutionStrategy = {, +    componentSelection { rules ->, +        rules.all { ComponentSelection selection ->, +            boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'atlassian'].any { qualifier ->, +                selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/, +            }, +            if (rejected) {, +                selection.reject('Release candidate'), +            }, +        }, +    }, +}, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.5.1-bin.zip, +++ b/build.gradle, +    id 'org.sonarqube' version '2.6.2', +    id 'com.github.ben-manes.versions' version '0.17.0', +        compile 'org.slf4j:slf4j-api:1.7.25', +        testCompile 'ch.qos.logback:logback-classic:1.2.3', +        testCompile 'org.mockito:mockito-core:2.15.0', +        testCompile 'org.spockframework:spock-core:1.1-groovy-2.4', +        testCompile 'cglib:cglib-nodep:3.2.6', +    jacoco {, +        toolVersion = "0.8.0", +    }, +dependencyUpdates.resolutionStrategy = {, +    componentSelection { rules ->, +        rules.all { ComponentSelection selection ->, +            boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'atlassian'].any { qualifier ->, +                selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/, +            }, +            if (rejected) {, +                selection.reject('Release candidate'), +            }, +        }, +    }, +}, +]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		if (isR(cls.getParentClass())) {, +			return;, +		}, +, +	private static boolean isR(ClassNode cls) {, +		if (!cls.getClassInfo().getShortName().equals("R")) {, +			return false;, +		}, +		if (!cls.getMethods().isEmpty() || !cls.getFields().isEmpty()) {, +			return false;, +		}, +		for (ClassNode inner : cls.getInnerClasses()) {, +			for (MethodNode m : inner.getMethods()) {, +				if (!m.getMethodInfo().isConstructor() && !m.getMethodInfo().isClassInit()) {, +					return false;, +				}, +			}, +			for (FieldNode field : cls.getFields()) {, +				ArgType type = field.getType();, +				if (type != ArgType.INT && (!type.isArray() || type.getArrayElement() != ArgType.INT)) {, +					return false;, +				}, +			}, +		}, +		return true;, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributesList.java, +import java.util.LinkedList;, +		attributes = new LinkedList<IAttribute>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributesList.java, +import java.util.LinkedList;, +		attributes = new LinkedList<IAttribute>();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.LinkedHashMap;, +	private final AccessInfo accessFlags;, +	private final List<MethodNode> methods;, +	private final List<FieldNode> fields;, +	private Map<Object, FieldNode> constFields = Collections.emptyMap();, +			if (cls.getSupertypeIndex() == DexNode.NO_INDEX) {, +				this.superClass = null;, +			} else {, +				this.superClass = ClassInfo.fromDex(dex, cls.getSupertypeIndex());, +			}, +				int mthsCount = clsData.getDirectMethods().length + clsData.getVirtualMethods().length;, +				int fieldsCount = clsData.getStaticFields().length + clsData.getInstanceFields().length;, +				methods = new ArrayList<MethodNode>(mthsCount);, +				fields = new ArrayList<FieldNode>(fieldsCount);, +, +				for (Method mth : clsData.getDirectMethods()) {, +				}, +				for (Method mth : clsData.getVirtualMethods()) {, +				}, +				for (Field f : clsData.getStaticFields()) {, +				}, +				for (Field f : clsData.getInstanceFields()) {, +			} else {, +				methods = Collections.emptyList();, +				fields = Collections.emptyList();, +			}, +			// restore original access flags from dalvik annotation if present, +			if (a != null) {, +			} else {, +			}, +			int count = parser.processFields(staticFields);, +			constFields = new LinkedHashMap<Object, FieldNode>(count);, +		if (a == null) {, +		}, +			if (a != null) {, +				if (gType != null) {, +		}, +	}, +			if (f.getName().equals(name)) {, +		}, +			if (f.getName().equals(name)) {, +		}, +			if (m.getMethodInfo().equals(mth)) {, +		}, +			if (m.getMethodInfo().getShortId().equals(shortId)) {, +		}, +		if (innerClasses.isEmpty()) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributesList.java, +import java.util.LinkedList;, +		attributes = new LinkedList<IAttribute>();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.LinkedHashMap;, +	private final AccessInfo accessFlags;, +	private final List<MethodNode> methods;, +	private final List<FieldNode> fields;, +	private Map<Object, FieldNode> constFields = Collections.emptyMap();, +			if (cls.getSupertypeIndex() == DexNode.NO_INDEX) {, +				this.superClass = null;, +			} else {, +				this.superClass = ClassInfo.fromDex(dex, cls.getSupertypeIndex());, +			}, +				int mthsCount = clsData.getDirectMethods().length + clsData.getVirtualMethods().length;, +				int fieldsCount = clsData.getStaticFields().length + clsData.getInstanceFields().length;, +				methods = new ArrayList<MethodNode>(mthsCount);, +				fields = new ArrayList<FieldNode>(fieldsCount);, +, +				for (Method mth : clsData.getDirectMethods()) {, +				}, +				for (Method mth : clsData.getVirtualMethods()) {, +				}, +				for (Field f : clsData.getStaticFields()) {, +				}, +				for (Field f : clsData.getInstanceFields()) {, +			} else {, +				methods = Collections.emptyList();, +				fields = Collections.emptyList();, +			}, +			// restore original access flags from dalvik annotation if present, +			if (a != null) {, +			} else {, +			}, +			int count = parser.processFields(staticFields);, +			constFields = new LinkedHashMap<Object, FieldNode>(count);, +		if (a == null) {, +		}, +			if (a != null) {, +				if (gType != null) {, +		}, +	}, +			if (f.getName().equals(name)) {, +		}, +			if (f.getName().equals(name)) {]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		setFromOut(args);, +		checkDir(args.getOutDir());, +		checkDir(args.getOutDirSrc());, +		checkDir(args.getOutDirRes());, +	private static void setFromOut(JadxArgs args) {, +		if (args.getOutDirSrc() == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (args.getOutDirRes() == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +	}, +, +	private static void checkDir(File dir) {, +			throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		setFromOut(args);, +		checkDir(args.getOutDir());, +		checkDir(args.getOutDirSrc());, +		checkDir(args.getOutDirRes());, +	private static void setFromOut(JadxArgs args) {, +		if (args.getOutDirSrc() == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (args.getOutDirRes() == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +	}, +, +	private static void checkDir(File dir) {, +			throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		setFromOut(args);, +		checkDir(args.getOutDir());, +		checkDir(args.getOutDirSrc());, +		checkDir(args.getOutDirRes());, +	private static void setFromOut(JadxArgs args) {, +		if (args.getOutDirSrc() == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (args.getOutDirRes() == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +	}, +, +	private static void checkDir(File dir) {, +			throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +			passes.add(new CleanRegions());, +			passes.add(new ProcessVariables());, +			passes.add(new PrepareForCodeGen());, +++ b/.gitignore, +*.orig]
[+++ /dev/null, +++ /dev/null, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);, +		try {, +			JadxCLIArgs jadxArgs = new JadxCLIArgs(args);, +			checkArgs(jadxArgs);, +		} catch (Throwable e) {, +			LOG.error(e.getMessage());, +			System.exit(1);, +		}, +	}, +, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, +		if (jadxArgs.getInput().isEmpty()), +			throw new JadxException("Please specify input file");, +, +		File outputDir = jadxArgs.getOutDir();, +		if (outputDir == null) {, +			String outDirName;, +			File file = jadxArgs.getInput().get(0);, +			String name = file.getName();, +			int pos = name.lastIndexOf('.');, +			if (pos != -1), +				outDirName = name.substring(0, pos);, +			else, +				outDirName = name + "-jadx-out";, +, +			LOG.info("output directory: " + outDirName);, +			outputDir = new File(outDirName);, +			jadxArgs.setOutputDir(outputDir);, +		}, +		if (outputDir.exists() && !outputDir.isDirectory()), +			throw new JadxException("Output directory exists as file " + outputDir);, +++ /dev/null, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);, +		try {, +			JadxCLIArgs jadxArgs = new JadxCLIArgs(args);, +			checkArgs(jadxArgs);, +		} catch (Throwable e) {, +			LOG.error(e.getMessage());, +			System.exit(1);, +		}, +	}, +, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, +		if (jadxArgs.getInput().isEmpty()), +			throw new JadxException("Please specify input file");, +, +		File outputDir = jadxArgs.getOutDir();, +		if (outputDir == null) {, +			String outDirName;, +			File file = jadxArgs.getInput().get(0);, +			String name = file.getName();, +			int pos = name.lastIndexOf('.');, +			if (pos != -1), +				outDirName = name.substring(0, pos);, +			else, +				outDirName = name + "-jadx-out";, +, +			LOG.info("output directory: " + outDirName);, +			outputDir = new File(outDirName);, +			jadxArgs.setOutputDir(outputDir);, +		}, +		if (outputDir.exists() && !outputDir.isDirectory()), +			throw new JadxException("Output directory exists as file " + outputDir);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +package jadx.cli;, +, +import jadx.api.IJadxArgs;, +import jadx.core.Consts;, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.Parameter;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +		boolean reThrow = false;, +				reThrow = true;, +		if (totalSize == 0 && noExitNode && reThrow) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import jadx.gui.utils.TextStandardActions;, +		new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import jadx.gui.utils.TextStandardActions;, +		new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +		new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import jadx.gui.utils.TextStandardActions;, +		new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +		new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java, +package jadx.gui.utils;, +, +import javax.swing.AbstractAction;, +import javax.swing.Action;, +import javax.swing.JPopupMenu;, +import javax.swing.KeyStroke;, +import javax.swing.event.UndoableEditEvent;, +import javax.swing.event.UndoableEditListener;, +import javax.swing.text.JTextComponent;, +import javax.swing.undo.UndoManager;, +import java.awt.Toolkit;, +import java.awt.datatransfer.DataFlavor;, +import java.awt.event.ActionEvent;, +import java.awt.event.InputEvent;, +import java.awt.event.KeyEvent;, +import java.awt.event.MouseAdapter;, +import java.awt.event.MouseEvent;, +, +@SuppressWarnings("serial"), +public class TextStandardActions {, +, +	private final JTextComponent textComponent;, +, +	private final JPopupMenu popup = new JPopupMenu();, +	private final UndoManager undoManager;, +, +	private Action undoAction;, +	private Action redoAction;, +	private Action cutAction;, +	private Action copyAction;, +	private Action pasteAction;, +	private Action deleteAction;, +	private Action selectAllAction;, +, +	public TextStandardActions(JTextComponent textComponent) {, +		this.textComponent = textComponent;, +		this.undoManager = new UndoManager();, +, +		initActions();, +		addPopupItems();, +		addKeyActions();, +, +		registerListeners();, +	}, +, +	private void initActions() {, +		undoAction = new AbstractAction(NLS.str("popup.undo")) {, +			@Override, +			public void actionPerformed(ActionEvent ae) {, +				if (undoManager.canUndo()) {, +					undoManager.undo();, +				}, +			}, +		};, +		redoAction = new AbstractAction(NLS.str("popup.redo")) {, +			@Override, +			public void actionPerformed(ActionEvent ae) {, +				if (undoManager.canRedo()) {, +					undoManager.redo();, +				}, +			}, +		};, +		cutAction = new AbstractAction(NLS.str("popup.cut")) {, +			@Override, +			public void actionPerformed(ActionEvent ae) {, +				textComponent.cut();, +			}, +		};, +		copyAction = new AbstractAction(NLS.str("popup.copy")) {, +			@Override, +			public void actionPerformed(ActionEvent ae) {, +				textComponent.copy();, +			}, +		};, +		pasteAction = new AbstractAction(NLS.str("popup.paste")) {, +			@Override, +			public void actionPerformed(ActionEvent ae) {, +				textComponent.paste();, +			}, +		};, +		deleteAction = new AbstractAction(NLS.str("popup.delete")) {, +			@Override, +			public void actionPerformed(ActionEvent ae) {, +				textComponent.replaceSelection("");, +			}, +		};]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		int maxAddr = insnByOffset.length - 1;, +		newAddr = Math.min(newAddr, maxAddr);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		int maxAddr = insnByOffset.length - 1;, +		newAddr = Math.min(newAddr, maxAddr);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +, +		InstructionRemover remover = new InstructionRemover(mth);, +		replaceStep(mth, remover);, +		removeStep(mth, remover);, +	private static void replaceStep(MethodNode mth, InstructionRemover remover) {, +			remover.setBlock(block);, +						processInvoke(mth, block, i, remover);, +	private static void processInvoke(MethodNode mth, BlockNode block, int insnNumber, InstructionRemover remover) {, +		ClassNode parentClass = mth.getParentClass();, +		InsnNode insn = block.getInstructions().get(insnNumber);, +		InvokeNode inv = (InvokeNode) insn;, +		MethodInfo callMth = inv.getCallMth();, +		if (callMth.isConstructor()) {, +			InsnNode instArgAssignInsn = ((RegisterArg) inv.getArg(0)).getAssignInsn();, +			ConstructorInsn co = new ConstructorInsn(mth, inv);, +			boolean remove = false;, +			if (co.isSuper() && (co.getArgsCount() == 0 || parentClass.isEnum())) {, +				remove = true;, +			} else if (co.isThis() && co.getArgsCount() == 0) {, +				MethodNode defCo = parentClass.searchMethodByName(callMth.getShortId());, +				if (defCo == null || defCo.isNoCode()) {, +					// default constructor not implemented, +					remove = true;, +				}, +			}, +			// remove super() call in instance initializer, +			if (parentClass.isAnonymous() && mth.isDefaultConstructor() && co.isSuper()) {, +				remove = true;, +			}, +			if (remove) {, +				remover.add(insn);, +			} else {, +				replaceInsn(block, insnNumber, co);, +				if (co.isNewInstance()) {, +					removeAssignChain(instArgAssignInsn, remover, InsnType.NEW_INSTANCE);, +				}, +			}, +		} else if (inv.getArgsCount() > 0) {, +			for (int j = 0; j < inv.getArgsCount(); j++) {, +				InsnArg arg = inv.getArg(j);, +				if (arg.isLiteral()) {, +					FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +					if (f != null) {, +						arg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, +					}, +				}, +			}, +		}, +	}, +, +	/**, +	 * Remove instructions on 'move' chain until instruction with type 'insnType', +	 */, +	private static void removeAssignChain(InsnNode insn, InstructionRemover remover, InsnType insnType) {, +		if (insn == null) {, +			return;, +		}, +		remover.add(insn);, +		InsnType type = insn.getType();, +		if (type == insnType) {, +			return;, +		}, +		if (type == InsnType.MOVE) {, +			RegisterArg arg = (RegisterArg) insn.getArg(0);, +			removeAssignChain(arg.getAssignInsn(), remover, insnType);, +		}, +	}, +, +	private static void removeStep(MethodNode mth, InstructionRemover remover) {, +			remover.setBlock(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public boolean isNewInstance() {, +		return callType == CallType.CONSTRUCTOR;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		int maxAddr = insnByOffset.length - 1;, +		newAddr = Math.min(newAddr, maxAddr);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		RegisterArg iterVar = arrGetInsn.getResult();, +		if (iterVar == null) {, +			return null;, +		}, +		if (iterVar == null || !fixIterableType(iterableArg, iterVar)) {, +			LOG.debug(" LoopRegionVisitor: instruction not found: {}, mth: {}", parentInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		RegisterArg iterVar = arrGetInsn.getResult();, +		if (iterVar == null) {, +			return null;, +		}, +		if (iterVar == null || !fixIterableType(iterableArg, iterVar)) {, +			LOG.debug(" LoopRegionVisitor: instruction not found: {}, mth: {}", parentInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +					if (j >= phiInsn.getArgsCount()) {, +						continue;, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		RegisterArg iterVar = arrGetInsn.getResult();, +		if (iterVar == null) {, +			return null;, +		}, +		if (iterVar == null || !fixIterableType(iterableArg, iterVar)) {, +			LOG.debug(" LoopRegionVisitor: instruction not found: {}, mth: {}", parentInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +					if (j >= phiInsn.getArgsCount()) {, +						continue;, +					}, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CodeArea.java, +			// fast skip, +			if (token.length() == 1) {, +				char ch = token.getTextArray()[token.getTextOffset()];, +				if (ch == '.' || ch == ',' || ch == ';') {, +					return false;, +				}, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {, +				useClass(code, it.next());, +			}, +			while (it.hasNext()) {, +				code.add(" | ");, +				useClass(code, it.next());, +			}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, +		} else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {, +				useClass(code, it.next());, +			}, +			while (it.hasNext()) {, +				code.add(" | ");, +				useClass(code, it.next());, +			}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, +		} else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +import org.jetbrains.annotations.NotNull;, +, +public final class ClassInfo implements Comparable<ClassInfo> {, +, +	@Override, +	public int compareTo(@NotNull ClassInfo o) {, +		return fullName.compareTo(o.fullName);, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {, +				useClass(code, it.next());, +			}, +			while (it.hasNext()) {, +				code.add(" | ");, +				useClass(code, it.next());, +			}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, +		} else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +import org.jetbrains.annotations.NotNull;, +, +public final class ClassInfo implements Comparable<ClassInfo> {, +, +	@Override, +	public int compareTo(@NotNull ClassInfo o) {, +		return fullName.compareTo(o.fullName);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			this.regsCount = mthCode.getRegistersSize();, +			this.instructions = decoder.process();, +			this.codeSize = instructions.length;, +			initTryCatches(this, mthCode, instructions);, +			initJumps(instructions);, +	private static void initTryCatches(MethodNode mth, Code mthCode, InsnNode[] insnByOffset) {, +		int handlersCount = 0;, +			int[] handlerAddrArr = handler.getAddresses();, +			for (int i = 0; i < handlerAddrArr.length; i++) {, +				int addr = handlerAddrArr[i];, +				ClassInfo type = ClassInfo.fromDex(mth.dex(), handler.getTypeIndexes()[i]);, +				tcBlock.addHandler(mth, addr, type);, +				handlersCount++;, +				tcBlock.addHandler(mth, addr, null);, +				handlersCount++;, +		if (handlersCount > 0 && handlersCount != addrs.size()) {, +							ct2.removeHandler(mth, h);, +				// TODO: don't override existing attribute, +	private static void initJumps(InsnNode[] insnByOffset) {, +				if (h.equals(handler)) {, +					return h;, +				}, +				if (h.getHandleOffset() == handler.getHandleOffset()) {, +					if (h.getTryBlock() == handler.getTryBlock()) {, +						for (ClassInfo catchType : handler.getCatchTypes()) {, +							h.addCatchType(catchType);, +						}, +					} else {, +						// same handlers from different try blocks, +						// will merge later, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		Runnable save = () -> {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		Runnable save = () -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +				String msg = NLS.str("message.indexingClassesSkipped", searchIndex.getSkippedCount());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +			SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		Runnable save = () -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +				String msg = NLS.str("message.indexingClassesSkipped", searchIndex.getSkippedCount());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java, +package jadx.gui.settings;, +, +import java.io.BufferedWriter;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.util.Arrays;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.google.gson.Gson;, +import com.google.gson.GsonBuilder;, +, +import jadx.gui.utils.PathTypeAdapter;, +, +public class JadxProject {, +, +	private static final Logger LOG = LoggerFactory.getLogger(JadxProject.class);, +	private static final int CURRENT_SETTINGS_VERSION = 0;, +, +	public static final String PROJECT_EXTENSION = "jadx";, +, +	private static final Gson GSON = new GsonBuilder(), +			.registerTypeHierarchyAdapter(Path.class, PathTypeAdapter.singleton()), +			.create();, +, +	private transient JadxSettings settings;, +	private transient String name = "New Project";, +	private transient Path projectPath;, +	private List<Path> filesPath;, +	private transient boolean saved;, +	private transient boolean initial = true;, +, +	private int projectVersion = 0;, +, +	public JadxProject(JadxSettings settings) {, +		this.settings = settings;, +	}, +, +	public Path getProjectPath() {, +		return projectPath;, +	}, +, +	private void setProjectPath(Path projectPath) {, +		this.projectPath = projectPath;, +		if (projectVersion != CURRENT_SETTINGS_VERSION) {, +			upgradeSettings(projectVersion);, +		}, +		name = projectPath.getFileName().toString();, +		name = name.substring(0, name.lastIndexOf('.'));, +		changed();, +	}, +, +	public Path getFilePath() {, +		return filesPath == null ? null : filesPath.get(0);, +	}, +, +	public void setFilePath(Path filePath) {, +		if (!filePath.equals(getFilePath())) {, +			this.filesPath = Arrays.asList(filePath);, +			changed();, +		}, +	}, +, +	private void changed() {, +		if (settings.isAutoSaveProject()) {, +			save();, +		}, +		else {, +			saved = false;, +		}, +		initial = false;, +	}, +, +	public String getName() {]
[+++ b/.gitignore, +# Eclipse files, +# IntelliJ Idea files, +.idea/, +out/, +*.iml, +]
[+++ b/.travis.yml, +    - oraclejdk8]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		return parentGen == null ? this : parentGen;]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +						.doOnError(e -> LOG.error("Error prepare search: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +						.doOnError(e -> LOG.error("Error prepare search: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java, +	private final Object syncData = new Object();, +, +		synchronized (syncData) {, +	}, +			synchronized (syncData) {, +				int size = keys.size();, +			}, +		synchronized (syncData) {, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import java.util.HashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.Nullable;, +, +	@Nullable, +	private Map<FieldNode, KeyValueMap> fieldsMap;, +	@Nullable, +		if (fieldsMap == null) {, +			return null;, +		}, +			if (fieldsMap == null) {, +				fieldsMap = new HashMap<>();, +			}, +	public boolean isEmpty() {, +		return fieldsMap == null || fieldsMap.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import java.util.HashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.Nullable;, +, +	@Nullable, +	private Map<FieldNode, KeyValueMap> fieldsMap;, +	@Nullable, +		if (fieldsMap == null) {, +			return null;, +		}, +			if (fieldsMap == null) {, +				fieldsMap = new HashMap<>();, +			}, +	public boolean isEmpty() {, +		return fieldsMap == null || fieldsMap.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.core.dex.nodes.DexNode;, +	public boolean visit(ClassNode cls) throws JadxException {, +		initClsEnumMap(cls);, +		return true;, +	}, +, +	@Override, +		EnumMapInfo enumMapInfo = checkEnumMapAccess(mth.dex(), wrapInsn);, +	private static void initClsEnumMap(ClassNode enumCls) {, +		MethodNode clsInitMth = enumCls.getClassInitMth();, +			return;, +		EnumMapAttr mapAttr = new EnumMapAttr();, +					addToEnumMap(enumCls.dex(), mapAttr, insn);, +		if (!mapAttr.isEmpty()) {, +			enumCls.addAttr(mapAttr);, +	@Nullable, +	private static EnumMapAttr.KeyValueMap getEnumMap(MethodNode mth, FieldNode field) {, +		ClassNode syntheticClass = field.getParentClass();, +		EnumMapAttr mapAttr = syntheticClass.get(AType.ENUM_MAP);, +		if (mapAttr == null) {, +			return null;, +		}, +		return mapAttr.getMap(field);, +	}, +, +	private static void addToEnumMap(DexNode dex, EnumMapAttr mapAttr, InsnNode aputInsn) {, +		EnumMapInfo mapInfo = checkEnumMapAccess(dex, aputInsn);, +		FieldNode fieldNode = dex.resolveField((FieldInfo) index);, +	public static EnumMapInfo checkEnumMapAccess(DexNode dex, InsnNode checkInsn) {, +		ClassNode enumCls = dex.resolveClass(inv.getCallMth().getDeclClass());, +		FieldNode enumMapField = dex.resolveField((FieldInfo) index);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import java.util.HashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.Nullable;, +, +	@Nullable, +	private Map<FieldNode, KeyValueMap> fieldsMap;, +	@Nullable, +		if (fieldsMap == null) {, +			return null;, +		}, +			if (fieldsMap == null) {, +				fieldsMap = new HashMap<>();, +			}, +	public boolean isEmpty() {, +		return fieldsMap == null || fieldsMap.isEmpty();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			if (c == null) {, +				throw new JadxRuntimeException("Switch block not found by offset: " + entry.getKey());, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			if (c == null) {, +				throw new JadxRuntimeException("Switch block not found by offset: " + entry.getKey());, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java, +import jadx.core.dex.regions.SwitchRegion;, +, +		@Override, +		public boolean enterRegion(MethodNode mth, IRegion region) {, +			super.enterRegion(mth, region);, +			return !(region instanceof SwitchRegion);, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			if (c == null) {, +				throw new JadxRuntimeException("Switch block not found by offset: " + entry.getKey());, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java, +import jadx.core.dex.regions.SwitchRegion;, +, +		@Override, +		public boolean enterRegion(MethodNode mth, IRegion region) {, +			super.enterRegion(mth, region);, +			return !(region instanceof SwitchRegion);, +		}, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitch3.java, +package jadx.tests.integration.switches;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.countString;, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertThat;, +, +public class TestSwitch3 extends IntegrationTest {, +, +	public static class TestCls {, +		private int i;, +, +		void test(int a) {, +			switch (a) {, +				case 1:, +					i = 1;, +					return;, +				case 2:, +				case 3:, +					i = 2;, +					return;, +				default:, +					i = 4;, +					break;, +			}, +			i = 5;, +		}, +, +		public void check() {, +			test(1);, +			assertThat(i, is(1));, +			test(2);, +			assertThat(i, is(2));, +			test(3);, +			assertThat(i, is(2));, +			test(4);, +			assertThat(i, is(5));, +			test(10);, +			assertThat(i, is(5));, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, countString(0, "break;"));, +		assertThat(code, countString(3, "return;"));, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, +					if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, +						code.startLine("/* JADX WARNING: inconsistent code */");, +						LOG.error(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +						mthGen.makeMethodDump(code);, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, +					if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, +						code.startLine("/* JADX WARNING: inconsistent code */");, +						LOG.error(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +						mthGen.makeMethodDump(code);, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			makeMethodDump(code);, +	public void makeMethodDump(CodeWriter code) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, +					if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, +						code.startLine("/* JADX WARNING: inconsistent code */");, +						LOG.error(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +						mthGen.makeMethodDump(code);, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			makeMethodDump(code);, +	public void makeMethodDump(CodeWriter code) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import jadx.core.dex.nodes.BlockNode;, +import static jadx.core.utils.BlockUtils.getBlockByOffset;, +import static jadx.core.utils.BlockUtils.selectOther;, +, +	private BlockNode thenBlock;, +	private BlockNode elseBlock;, +, +	public void invertCondition() {, +		BlockNode tmp = thenBlock;, +		thenBlock = elseBlock;, +		elseBlock = tmp;, +		target = thenBlock.getStartOffset();, +			if (getArgsCount() == 2) {, +			} else {, +	}, +, +	public void initBlocks(BlockNode curBlock) {, +		thenBlock = getBlockByOffset(target, curBlock.getSuccessors());, +		if (curBlock.getSuccessors().size() == 1) {, +			elseBlock = thenBlock;, +		} else {, +			elseBlock = selectOther(thenBlock, curBlock.getSuccessors());, +		}, +		target = thenBlock.getStartOffset();, +	}, +, +	public BlockNode getThenBlock() {, +		return thenBlock;, +	}, +, +	public BlockNode getElseBlock() {, +		return elseBlock;, +	}, +				+ "  -> " + (thenBlock != null ? thenBlock : InsnUtils.formatOffset(target));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, +					if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, +						code.startLine("/* JADX WARNING: inconsistent code */");, +						LOG.error(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +						mthGen.makeMethodDump(code);, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +			makeMethodDump(code);, +	public void makeMethodDump(CodeWriter code) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import jadx.core.dex.nodes.BlockNode;, +import static jadx.core.utils.BlockUtils.getBlockByOffset;, +import static jadx.core.utils.BlockUtils.selectOther;, +, +	private BlockNode thenBlock;, +	private BlockNode elseBlock;, +, +	public void invertCondition() {, +		BlockNode tmp = thenBlock;, +		thenBlock = elseBlock;, +		elseBlock = tmp;]
[+++ b/README.md, + -e, --export-gradle        - save as android gradle project, +++ b/README.md, + -e, --export-gradle        - save as android gradle project, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-e", "--export-gradle"}, description = "save as android gradle project"), +	protected boolean exportAsGradleProject = false;, +, +, +	@Override, +	public boolean isExportAsGradleProject() {, +		return exportAsGradleProject;, +	}, +++ b/README.md, + -e, --export-gradle        - save as android gradle project, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-e", "--export-gradle"}, description = "save as android gradle project"), +	protected boolean exportAsGradleProject = false;, +, +, +	@Override, +	public boolean isExportAsGradleProject() {, +		return exportAsGradleProject;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	/**, +	 * Save as gradle project, +	 */, +	boolean isExportAsGradleProject();, +++ b/README.md, + -e, --export-gradle        - save as android gradle project, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-e", "--export-gradle"}, description = "save as android gradle project"), +	protected boolean exportAsGradleProject = false;, +, +, +	@Override, +	public boolean isExportAsGradleProject() {, +		return exportAsGradleProject;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	/**, +	 * Save as gradle project, +	 */, +	boolean isExportAsGradleProject();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean exportAsGradleProject = false;, +, +	@Override, +	public boolean isExportAsGradleProject() {, +		return exportAsGradleProject;, +	}, +, +	public void setExportAsGradleProject(boolean exportAsGradleProject) {, +		this.exportAsGradleProject = exportAsGradleProject;, +	}, +++ b/README.md, + -e, --export-gradle        - save as android gradle project, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-e", "--export-gradle"}, description = "save as android gradle project"), +	protected boolean exportAsGradleProject = false;, +, +, +	@Override, +	public boolean isExportAsGradleProject() {, +		return exportAsGradleProject;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	/**, +	 * Save as gradle project, +	 */, +	boolean isExportAsGradleProject();, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean exportAsGradleProject = false;, +, +	@Override, +	public boolean isExportAsGradleProject() {, +		return exportAsGradleProject;, +	}, +, +	public void setExportAsGradleProject(boolean exportAsGradleProject) {, +		this.exportAsGradleProject = exportAsGradleProject;, +	}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.export.ExportGradleProject;, +	private ExecutorService getSaveExecutor(boolean saveSources, boolean saveResources) {, +, +		File sourcesOutDir;, +		File resOutDir;, +		if (args.isExportAsGradleProject()) {, +			ExportGradleProject export = new ExportGradleProject(root, outDir);, +			export.init();, +			sourcesOutDir = export.getSrcOutDir();, +			resOutDir = export.getResOutDir();, +		} else {, +			sourcesOutDir = outDir;]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import java.io.File;, +import java.util.ArrayList;, +import java.util.List;, +, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, +		JadxArgs args = inputArgs.toJadxArgs();, +		args.setFsCaseSensitive(getFsCaseSensitivity(args));, +		JadxDecompiler jadx = new JadxDecompiler(args);, +, +	private static boolean getFsCaseSensitivity(JadxArgs args) {, +		List<File> testDirList = new ArrayList<>(3);, +		testDirList.add(args.getOutDir());, +		testDirList.add(args.getOutDirSrc());, +		if (!args.getInputFiles().isEmpty()) {, +			testDirList.add(args.getInputFiles().get(0));, +		}, +		return FileUtils.isCaseSensitiveFS(testDirList);, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import java.io.File;, +import java.util.ArrayList;, +import java.util.List;, +, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, +		JadxArgs args = inputArgs.toJadxArgs();, +		args.setFsCaseSensitive(getFsCaseSensitivity(args));, +		JadxDecompiler jadx = new JadxDecompiler(args);, +, +	private static boolean getFsCaseSensitivity(JadxArgs args) {, +		List<File> testDirList = new ArrayList<>(3);, +		testDirList.add(args.getOutDir());, +		testDirList.add(args.getOutDirSrc());, +		if (!args.getInputFiles().isEmpty()) {, +			testDirList.add(args.getInputFiles().get(0));, +		}, +		return FileUtils.isCaseSensitiveFS(testDirList);, +	}, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +import java.util.Collections;, +	private boolean isFsCaseSensitive;, +, +	public void setInputFile(File inputFile) {, +		this.inputFiles = Collections.singletonList(inputFile);, +	}, +, +	public boolean isFsCaseSensitive() {, +		return isFsCaseSensitive;, +	}, +, +	public void setFsCaseSensitive(boolean fsCaseSensitive) {, +		isFsCaseSensitive = fsCaseSensitive;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import java.io.File;, +import java.util.ArrayList;, +import java.util.List;, +, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, +		JadxArgs args = inputArgs.toJadxArgs();, +		args.setFsCaseSensitive(getFsCaseSensitivity(args));, +		JadxDecompiler jadx = new JadxDecompiler(args);, +, +	private static boolean getFsCaseSensitivity(JadxArgs args) {, +		List<File> testDirList = new ArrayList<>(3);, +		testDirList.add(args.getOutDir());, +		testDirList.add(args.getOutDirSrc());, +		if (!args.getInputFiles().isEmpty()) {, +			testDirList.add(args.getInputFiles().get(0));, +		}, +		return FileUtils.isCaseSensitiveFS(testDirList);, +	}, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +import java.util.Collections;, +	private boolean isFsCaseSensitive;, +, +	public void setInputFile(File inputFile) {, +		this.inputFiles = Collections.singletonList(inputFile);, +	}, +, +	public boolean isFsCaseSensitive() {, +		return isFsCaseSensitive;, +	}, +, +	public void setFsCaseSensitive(boolean fsCaseSensitive) {, +		isFsCaseSensitive = fsCaseSensitive;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		checkClasses(root, args.isFsCaseSensitive());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import java.io.File;, +import java.util.ArrayList;, +import java.util.List;, +, +import jadx.api.JadxArgs;]
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/README.md, +, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, +	public static String bytesToHex(byte[] bytes) {, +		char[] hexArray = "0123456789abcdef".toCharArray();, +		if (bytes == null || bytes.length <= 0) {, +			return null;, +		}, +		char[] hexChars = new char[bytes.length * 2];, +		for ( int j = 0; j < bytes.length; j++ ) {, +			int v = bytes[j] & 0xFF;, +			hexChars[j * 2] = hexArray[v >>> 4];, +			hexChars[j * 2 + 1] = hexArray[v & 0x0F];, +		}, +		return new String(hexChars);, +	}, +, +	public static boolean isZipfile(File file) {, +		boolean isZipfile = false;, +		InputStream is = null;, +		try {, +			byte[] headers = new byte[4];, +			is = new FileInputStream(file);, +			is.read(headers, 0, 4);, +			System.out.println(bytesToHex(headers));, +			String headerString = bytesToHex(headers);, +			if (headerString.equals("504b0304")) {, +				isZipfile = true;, +			}, +		} catch (Exception e) {, +			e.printStackTrace();, +		} finally {, +			if (is != null) {, +				try {, +					is.close();, +				} catch (IOException e) {, +					e.printStackTrace();, +				}, +			}, +		}, +, +		return isZipfile;, +	}, +, +	public static List<String> getZipfileList(File file) {, +		List<String> filelist = new ArrayList<String>();, +		ZipFile zipFile = null;, +		try {, +			zipFile = new ZipFile(file);, +			Enumeration<? extends ZipEntry> entries = zipFile.entries();, +, +			while(entries.hasMoreElements()){, +				ZipEntry entry = entries.nextElement();, +				filelist.add(entry.getName());, +				System.out.println(entry.getName());, +			}, +		} catch (IOException e) {, +			e.printStackTrace();, +			System.out.println(e.getMessage());, +		}, +, +		return filelist;, +	}, +, +	public static boolean isApkfile(File file) {, +		boolean isApkfile = false;, +		if (isZipfile(file)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		if (!(obj instanceof MethodInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		if (!(obj instanceof MethodInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.HashMap;, +	// cache maps, +	private Map<MethodInfo, MethodNode> mthInfoMap = Collections.emptyMap();, +, +			buildCache();, +	private void buildCache() {, +		mthInfoMap = new HashMap<MethodInfo, MethodNode>(methods.size());, +		for (MethodNode mth : methods) {, +			mthInfoMap.put(mth.getMethodInfo(), mth);, +		}, +	}, +, +		return mthInfoMap.get(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		if (!(obj instanceof MethodInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.HashMap;, +	// cache maps, +	private Map<MethodInfo, MethodNode> mthInfoMap = Collections.emptyMap();, +, +			buildCache();, +	private void buildCache() {, +		mthInfoMap = new HashMap<MethodInfo, MethodNode>(methods.size());, +		for (MethodNode mth : methods) {, +			mthInfoMap.put(mth.getMethodInfo(), mth);, +		}, +	}, +, +		return mthInfoMap.get(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		for (MethodNode method : parentClass.getMethods()) {, +			MethodInfo otherMthInfo = method.mthInfo;, +					&& otherMthInfo.getArgumentsTypes().size() == argsCount, +					&& otherMthInfo.getName().equals(name)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +	                    InsnNode firstNode = chain.get(0);, +	                    if (firstNode instanceof ConstStringNode) {, +		                    ConstStringNode csn = (ConstStringNode) firstNode;, +	                    } else {, +		                    return null;, +	                    }]
[+++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.preferences=首选项, +menu.sync=与编辑器同步, +menu.heapUsageBar=显示内存使用栏, +menu.update_label=发现新版本 %s！, +file.open_action=打开文件..., +search.previous=上一个, +search.find=查找, +message.indexingClassesSkipped=<html>Jadx 的内存不足。因此，%d 类没有编入索引。<br>如果要将所有类编入索引，请使用增加的最大堆大小重新启动 Jadx。</html>, +, +heapUsage.text=JADX 内存使用率：%.2f GB 共 %.2f GB, +, +preferences.title=首选项, +preferences.editor=编辑器, +preferences.language=语言, +preferences.check_for_updates=启动时检查更新, +preferences.respectBytecodeAccessModifiers=遵守字节码访问修饰符, +preferences.useImports=使用 import 语句, +preferences.excludedPackages=排除的包, +preferences.excludedPackages.tooltip=将不被解压缩或索引的以空格分隔的包名称列表（节省 RAM）, +preferences.excludedPackages.button=编辑, +preferences.excludedPackages.editDialog=<html>将不被解压或索引的以空格分隔的包名称列表（节省 RAM）<br>例如<code>android.support</html>, +preferences.select_font=更改, +popup.find_usage=查找用例, +certificate.serialPubKeyModulusSize=模数大小（位）, +, +apkSignature.signer=签名人, +apkSignature.verificationSuccess=签名验证成功, +apkSignature.verificationFailed=签名验证成功, +apkSignature.signatureSuccess=找到有效的 APK 签名 v%d, +apkSignature.signatureFailed=找到无效的 APK 签名 v%d, +apkSignature.errors=错误, +apkSignature.warnings=警告, +apkSignature.exception=APK 验证失败, +apkSignature.unprotectedEntry=不受签名保护的文件。不会检测对此 JAR 条目的未经授权的修改。]
[+++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.2', +    testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.2', +    testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case NEG:, +				oneArgInsn(code, insn, state, '-');, +, +			case NOT:, +				oneArgInsn(code, insn, state, '~');, +				break;, +	private void oneArgInsn(CodeWriter code, InsnNode insn, Set<Flags> state, char op) throws CodegenException {, +		boolean wrap = state.contains(Flags.BODY_ONLY);, +		if (wrap) {, +			code.add('(');, +		}, +		code.add(op);, +		addArg(code, insn.getArg(0));, +		if (wrap) {, +			code.add(')');, +		}, +	}, +, +++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.2', +    testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case NEG:, +				oneArgInsn(code, insn, state, '-');, +, +			case NOT:, +				oneArgInsn(code, insn, state, '~');, +				break;, +	private void oneArgInsn(CodeWriter code, InsnNode insn, Set<Flags> state, char op) throws CodegenException {, +		boolean wrap = state.contains(Flags.BODY_ONLY);, +		if (wrap) {, +			code.add('(');, +		}, +		code.add(op);, +		addArg(code, insn.getArg(0));, +		if (wrap) {, +			code.add(')');, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +			case Opcodes.NOT_INT:, +				return not(insn, ArgType.INT);, +			case Opcodes.NOT_LONG:, +				return not(insn, ArgType.LONG);, +, +	private InsnNode not(DecodedInstruction insn, ArgType type) {, +		InsnNode inode = new InsnNode(InsnType.NOT, 1);, +		inode.setResult(InsnArg.reg(insn, 0, type));, +		inode.addArg(InsnArg.reg(insn, 1, type));, +		return inode;, +	}, +, +++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.2', +    testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case NEG:, +				oneArgInsn(code, insn, state, '-');, +, +			case NOT:, +				oneArgInsn(code, insn, state, '~');, +				break;, +	private void oneArgInsn(CodeWriter code, InsnNode insn, Set<Flags> state, char op) throws CodegenException {, +		boolean wrap = state.contains(Flags.BODY_ONLY);, +		if (wrap) {, +			code.add('(');, +		}, +		code.add(op);, +		addArg(code, insn.getArg(0));, +		if (wrap) {, +			code.add(')');, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +			case Opcodes.NOT_INT:, +				return not(insn, ArgType.INT);, +			case Opcodes.NOT_LONG:, +				return not(insn, ArgType.LONG);, +, +	private InsnNode not(DecodedInstruction insn, ArgType type) {, +		InsnNode inode = new InsnNode(InsnType.NOT, 1);, +		inode.setResult(InsnArg.reg(insn, 0, type));, +		inode.addArg(InsnArg.reg(insn, 1, type));, +		return inode;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	NOT,, +++ b/jadx-core/build.gradle, +    testCompile 'org.smali:smali:2.2.2', +    testCompile 'org.smali:baksmali:2.2.2']
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		return Short.toString(s);, +		return Byte.toString(b);, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		return Short.toString(s);, +		return Byte.toString(b);, +++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java, +package jadx.tests.integration.arrays;, +, +import static org.junit.jupiter.api.Assertions.assertEquals;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestRedundantType extends IntegrationTest {, +, +	public static class TestCls {, +, +		public byte[] method() {, +	        return new byte[]{10, 11, 12};, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("return new byte[]{10, 11, 12};"));, +	}, +, +	public static class TestByte {, +, +		public byte[] method() {, +			byte[] arr = new byte[50];, +			arr[10] = 126;, +			arr[20] = 127;, +			arr[30] = (byte) 128;, +			arr[40] = (byte) 129;, +	        return arr;, +		}, +	}, +, +	@Test, +	public void testByte() {, +		ClassNode cls = getClassNode(TestByte.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("arr[10] = 126"));, +		assertThat(code, containsString("arr[20] = Byte.MAX_VALUE"));, +		assertThat(code, containsString("arr[30] = Byte.MIN_VALUE"));, +		assertThat(code, containsString("arr[40] = -127"));, +		assertEquals(-127, new TestByte().method()[40]);, +	}, +, +	public static class TestShort {, +, +		public short[] method() {, +			short[] arr = new short[50];, +			arr[10] = 32766;, +			arr[20] = 32767;, +			arr[30] = (short) 32768;, +			arr[40] = (short) 32769;, +	        return arr;, +		}, +	}, +, +	@Test, +	public void testShort() {, +		ClassNode cls = getClassNode(TestShort.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("arr[10] = 32766"));, +		assertThat(code, containsString("arr[20] = Short.MAX_VALUE"));, +		assertThat(code, containsString("arr[30] = Short.MIN_VALUE"));, +		assertThat(code, containsString("arr[40] = -32767"));, +		assertEquals(-32767, new TestShort().method()[40]);, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +		return Short.toString(s);, +		return Byte.toString(b);, +++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java, +package jadx.tests.integration.arrays;, +, +import static org.junit.jupiter.api.Assertions.assertEquals;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.MatcherAssert.assertThat;, +]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml"), +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml"), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(args.getOutDir(), "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser();, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml"), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(args.getOutDir(), "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser();, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (xml == null) {, +			if (null != in) {, +				in.close();, +			}, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml"), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(args.getOutDir(), "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser();, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (xml == null) {, +			if (null != in) {, +				in.close();, +			}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/AndroidR.java, +package jadx.core.xmlgen;, +, +/**, + * Android R class, + * TODO: load from external resources, can change between android version., + */, +, +public final class AndroidR, +{, +public static final class anim, +{, +public  anim() { throw new RuntimeException("Stub!"); }, +public static final int accelerate_decelerate_interpolator = 17432580;, +public static final int accelerate_interpolator = 17432581;, +public static final int anticipate_interpolator = 17432583;, +public static final int anticipate_overshoot_interpolator = 17432585;, +public static final int bounce_interpolator = 17432586;, +public static final int cycle_interpolator = 17432588;, +public static final int decelerate_interpolator = 17432582;, +public static final int fade_in = 17432576;, +public static final int fade_out = 17432577;, +public static final int linear_interpolator = 17432587;, +public static final int overshoot_interpolator = 17432584;, +public static final int slide_in_left = 17432578;, +public static final int slide_out_right = 17432579;, +}, +public static final class animator, +{, +public  animator() { throw new RuntimeException("Stub!"); }, +public static final int fade_in = 17498112;, +public static final int fade_out = 17498113;, +}, +public static final class array, +{, +public  array() { throw new RuntimeException("Stub!"); }, +public static final int emailAddressTypes = 17235968;, +public static final int imProtocols = 17235969;, +public static final int organizationTypes = 17235970;, +public static final int phoneTypes = 17235971;, +public static final int postalAddressTypes = 17235972;, +}, +public static final class attr, +{]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java, +import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;, +, +public final class CertificatePanel extends ContentPanel {, +	private static final long serialVersionUID = 8566591625905036877L;, +, +	private final RSyntaxTextArea textArea;, +, +		textArea = new RSyntaxTextArea(jnode.getContent());, +		loadSettings();, +		CodeArea.loadCommonSettings(getTabbedPane().getMainWindow(), textArea);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		String name = arg.getName();, +		if (name == null) {, +			return getFallbackName(arg);, +		}, +			return getFallbackName(arg);, +		String name = arg.getName();, +	private String getFallbackName(RegisterArg arg) {, +		String name = arg.getName();, +		String base = "r" + arg.getRegNum();, +		if (name != null && !name.equals("this")) {, +			return base + "_" + name;, +		}, +		return base;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		String name = arg.getName();, +		if (name == null) {, +			return getFallbackName(arg);, +		}, +			return getFallbackName(arg);, +		String name = arg.getName();, +	private String getFallbackName(RegisterArg arg) {, +		String name = arg.getName();, +		String base = "r" + arg.getRegNum();, +		if (name != null && !name.equals("this")) {, +			return base + "_" + name;, +		}, +		return base;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	public boolean isConstInsn() {, +		switch (getType()) {, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +				return true;, +, +			default:, +				return false;, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		String name = arg.getName();, +		if (name == null) {, +			return getFallbackName(arg);, +		}, +			return getFallbackName(arg);, +		String name = arg.getName();, +	private String getFallbackName(RegisterArg arg) {, +		String name = arg.getName();, +		String base = "r" + arg.getRegNum();, +		if (name != null && !name.equals("this")) {, +			return base + "_" + name;, +		}, +		return base;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	public boolean isConstInsn() {, +		switch (getType()) {, +			case CONST:, +			case CONST_STR:, +			case CONST_CLASS:, +				return true;, +, +			default:, +				return false;, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +import static jadx.core.utils.EmptyBitSet.EMPTY;, +, +			InsnType.MONITOR_EXIT, +	);, +			exit.setDomFrontier(EMPTY);, +			domFrontier = EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		String name = arg.getName();, +		if (name == null) {, +			return getFallbackName(arg);, +		}, +			return getFallbackName(arg);, +		String name = arg.getName();, +	private String getFallbackName(RegisterArg arg) {, +		String name = arg.getName();, +		String base = "r" + arg.getRegNum();, +		if (name != null && !name.equals("this")) {, +			return base + "_" + name;, +		}, +		return base;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +	public boolean isConstInsn() {, +		switch (getType()) {]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		if (parent == null) {, +			return null;, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		if (parent == null) {, +			return null;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypedVar.java, +import java.util.Iterator;, +	public List<InsnArg> getUseList() {, +		return useList;, +	}, +, +	public void removeUse(InsnArg arg) {, +		Iterator<InsnArg> it = useList.iterator();, +		while (it.hasNext()) {, +			InsnArg use = it.next();, +			if (use == arg) {, +				it.remove();, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		if (parent == null) {, +			return null;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypedVar.java, +import java.util.Iterator;, +	public List<InsnArg> getUseList() {, +		return useList;, +	}, +, +	public void removeUse(InsnArg arg) {, +		Iterator<InsnArg> it = useList.iterator();, +		while (it.hasNext()) {, +			InsnArg use = it.next();, +			if (use == arg) {, +				it.remove();, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import jadx.core.dex.regions.Region;, +	private Region region;, +	public Region getRegion() {, +	public void setRegion(Region region) {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		if (parent == null) {, +			return null;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypedVar.java, +import java.util.Iterator;, +	public List<InsnArg> getUseList() {, +		return useList;, +	}, +, +	public void removeUse(InsnArg arg) {, +		Iterator<InsnArg> it = useList.iterator();, +		while (it.hasNext()) {, +			InsnArg use = it.next();, +			if (use == arg) {, +				it.remove();, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import jadx.core.dex.regions.Region;, +	private Region region;, +	public Region getRegion() {, +	public void setRegion(Region region) {, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/SynchronizedRegion.java, +import java.util.LinkedList;, +	private final InsnNode enterInsn;, +	private final List<InsnNode> exitInsns = new LinkedList<InsnNode>();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			loop.getEnd().add(AFlag.SKIP);, +			loop.getEnd().remove(AFlag.SKIP);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			loop.getEnd().add(AFlag.SKIP);, +			loop.getEnd().remove(AFlag.SKIP);, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopConditionInvoke.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopConditionInvoke extends InternalJadxTest {, +, +	public static class TestCls {, +		private static final char STOP_CHAR = 0;, +		private int pos;, +, +		private boolean test(char lastChar) {, +			int startPos = pos;, +			char ch;, +			while ((ch = next()) != STOP_CHAR) {, +				if (ch == lastChar) {, +					return true;, +				}, +			}, +			pos = startPos;, +			return false;, +		}, +, +		private char next() {, +			return 0;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsOne("do {"));, +		assertThat(code, containsOne("if (ch == '\\u0000') {"));, +		assertThat(code, containsOne("this.pos = startPos;"));, +		assertThat(code, containsOne("return false;"));, +		assertThat(code, containsOne("} while (ch != lastChar);"));, +		assertThat(code, containsOne("return true;"));, +	}, +}]
[+++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java, +import static org.junit.jupiter.api.Assertions.assertSame;, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java, +import static org.junit.jupiter.api.Assertions.assertSame;, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/tests/TestsTest.java, +package jadx.tests;, +, +import static org.junit.jupiter.api.Assertions.assertTrue;, +import static org.junit.jupiter.api.Assertions.fail;, +, +import java.io.File;, +import java.io.IOException;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.Paths;, +import java.util.List;, +, +import org.junit.jupiter.api.Test;, +, +public class TestsTest {, +, +	@Test, +	public void noJUnit4Asssertions() throws IOException {, +		noJUnit4Asssertions(".");, +		noJUnit4Asssertions("../jadx-cli");, +		noJUnit4Asssertions("../jadx-gui");, +	}, +, +	private void noJUnit4Asssertions(String path) throws IOException {, +		Path dir = Paths.get(path, "src/test/java");, +		assertTrue(Files.exists(dir));, +		Files.walk(dir), +				.filter(p -> p.getFileName().toString().endsWith(".java"), +						&& !p.getFileName().toString().endsWith(TestsTest.class.getSimpleName() + ".java")), +				.forEach(p -> {, +					try {, +, +						List<String> lines = Files.readAllLines(p);, +, +						for (String line : lines) {, +							if (line.contains("org.junit.Assert")) {, +								String className = dir.relativize(p).toString();, +								className = className.substring(0, className.length() - ".java".length());, +								className = className.replace(File.separatorChar, '.');, +, +								fail("Test class " + className + " should be migrated to JUnit 5");, +							}, +						}, +					} catch (IOException e) {, +						throw new RuntimeException(e);, +					}, +				});, +	}, +}, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java, +import static org.junit.jupiter.api.Assertions.assertSame;, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/tests/TestsTest.java, +package jadx.tests;, +, +import static org.junit.jupiter.api.Assertions.assertTrue;, +import static org.junit.jupiter.api.Assertions.fail;, +, +import java.io.File;, +import java.io.IOException;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.Paths;]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +			JadxDecompiler jadx = new JadxDecompiler(jadxArgs);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +			JadxDecompiler jadx = new JadxDecompiler(jadxArgs);, +++ /dev/null, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +			JadxDecompiler jadx = new JadxDecompiler(jadxArgs);, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +package jadx.api;, +, +import jadx.core.Jadx;, +import jadx.core.ProcessClass;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.dex.visitors.SaveCode;, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.exceptions.DecodeException;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import jadx.core.utils.files.InputFile;, +, +import java.io.File;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +/**, + * Jadx API usage example:, + * <pre><code>, + *  Decompiler jadx = new Decompiler();, + *  jadx.loadFile(new File("classes.dex"));, + *  jadx.setOutputDir(new File("out"));, + *  jadx.save();, + * </code></pre>, + * <p/>, + * Instead of 'save()' you can get list of decompiled classes:, + * <pre><code>, + *  for(JavaClass cls : jadx.getClasses()) {, + *      System.out.println(cls.getCode());, + *  }, + * </code></pre>, + */, +public final class JadxDecompiler {, +	private static final Logger LOG = LoggerFactory.getLogger(JadxDecompiler.class);, +, +	private final IJadxArgs args;, +	private final List<InputFile> inputFiles = new ArrayList<InputFile>();, +, +	private File outDir;, +, +	private RootNode root;, +	private List<IDexTreeVisitor> passes;, +	private List<JavaClass> classes;, +, +	public JadxDecompiler() {, +		this.args = new DefaultJadxArgs();, +		init();, +	}, +, +	public JadxDecompiler(IJadxArgs jadxArgs) {, +		this.args = jadxArgs;, +		init();, +	}, +, +	public void setOutputDir(File outDir) {, +		this.outDir = outDir;, +		init();, +	}, +, +	void init() {, +		reset();, +		if (outDir == null) {, +			outDir = new File("jadx-output");, +		}, +		this.passes = Jadx.getPassesList(args, outDir);, +	}, +, +	void reset() {, +		ClassInfo.clearCache();, +		ErrorsCounter.reset();, +		classes = null;, +	}, +, +	public void loadFile(File file) throws JadxException {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, +	private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, +	private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +		if (codeVar.getType() != null && !typeInfo.getType().equals(codeVar.getType())) {, +			throw new JadxRuntimeException("Unmached types for SSA and Code variables: " + this + " and " + codeVar);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, +	private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +		if (codeVar.getType() != null && !typeInfo.getType().equals(codeVar.getType())) {, +			throw new JadxRuntimeException("Unmached types for SSA and Code variables: " + this + " and " + codeVar);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java, +import java.util.LinkedHashSet;, +import java.util.List;, +import java.util.stream.Collectors;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			Set<SSAVar> vars = new LinkedHashSet<>();, +			vars.add(ssaVar);, +			setCodeVarType(codeVar, vars);, +		} else {, +			ssaVar.setCodeVar(codeVar);, +		}, +	}, +, +	private static void setCodeVarType(CodeVar codeVar, Set<SSAVar> vars) {, +		if (vars.size() > 1) {, +			List<ArgType> imTypes = vars.stream(), +					.filter(var -> var.contains(AFlag.METHOD_ARGUMENT)), +					.map(var -> var.getTypeInfo().getType()), +					.distinct(), +					.collect(Collectors.toList());, +			int imCount = imTypes.size();, +			if (imCount == 1) {, +				codeVar.setType(imTypes.get(0));, +			} else if (imCount > 1) {, +				throw new JadxRuntimeException("Several immutable types in one variable: " + imTypes + ", vars: " + vars);, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, +	private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +		if (codeVar.getType() != null && !typeInfo.getType().equals(codeVar.getType())) {, +			throw new JadxRuntimeException("Unmached types for SSA and Code variables: " + this + " and " + codeVar);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/InitCodeVariables.java, +import java.util.LinkedHashSet;, +import java.util.List;, +import java.util.stream.Collectors;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +			Set<SSAVar> vars = new LinkedHashSet<>();, +			vars.add(ssaVar);, +			setCodeVarType(codeVar, vars);, +		} else {, +			ssaVar.setCodeVar(codeVar);, +		}, +	}, +, +	private static void setCodeVarType(CodeVar codeVar, Set<SSAVar> vars) {, +		if (vars.size() > 1) {, +			List<ArgType> imTypes = vars.stream(), +					.filter(var -> var.contains(AFlag.METHOD_ARGUMENT)), +					.map(var -> var.getTypeInfo().getType()), +					.distinct(), +					.collect(Collectors.toList());, +			int imCount = imTypes.size();, +			if (imCount == 1) {, +				codeVar.setType(imTypes.get(0));, +			} else if (imCount > 1) {, +				throw new JadxRuntimeException("Several immutable types in one variable: " + imTypes + ", vars: " + vars);, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +			ArgType codeVarType = ssaVar.getCodeVar().getType();, +			if (codeVarType != null) {, +				return applyImmutableType(ssaVar, codeVarType);, +			RegisterArg assignArg = ssaVar.getAssign();, +			if (assignArg.isTypeImmutable()) {, +				return applyImmutableType(ssaVar, assignArg.getInitType());, +			}, +			return calculateFromBounds(ssaVar);, +		} catch (Exception e) {, +			LOG.error("Failed to calculate best type for var: {}", ssaVar);, +			return false;, +		}, +	}, +, +	private boolean applyImmutableType(SSAVar ssaVar, ArgType initType) {, +		return result == TypeUpdateResult.CHANGED;, +		if (!bestTypeOpt.isPresent()) {, +			if (Consts.DEBUG) {, +				LOG.warn("Failed to select best type from bounds, count={} : ", bounds.size());, +				for (ITypeBound bound : bounds) {, +					LOG.warn("  {}", bound);, +				}, +			}, +			return false;, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	private List<ExceptionHandler> exceptionHandlers = Collections.emptyList();, +		if (exceptionHandlers.isEmpty()) {, +		return Collections.unmodifiableList(exceptionHandlers);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	private List<ExceptionHandler> exceptionHandlers = Collections.emptyList();, +		if (exceptionHandlers.isEmpty()) {, +		return Collections.unmodifiableList(exceptionHandlers);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.dex.instructions.IfNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.utils.RegionUtils;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +	private CodeWriter dot;, +	private CodeWriter conn;, +, +		dot = new CodeWriter();, +		conn = new CodeWriter();, +		dot.startLine("digraph \"CFG for");, +		dot.add(escape(mth.getParentClass().getFullName() + "." + mth.getMethodInfo().getShortId()));, +		dot.add("\" {");, +			processMethodRegion(mth);, +				processBlock(mth, block);, +		dot.startLine("MethodNode[shape=record,label=\"{");, +		dot.add(escape(mth.getAccessFlags().makeString()));, +		dot.add(escape(mth.getReturnType() + " ", +				+ mth.getParentClass().getFullName() + "." + mth.getName(), +				+ "(" + Utils.listToString(mth.getArguments(true)) + ") "));, +, +		if (attrs.length() != 0) {, +			dot.add(" | ").add(attrs);, +		}, +		dot.add("}\"];");, +		dot.startLine("MethodNode -> ").add(makeName(mth.getEnterBlock())).add(';');, +		dot.add(conn.toString());, +	private void processMethodRegion(MethodNode mth) {, +		processRegion(mth, mth.getRegion());, +		for (ExceptionHandler h : mth.getExceptionHandlers()) {, +			if (h.getHandlerRegion() != null) {, +				processRegion(mth, h.getHandlerRegion());, +			}, +		}, +		Set<BlockNode> regionsBlocks = new HashSet<BlockNode>(mth.getBasicBlocks().size());, +		RegionUtils.getAllRegionBlocks(mth.getRegion(), regionsBlocks);, +		for (ExceptionHandler handler : mth.getExceptionHandlers()) {, +			IContainer handlerRegion = handler.getHandlerRegion();, +			if (handlerRegion != null) {, +				RegionUtils.getAllRegionBlocks(handlerRegion, regionsBlocks);, +			}, +		}, +		for (BlockNode block : mth.getBasicBlocks()) {, +			if (!regionsBlocks.contains(block)) {, +				processBlock(mth, block, true);, +			}, +		}, +	}, +, +	private void processRegion(MethodNode mth, IContainer region) {, +			dot.startLine("label = \"").add(r);, +			String attrs = attributesString(r);, +			if (attrs.length() != 0) {, +				dot.add(" | ").add(attrs);, +			}, +			dot.add("\";");, +				processRegion(mth, c);, +			processBlock(mth, (BlockNode) region);, +	private void processBlock(MethodNode mth, BlockNode block) {, +		processBlock(mth, block, false);, +	}, +, +	private void processBlock(MethodNode mth, BlockNode block, boolean error) {, +		dot.startLine(makeName(block));, +		dot.add(" [shape=record,");, +		if (error) {, +			dot.add("color=red,");, +		dot.add("label=\"{");, +		dot.add(block.getId()).add("\\:\\ ");, +		dot.add(InsnUtils.formatOffset(block.getStartOffset()));, +		if (attrs.length() != 0) {, +			dot.add('|').add(attrs);, +		}, +		String insns = insertInsns(mth, block);, +		if (insns.length() != 0) {, +			dot.add('|').add(insns);, +		}, +		dot.add("}\"];");, +, +		BlockNode falsePath = null;, +		List<InsnNode> list = block.getInstructions();, +		if (!list.isEmpty() && list.get(0).getType() == InsnType.IF) {, +			falsePath = ((IfNode) list.get(0)).getElseBlock();, +		}, +		for (BlockNode next : block.getSuccessors()) {, +			conn.startLine(makeName(block)).add(" -> ").add(makeName(next));, +			if (next == falsePath) {, +				conn.add("[style=dotted]");, +			}, +			conn.add(';');]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, +			IfCondition i = simplifyCmpOp(c);, +			if (i != null) {, +				return i;, +			}, +	private static IfCondition simplifyCmpOp(Compare c) {, +			return null;, +		if (!c.getB().isLiteral()) {, +			return null;, +		long lit = ((LiteralArg) c.getB()).getLiteral();, +		if (lit != 0 && lit != 1) {, +			return null;, +		}, +, +		switch (wrapInsn.getType()) {, +			case CMP_L:, +			case CMP_G:, +				if (lit == 0) {, +				break;, +, +			case ARITH:, +				ArithOp arithOp = ((ArithNode) wrapInsn).getOp();, +				if (arithOp == ArithOp.OR || arithOp == ArithOp.AND) {, +					IfOp ifOp = c.getInsn().getOp();, +					boolean isTrue = ifOp == IfOp.NE && lit == 0, +							|| ifOp == IfOp.EQ && lit == 1;, +, +					IfOp op = isTrue ? IfOp.NE : IfOp.EQ;, +					Mode mode = isTrue && arithOp == ArithOp.OR ||, +							!isTrue && arithOp == ArithOp.AND ? Mode.OR : Mode.AND;, +, +					IfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.FALSE);, +					IfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.FALSE);, +					return new IfCondition(mode,, +							Arrays.asList(new IfCondition(new Compare(if1)),, +									new IfCondition(new Compare(if2))));, +				}, +			break;, +, +		default:, +			break;, +		}, +, +, +		return null;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, +			IfCondition i = simplifyCmpOp(c);, +			if (i != null) {, +				return i;, +			}, +	private static IfCondition simplifyCmpOp(Compare c) {, +			return null;, +		if (!c.getB().isLiteral()) {, +			return null;, +		long lit = ((LiteralArg) c.getB()).getLiteral();, +		if (lit != 0 && lit != 1) {, +			return null;, +		}, +, +		switch (wrapInsn.getType()) {, +			case CMP_L:, +			case CMP_G:, +				if (lit == 0) {, +				break;, +, +			case ARITH:, +				ArithOp arithOp = ((ArithNode) wrapInsn).getOp();, +				if (arithOp == ArithOp.OR || arithOp == ArithOp.AND) {, +					IfOp ifOp = c.getInsn().getOp();, +					boolean isTrue = ifOp == IfOp.NE && lit == 0, +							|| ifOp == IfOp.EQ && lit == 1;, +, +					IfOp op = isTrue ? IfOp.NE : IfOp.EQ;, +					Mode mode = isTrue && arithOp == ArithOp.OR ||, +							!isTrue && arithOp == ArithOp.AND ? Mode.OR : Mode.AND;, +, +					IfNode if1 = new IfNode(op, -1, wrapInsn.getArg(0), LiteralArg.FALSE);, +					IfNode if2 = new IfNode(op, -1, wrapInsn.getArg(1), LiteralArg.FALSE);, +					return new IfCondition(mode,, +							Arrays.asList(new IfCondition(new Compare(if1)),, +									new IfCondition(new Compare(if2))));, +				}, +			break;, +, +		default:, +			break;, +		}, +, +, +		return null;, +	}, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestBitwiseAnd.java, +package jadx.tests.integration.conditions;, +, +import org.junit.jupiter.api.Test;]
[+++ b/jadx-core/src/main/java/jadx/core/utils/ImmutableList.java, +import java.util.NoSuchElementException;, +	@SuppressWarnings({"unchecked", "SuspiciousArrayCast"}), +	public ImmutableList(Collection<E> col) {, +		this((E[]) Objects.requireNonNull(col).toArray());, +	}, +, +	public ImmutableList(E[] arr) {, +		this.arr = Objects.requireNonNull(arr);, +				try {, +				} catch (IndexOutOfBoundsException e) {, +					throw new NoSuchElementException(e.getMessage());, +				}, +		return Arrays.copyOf(arr, arr.length);, +		return (T[]) Arrays.copyOf(arr, arr.length);, +++ b/jadx-core/src/main/java/jadx/core/utils/ImmutableList.java, +import java.util.NoSuchElementException;, +	@SuppressWarnings({"unchecked", "SuspiciousArrayCast"}), +	public ImmutableList(Collection<E> col) {, +		this((E[]) Objects.requireNonNull(col).toArray());, +	}, +, +	public ImmutableList(E[] arr) {, +		this.arr = Objects.requireNonNull(arr);, +				try {, +				} catch (IndexOutOfBoundsException e) {, +					throw new NoSuchElementException(e.getMessage());, +				}, +		return Arrays.copyOf(arr, arr.length);, +		return (T[]) Arrays.copyOf(arr, arr.length);, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +		return new ImmutableList<>(list);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (domFrontier == null) {, +			throw new JadxRuntimeException("Dominance frontier not set for block: " + this);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (domFrontier == null) {, +			throw new JadxRuntimeException("Dominance frontier not set for block: " + this);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +import java.util.stream.Collectors;, +		int removeApplied = 0;, +			if (applyRemove(mth, removeInfo)) {, +				removeApplied++;, +				removeInfo.setApplied(true);, +			}, +		}, +		if (removeApplied == 0) {, +		if (removeApplied != removes.size()) {, +			throw new JadxRuntimeException("Some finally instructions failed to remove: ", +					+ removes.stream().filter(n -> !n.isApplied()).map(BlocksRemoveInfo::toString).collect(Collectors.joining(",")), +			);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +		if (domFrontier == null) {, +			throw new JadxRuntimeException("Dominance frontier not set for block: " + this);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +import java.util.stream.Collectors;, +		int removeApplied = 0;, +			if (applyRemove(mth, removeInfo)) {, +				removeApplied++;, +				removeInfo.setApplied(true);, +			}, +		}, +		if (removeApplied == 0) {, +		if (removeApplied != removes.size()) {, +			throw new JadxRuntimeException("Some finally instructions failed to remove: ", +					+ removes.stream().filter(n -> !n.isApplied()).map(BlocksRemoveInfo::toString).collect(Collectors.joining(",")), +			);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/helpers/BlocksRemoveInfo.java, +	private boolean applied;, +, +	public boolean isApplied() {, +		return applied;, +	}, +, +	public void setApplied(boolean applied) {, +		this.applied = applied;, +	}, +, +		return "BRI{start: " + start, +				+ ", processed: " + processed, +				+ ", split: " + startSplitIndex + "-" + endSplitIndex, +				+ "}";]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private String nsURI="ERROR";, +	private String currentTag="ERROR";, +	private boolean wasOneLiner=false;, +		nsURI=strings[beginURI];, +		nsURI=strings[endURI];, +		int elementBegLineNumber = cInt32(bytes, count);, +		//System.out.println("ELEMENT BEG Line: " + elementBegLineNumber + " of " + strings[startNSName]);, +		int startNSName = cInt32(bytes, count); // actually is elementName..., +		if(!wasOneLiner && !"ERROR".equals(currentTag) && !currentTag.equals(strings[startNSName])) {, +			writer.println(">");, +		}, +		wasOneLiner=false;, +		currentTag=strings[startNSName];, +		if("manifest".equals(strings[startNSName])) writer.print(" xmlns:\""+nsURI+"\"");, +/*(, +			//writer.print(strings[attributeName] + "=\"");, +			} else if(attrValDataType==0x1) writer.print(strings[attributeName] + "=\"0x" + Integer.toHexString(attrValData) + "\"");, +			if((i+1)<attributeCount) writer.print(" ");, +		//writer.println(">");, +		//System.out.println("ELEMENT BEG Line: " + elementBegLineNumber + " of " + strings[startNSName]);, +		if(currentTag==strings[elementName]) {, +			writer.println("/>");, +			wasOneLiner=true;, +		} else {, +		}, +		//System.out.println("ELEMENT END Line: " + endLineNumber + " of " + strings[elementName]);, +		// TODO: Mind linenumbers for real original file ;)]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		// don't add 'abstract' and 'public' to methods in interface, +			ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		// don't add 'abstract' and 'public' to methods in interface, +			ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (tryCatchBlock.getFinalRegion() != null) {, +			makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		// don't add 'abstract' and 'public' to methods in interface, +			ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (tryCatchBlock.getFinalRegion() != null) {, +			makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +					if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		// don't add 'abstract' and 'public' to methods in interface, +			ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (tryCatchBlock.getFinalRegion() != null) {, +			makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +					if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java, +	private BlockNode handlerBlock;, +	public BlockNode getHandlerBlock() {, +		return handlerBlock;, +	public void setHandlerBlock(BlockNode handlerBlock) {, +		this.handlerBlock = handlerBlock;, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		// don't add 'abstract' and 'public' to methods in interface, +			ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (tryCatchBlock.getFinalRegion() != null) {, +			makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +					if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java, +	private BlockNode handlerBlock;, +	public BlockNode getHandlerBlock() {, +		return handlerBlock;, +	public void setHandlerBlock(BlockNode handlerBlock) {, +		this.handlerBlock = handlerBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +	private IContainer finalRegion;, +	public Iterable<ExceptionHandler> getHandlers() {, +		return handlers;, +	}, +, +	public int getHandlersCount() {, +		return handlers.size();, +	}, +, +	public boolean containsAllHandlers(TryCatchBlock tb) {, +		return handlers.containsAll(tb.handlers);, +		if (finalRegion != null) {, +							tb.setFinalRegionFromInsns(mth, ((IBlock) finalRegion).getInstructions());, +	public IContainer getFinalRegion() {, +		return finalRegion;, +	public void setFinalRegion(IContainer finalRegion) {, +		this.finalRegion = finalRegion;, +	public void setFinalRegionFromInsns(MethodNode mth, List<InsnNode> insns) {, +		setFinalRegion(new InsnContainer(finalBlockInsns));, +		this.handlers.addAll(tryBlock.handlers);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		// don't add 'abstract' and 'public' to methods in interface, +			ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +		if (tryCatchBlock.getFinalRegion() != null) {, +			makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +					if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/ExceptionHandler.java, +	private BlockNode handlerBlock;, +	public BlockNode getHandlerBlock() {, +		return handlerBlock;, +	public void setHandlerBlock(BlockNode handlerBlock) {, +		this.handlerBlock = handlerBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +	private IContainer finalRegion;, +	public Iterable<ExceptionHandler> getHandlers() {, +		return handlers;, +	}, +, +	public int getHandlersCount() {, +		return handlers.size();, +	}, +, +	public boolean containsAllHandlers(TryCatchBlock tb) {, +		return handlers.containsAll(tb.handlers);, +		if (finalRegion != null) {, +							tb.setFinalRegionFromInsns(mth, ((IBlock) finalRegion).getInstructions());, +	public IContainer getFinalRegion() {, +		return finalRegion;, +	public void setFinalRegion(IContainer finalRegion) {, +		this.finalRegion = finalRegion;, +	public void setFinalRegionFromInsns(MethodNode mth, List<InsnNode> insns) {, +		setFinalRegion(new InsnContainer(finalBlockInsns));]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/resources/i18n/Messages_es_ES.properties, +#menu.heapUsageBar=, +#message.indexingClassesSkipped=, +, +#heapUsage.text=, +, +#preferences.respectBytecodeAccessModifiers=, +#preferences.useImports=, +#preferences.excludedPackages=, +#preferences.excludedPackages.tooltip=, +#preferences.excludedPackages.button=, +#preferences.excludedPackages.editDialog=, +#popup.find_usage=, +#popup.exclude=, +#certificate.serialPubKeyModulusSize=, +, +#apkSignature.signer=, +#apkSignature.verificationSuccess=, +#apkSignature.verificationFailed=, +#apkSignature.signatureSuccess=, +#apkSignature.signatureFailed=, +#apkSignature.errors=, +#apkSignature.warnings=, +#apkSignature.exception=, +#apkSignature.unprotectedEntry=, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/resources/i18n/Messages_es_ES.properties, +#menu.heapUsageBar=, +#message.indexingClassesSkipped=, +, +#heapUsage.text=, +, +#preferences.respectBytecodeAccessModifiers=, +#preferences.useImports=, +#preferences.excludedPackages=, +#preferences.excludedPackages.tooltip=, +#preferences.excludedPackages.button=, +#preferences.excludedPackages.editDialog=, +#popup.find_usage=, +#popup.exclude=, +#certificate.serialPubKeyModulusSize=, +, +#apkSignature.signer=, +#apkSignature.verificationSuccess=, +#apkSignature.verificationFailed=, +#apkSignature.signatureSuccess=, +#apkSignature.signatureFailed=, +#apkSignature.errors=, +#apkSignature.warnings=, +#apkSignature.exception=, +#apkSignature.unprotectedEntry=, +++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +#popup.exclude=, +, +#apkSignature.verificationFailed=, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +		JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/resources/i18n/Messages_es_ES.properties, +#menu.heapUsageBar=, +#message.indexingClassesSkipped=, +, +#heapUsage.text=, +, +#preferences.respectBytecodeAccessModifiers=, +#preferences.useImports=, +#preferences.excludedPackages=, +#preferences.excludedPackages.tooltip=, +#preferences.excludedPackages.button=, +#preferences.excludedPackages.editDialog=, +#popup.find_usage=, +#popup.exclude=, +#certificate.serialPubKeyModulusSize=, +, +#apkSignature.signer=, +#apkSignature.verificationSuccess=, +#apkSignature.verificationFailed=, +#apkSignature.signatureSuccess=]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +					if (i != 0 && modInsn.contains(AFlag.ARITH_ONEARG)) {, +, +						InsnNode mergedNode = simplifyOneArgConsecutive(, +								list.get(i - 1), list.get(i), (ArithNode) modInsn);, +, +						if (mergedNode != null) {, +							list.remove(i - 1);, +							modInsn = mergedNode;, +							i--;, +						}, +					}, +	private static InsnNode simplifyOneArgConsecutive(InsnNode insn1, InsnNode insn2, ArithNode modInsn) {, +		if (insn1.getType() == InsnType.IGET, +				&& insn2.getType() == InsnType.IPUT, +				&& insn1.getResult().getSVar().getUseCount() == 2, +				&& insn2.getArg(1).equals(insn1.getResult())) {, +, +			FieldInfo field = (FieldInfo) ((IndexInsnNode) insn2).getIndex();, +			FieldArg fArg = new FieldArg(field, new InsnWrapArg(insn1));, +			return new ArithNode(modInsn.getOp(), fArg, modInsn.getArg(1));, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +					if (i != 0 && modInsn.contains(AFlag.ARITH_ONEARG)) {, +, +						InsnNode mergedNode = simplifyOneArgConsecutive(, +								list.get(i - 1), list.get(i), (ArithNode) modInsn);, +, +						if (mergedNode != null) {, +							list.remove(i - 1);, +							modInsn = mergedNode;, +							i--;, +						}, +					}, +	private static InsnNode simplifyOneArgConsecutive(InsnNode insn1, InsnNode insn2, ArithNode modInsn) {, +		if (insn1.getType() == InsnType.IGET, +				&& insn2.getType() == InsnType.IPUT, +				&& insn1.getResult().getSVar().getUseCount() == 2, +				&& insn2.getArg(1).equals(insn1.getResult())) {, +, +			FieldInfo field = (FieldInfo) ((IndexInsnNode) insn2).getIndex();, +			FieldArg fArg = new FieldArg(field, new InsnWrapArg(insn1));, +			return new ArithNode(modInsn.getOp(), fArg, modInsn.getArg(1));, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestFieldIncrement2.java]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("if (");, +				code.add(arg(insn.getArg(0))).add(' ');, +				code.add(ifInsn.getOp().getSymbol()).add(' ');, +				code.add(arg(insn.getArg(1)));, +				code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("if (");, +				code.add(arg(insn.getArg(0))).add(' ');, +				code.add(ifInsn.getOp().getSymbol()).add(' ');, +				code.add(arg(insn.getArg(1)));, +				code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +		this(InsnType.GOTO, target, 0);, +	protected GotoNode(InsnType type, int target, int argsCount) {, +		super(type, argsCount);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("if (");, +				code.add(arg(insn.getArg(0))).add(' ');, +				code.add(ifInsn.getOp().getSymbol()).add(' ');, +				code.add(arg(insn.getArg(1)));, +				code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +		this(InsnType.GOTO, target, 0);, +	protected GotoNode(InsnType type, int target, int argsCount) {, +		super(type, argsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	private static final ArgType ARG_TYPE = ArgType.unknown(, +			PrimitiveType.INT, PrimitiveType.OBJECT, PrimitiveType.ARRAY,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.CHAR);, +, +		this(op, insn.getTarget(),, +				InsnArg.reg(insn, 0, ARG_TYPE),, +				insn.getRegisterCount() == 1 ? InsnArg.lit(0, ARG_TYPE) : InsnArg.reg(insn, 1, ARG_TYPE));, +, +	public IfNode(IfOp op, int targetOffset, InsnArg arg1, InsnArg arg2) {, +		super(InsnType.IF, targetOffset, 2);, +		this.op = op;, +		addArg(arg1);, +		addArg(arg2);, +	public void changeCondition(IfOp op, InsnArg arg1, InsnArg arg2) {, +				+ getArg(0) + " " + op.getSymbol() + " " + getArg(1), +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("if (");, +				code.add(arg(insn.getArg(0))).add(' ');, +				code.add(ifInsn.getOp().getSymbol()).add(' ');, +				code.add(arg(insn.getArg(1)));, +				code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +		this(InsnType.GOTO, target, 0);, +	protected GotoNode(InsnType type, int target, int argsCount) {, +		super(type, argsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	private static final ArgType ARG_TYPE = ArgType.unknown(, +			PrimitiveType.INT, PrimitiveType.OBJECT, PrimitiveType.ARRAY,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.CHAR);, +, +		this(op, insn.getTarget(),, +				InsnArg.reg(insn, 0, ARG_TYPE),, +				insn.getRegisterCount() == 1 ? InsnArg.lit(0, ARG_TYPE) : InsnArg.reg(insn, 1, ARG_TYPE));, +, +	public IfNode(IfOp op, int targetOffset, InsnArg arg1, InsnArg arg2) {, +		super(InsnType.IF, targetOffset, 2);, +		this.op = op;, +		addArg(arg1);, +		addArg(arg2);, +	public void changeCondition(IfOp op, InsnArg arg1, InsnArg arg2) {, +				+ getArg(0) + " " + op.getSymbol() + " " + getArg(1), +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +		throw new UnsupportedOperationException("ArgType.getObject()");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("if (");, +				code.add(arg(insn.getArg(0))).add(' ');, +				code.add(ifInsn.getOp().getSymbol()).add(' ');, +				code.add(arg(insn.getArg(1)));, +				code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +		this(InsnType.GOTO, target, 0);, +	protected GotoNode(InsnType type, int target, int argsCount) {, +		super(type, argsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +	private static final ArgType ARG_TYPE = ArgType.unknown(, +			PrimitiveType.INT, PrimitiveType.OBJECT, PrimitiveType.ARRAY,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.CHAR);, +, +		this(op, insn.getTarget(),, +				InsnArg.reg(insn, 0, ARG_TYPE),, +				insn.getRegisterCount() == 1 ? InsnArg.lit(0, ARG_TYPE) : InsnArg.reg(insn, 1, ARG_TYPE));, +, +	public IfNode(IfOp op, int targetOffset, InsnArg arg1, InsnArg arg2) {, +		super(InsnType.IF, targetOffset, 2);, +		this.op = op;, +		addArg(arg1);, +		addArg(arg2);, +	public void changeCondition(IfOp op, InsnArg arg1, InsnArg arg2) {, +				+ getArg(0) + " " + op.getSymbol() + " " + getArg(1), +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +		throw new UnsupportedOperationException("ArgType.getObject()");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +	public static final LiteralArg TRUE = new LiteralArg(1, ArgType.BOOLEAN);]
[+++ b/.travis.yml, +    - TERM=dumb ./gradlew clean build dist, +    - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/.travis.yml, +    - TERM=dumb ./gradlew clean build dist, +    - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', +    gradleVersion = '2.0', +++ b/.travis.yml, +    - TERM=dumb ./gradlew clean build dist, +    - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', +    gradleVersion = '2.0', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +    - TERM=dumb ./gradlew clean build dist, +    - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', +    gradleVersion = '2.0', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.0-bin.zip, +++ b/.travis.yml, +    - TERM=dumb ./gradlew clean build dist, +    - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', +    gradleVersion = '2.0', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.0-bin.zip, +++ b/jadx-gui/build.gradle, +++ b/.travis.yml, +    - TERM=dumb ./gradlew clean build dist, +    - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', +    gradleVersion = '2.0', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.0-bin.zip, +++ b/jadx-gui/build.gradle, +++ b/version, +0.5.2]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +, +	private AType() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +, +	private AType() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +			case Opcodes.CONST_STRING_JUMBO:, +				InsnNode constStrInsn = new ConstStringNode(dex.getString(insn.getIndex()));, +				constStrInsn.setResult(InsnArg.reg(insn, 0, ArgType.STRING));, +				return constStrInsn;, +			case Opcodes.CONST_CLASS:, +				InsnNode constClsInsn = new ConstClassNode(dex.getType(insn.getIndex()));, +				constClsInsn.setResult(InsnArg.reg(insn, 0, ArgType.CLASS));, +				return constClsInsn;, +			case Opcodes.INSTANCE_OF:, +				InsnNode instInsn = new IndexInsnNode(InsnType.INSTANCE_OF, dex.getType(insn.getIndex()), 1);, +				instInsn.setResult(InsnArg.reg(insn, 0, ArgType.BOOLEAN));, +				instInsn.addArg(InsnArg.reg(insn, 1, ArgType.UNKNOWN_OBJECT));, +				return instInsn;, +			case Opcodes.CHECK_CAST:, +				InsnNode checkCastInsn = new IndexInsnNode(InsnType.CHECK_CAST, castType, 1);, +				checkCastInsn.setResult(InsnArg.reg(insn, 0, castType));, +				checkCastInsn.addArg(InsnArg.reg(insn, 0, ArgType.UNKNOWN_OBJECT));, +				return checkCastInsn;, +			case Opcodes.IGET_OBJECT:, +				FieldInfo igetFld = FieldInfo.fromDex(dex, insn.getIndex());, +				InsnNode igetInsn = new IndexInsnNode(InsnType.IGET, igetFld, 1);, +				igetInsn.setResult(InsnArg.reg(insn, 0, igetFld.getType()));, +				igetInsn.addArg(InsnArg.reg(insn, 1, igetFld.getDeclClass().getType()));, +				return igetInsn;, +			case Opcodes.IPUT_OBJECT:, +				FieldInfo iputFld = FieldInfo.fromDex(dex, insn.getIndex());, +				InsnNode iputInsn = new IndexInsnNode(InsnType.IPUT, iputFld, 2);, +				iputInsn.addArg(InsnArg.reg(insn, 0, iputFld.getType()));, +				iputInsn.addArg(InsnArg.reg(insn, 1, iputFld.getDeclClass().getType()));, +				return iputInsn;, +			case Opcodes.SGET_OBJECT:, +				FieldInfo sgetFld = FieldInfo.fromDex(dex, insn.getIndex());, +				InsnNode sgetInsn = new IndexInsnNode(InsnType.SGET, sgetFld, 0);, +				sgetInsn.setResult(InsnArg.reg(insn, 0, sgetFld.getType()));, +				return sgetInsn;, +			case Opcodes.SPUT_OBJECT:, +				FieldInfo sputFld = FieldInfo.fromDex(dex, insn.getIndex());, +				InsnNode sputInsn = new IndexInsnNode(InsnType.SPUT, sputFld, 1);, +				sputInsn.addArg(InsnArg.reg(insn, 0, sputFld.getType()));, +				return sputInsn;, +			case Opcodes.ARRAY_LENGTH:, +				InsnNode arrLenInsn = new InsnNode(InsnType.ARRAY_LENGTH, 1);, +				arrLenInsn.setResult(InsnArg.reg(insn, 0, ArgType.INT));, +				arrLenInsn.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +				return arrLenInsn;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		} catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +, +	private AType() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +			case Opcodes.CONST_STRING_JUMBO:, +				InsnNode constStrInsn = new ConstStringNode(dex.getString(insn.getIndex()));, +				constStrInsn.setResult(InsnArg.reg(insn, 0, ArgType.STRING));, +				return constStrInsn;, +			case Opcodes.CONST_CLASS:, +				InsnNode constClsInsn = new ConstClassNode(dex.getType(insn.getIndex()));, +				constClsInsn.setResult(InsnArg.reg(insn, 0, ArgType.CLASS));, +				return constClsInsn;, +			case Opcodes.INSTANCE_OF:, +				InsnNode instInsn = new IndexInsnNode(InsnType.INSTANCE_OF, dex.getType(insn.getIndex()), 1);, +				instInsn.setResult(InsnArg.reg(insn, 0, ArgType.BOOLEAN));, +				instInsn.addArg(InsnArg.reg(insn, 1, ArgType.UNKNOWN_OBJECT));, +				return instInsn;, +			case Opcodes.CHECK_CAST:, +				InsnNode checkCastInsn = new IndexInsnNode(InsnType.CHECK_CAST, castType, 1);]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private static final int CURRENT_SETTINGS_VERSION = 5;, +	public void setUseImports(boolean useImports) {, +		this.useImports = useImports;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 4) {, +			setUseImports(true);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private static final int CURRENT_SETTINGS_VERSION = 5;, +	public void setUseImports(boolean useImports) {, +		this.useImports = useImports;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 4) {, +			setUseImports(true);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +		JCheckBox useImports = new JCheckBox();, +		useImports.setSelected(settings.isUseImports());, +		useImports.addItemListener(e -> {, +			settings.setUseImports(e.getStateChange() == ItemEvent.SELECTED);, +			needReload();, +		});, +, +		other.addRow(NLS.str("preferences.useImports"), useImports);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	private static final int CURRENT_SETTINGS_VERSION = 5;, +	public void setUseImports(boolean useImports) {, +		this.useImports = useImports;, +	}, +, +			fromVersion++;, +		}, +		if (fromVersion == 4) {, +			setUseImports(true);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +		JCheckBox useImports = new JCheckBox();, +		useImports.setSelected(settings.isUseImports());, +		useImports.addItemListener(e -> {, +			settings.setUseImports(e.getStateChange() == ItemEvent.SELECTED);, +			needReload();, +		});, +, +		other.addRow(NLS.str("preferences.useImports"), useImports);, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +preferences.useImports=Use import statements]
[+++ b/NOTICE, +RSyntaxTextArea library (https://github.com/bobbylight/RSyntaxTextArea), +licensed under modified BSD license:, +Concurrent Trees (https://code.google.com/p/concurrent-trees/), +licenced under Apache License 2.0:, +, +*******************************************************************************, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +    http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +*******************************************************************************, +, +, + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed, +     under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +++ b/NOTICE, +RSyntaxTextArea library (https://github.com/bobbylight/RSyntaxTextArea), +licensed under modified BSD license:, +Concurrent Trees (https://code.google.com/p/concurrent-trees/), +licenced under Apache License 2.0:, +, +*******************************************************************************, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +    http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +*******************************************************************************, +, +, + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed, +     under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/FieldInitAttr.java, +	public static final FieldInitAttr NULL_VALUE = constValue(null);, +++ b/NOTICE, +RSyntaxTextArea library (https://github.com/bobbylight/RSyntaxTextArea), +licensed under modified BSD license:, +Concurrent Trees (https://code.google.com/p/concurrent-trees/), +licenced under Apache License 2.0:, +, +*******************************************************************************, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +    http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +*******************************************************************************, +, +, + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed, +     under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/FieldInitAttr.java, +	public static final FieldInitAttr NULL_VALUE = constValue(null);, +++ b/jadx-gui/build.gradle, +    compile 'com.fifesoft:rsyntaxtextarea:2.5.7', +++ b/NOTICE, +RSyntaxTextArea library (https://github.com/bobbylight/RSyntaxTextArea), +licensed under modified BSD license:, +Concurrent Trees (https://code.google.com/p/concurrent-trees/), +licenced under Apache License 2.0:, +, +*******************************************************************************, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +    http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +*******************************************************************************, +, +, + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed, +     under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/FieldInitAttr.java, +	public static final FieldInitAttr NULL_VALUE = constValue(null);]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	CODE(".dex", ".jar", ".class"),, +	XML(".xml"),, +	ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	CODE(".dex", ".jar", ".class"),, +	XML(".xml"),, +	ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +					return loadContent(jadxRef, rf, is, size);, +			InputStream inputStream, long size) throws IOException {, +		if (size > LOAD_SIZE_LIMIT) {, +			return ResContainer.singleFile(rf.getName(),, +					new CodeWriter().add("File too big, size: " + String.format("%.2f KB", size / 1024.)));, +		}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	CODE(".dex", ".jar", ".class"),, +	XML(".xml"),, +	ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +					return loadContent(jadxRef, rf, is, size);, +			InputStream inputStream, long size) throws IOException {, +		if (size > LOAD_SIZE_LIMIT) {, +			return ResContainer.singleFile(rf.getName(),, +					new CodeWriter().add("File too big, size: " + String.format("%.2f KB", size / 1024.)));, +		}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +				InputFile.addFilesFrom(f, inputFiles);, +	private static void addFilesFromDirectory(File dir, List<InputFile> inputFiles) {, +			} else {, +				try {, +					InputFile.addFilesFrom(file, inputFiles);, +				} catch (Exception e) {, +					LOG.warn("Skip file: {}, load error: {}", file, e.getMessage());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	CODE(".dex", ".jar", ".class"),, +	XML(".xml"),, +	ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +					return loadContent(jadxRef, rf, is, size);, +			InputStream inputStream, long size) throws IOException {, +		if (size > LOAD_SIZE_LIMIT) {, +			return ResContainer.singleFile(rf.getName(),, +					new CodeWriter().add("File too big, size: " + String.format("%.2f KB", size / 1024.)));, +		}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +				InputFile.addFilesFrom(f, inputFiles);, +	private static void addFilesFromDirectory(File dir, List<InputFile> inputFiles) {, +			} else {, +				try {, +					InputFile.addFilesFrom(file, inputFiles);, +				} catch (Exception e) {, +					LOG.warn("Skip file: {}, load error: {}", file, e.getMessage());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import jadx.core.utils.files.DexFile;, +	private final DexFile file;, +	public DexNode(RootNode root, DexFile input) {, +		this.dexBuf = input.getDexBuf();, +	public DexFile getDexFile() {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +	CODE(".dex", ".jar", ".class"),, +	XML(".xml"),, +	ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +					return loadContent(jadxRef, rf, is, size);, +			InputStream inputStream, long size) throws IOException {, +		if (size > LOAD_SIZE_LIMIT) {, +			return ResContainer.singleFile(rf.getName(),, +					new CodeWriter().add("File too big, size: " + String.format("%.2f KB", size / 1024.)));, +		}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +				InputFile.addFilesFrom(f, inputFiles);, +	private static void addFilesFromDirectory(File dir, List<InputFile> inputFiles) {, +			} else {, +				try {, +					InputFile.addFilesFrom(file, inputFiles);, +				} catch (Exception e) {, +					LOG.warn("Skip file: {}, load error: {}", file, e.getMessage());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import jadx.core.utils.files.DexFile;, +	private final DexFile file;, +	public DexNode(RootNode root, DexFile input) {, +		this.dexBuf = input.getDexBuf();, +	public DexFile getDexFile() {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +import jadx.core.utils.files.DexFile;, +	public void load(List<InputFile> inputFiles) throws DecodeException {, +		dexNodes = new ArrayList<DexNode>();]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +		SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, +	protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +		SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, +	protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java, +			addTask(cls::decompile);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +		SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, +	protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java, +			addTask(cls::decompile);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +		SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, +	protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java, +			addTask(cls::decompile);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +	private static final ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +		SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, +	protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java, +			addTask(cls::decompile);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +	private static final ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +		if (excludedPackages.length() == 0) {, +		}, +				if (cls.getFullName().startsWith(exclude)) {, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +		SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, +	protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java, +			addTask(cls::decompile);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +	private static final ExclusionStrategy EXCLUDE_FIELDS = new ExclusionStrategy() {, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/ApkSignature.java, +import com.android.apksig.ApkVerifier;, +import org.apache.commons.lang3.exception.ExceptionUtils;, +import org.apache.commons.text.StringEscapeUtils;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import jadx.gui.JadxWrapper;, +import jadx.gui.utils.CertificateManager;, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +, +public class ApkSignature extends JNode {, +	private static final long serialVersionUID = -9121321926113143407L;, +, +	private static final Logger LOG = LoggerFactory.getLogger(ApkSignature.class);, +, +	private String content;, +		if (wrapper.getResources().stream().noneMatch(r -> "AndroidManifest.xml".equals(r.getName()))) {, +		if (content != null) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.jetbrains.annotations.Nullable;, +	private static final int CURRENT_SETTINGS_VERSION = 7;, +	private static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();, +	public void setFont(@Nullable Font font) {, +		if (font == null) {, +			this.fontStr = "";, +			return;, +		}, +			fromVersion++;, +		}, +		if (fromVersion == 6) {, +			if (getFont().getFontName().equals("Hack Regular")) {, +				setFont(null);, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.jetbrains.annotations.Nullable;, +	private static final int CURRENT_SETTINGS_VERSION = 7;, +	private static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();, +	public void setFont(@Nullable Font font) {, +		if (font == null) {, +			this.fontStr = "";, +			return;, +		}, +			fromVersion++;, +		}, +		if (fromVersion == 6) {, +			if (getFont().getFontName().equals("Hack Regular")) {, +				setFont(null);, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +			mainWindow.loadSettings();, +				mainWindow.loadSettings();, +				needReload();, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.jetbrains.annotations.Nullable;, +	private static final int CURRENT_SETTINGS_VERSION = 7;, +	private static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();, +	public void setFont(@Nullable Font font) {, +		if (font == null) {, +			this.fontStr = "";, +			return;, +		}, +			fromVersion++;, +		}, +		if (fromVersion == 6) {, +			if (getFont().getFontName().equals("Hack Regular")) {, +				setFont(null);, +			}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +			mainWindow.loadSettings();, +				mainWindow.loadSettings();, +				needReload();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java]
[+++ b/.travis.yml, +install: true, +jdk:, +  - openjdk8, +  - oraclejdk8, +  - openjdk11, +, +script: ./gradlew clean build, +, +jobs:, +    - stage: deploy-unstable, +      jdk: openjdk8, +      if: branch = master AND env(BINTRAY_USER) IS present, +    - stage: deploy-release, +      jdk: openjdk8, +      if: branch = release AND env(GH_TOKEN) IS present, +++ b/.travis.yml, +install: true, +jdk:, +  - openjdk8, +  - oraclejdk8, +  - openjdk11, +, +script: ./gradlew clean build, +, +jobs:, +    - stage: deploy-unstable, +      jdk: openjdk8, +      if: branch = master AND env(BINTRAY_USER) IS present, +    - stage: deploy-release, +      jdk: openjdk8, +      if: branch = release AND env(GH_TOKEN) IS present, +++ b/scripts/bintray-upload.sh, +set -e, +TARGET=${BINTRAY_USER}/jadx/${BINTRAY_PACKAGE}/v${JADX_VERSION}, +CREDENTIALS="--user=${BINTRAY_USER} --key=${BINTRAY_KEY}", +++ b/.travis.yml, +install: true, +jdk:, +  - openjdk8, +  - oraclejdk8, +  - openjdk11, +, +script: ./gradlew clean build, +, +jobs:, +    - stage: deploy-unstable, +      jdk: openjdk8, +      if: branch = master AND env(BINTRAY_USER) IS present, +    - stage: deploy-release, +      jdk: openjdk8, +      if: branch = release AND env(GH_TOKEN) IS present, +++ b/scripts/bintray-upload.sh, +set -e, +TARGET=${BINTRAY_USER}/jadx/${BINTRAY_PACKAGE}/v${JADX_VERSION}, +CREDENTIALS="--user=${BINTRAY_USER} --key=${BINTRAY_KEY}", +++ b/scripts/travis-master.sh, +set -e, +++ b/.travis.yml, +install: true, +jdk:, +  - openjdk8, +  - oraclejdk8, +  - openjdk11, +, +script: ./gradlew clean build, +, +jobs:, +    - stage: deploy-unstable, +      jdk: openjdk8, +      if: branch = master AND env(BINTRAY_USER) IS present, +    - stage: deploy-release, +      jdk: openjdk8, +      if: branch = release AND env(GH_TOKEN) IS present, +++ b/scripts/bintray-upload.sh, +set -e, +TARGET=${BINTRAY_USER}/jadx/${BINTRAY_PACKAGE}/v${JADX_VERSION}, +CREDENTIALS="--user=${BINTRAY_USER} --key=${BINTRAY_KEY}", +++ b/scripts/travis-master.sh, +set -e, +++ b/scripts/travis-release.sh, +set -e]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.ClassData;, +import com.android.dex.FieldId;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.ClassData;, +import com.android.dex.FieldId;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.ClassData;, +import com.android.dex.FieldId;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +	@Deprecated, +	@Deprecated, +	@Nullable, +	FieldNode deepResolveField(@NotNull ClassNode cls, FieldInfo fieldInfo) {, +		FieldNode field = cls.searchFieldByName(fieldInfo.getName());, +		if (field != null) {, +			return field;, +		}, +		FieldNode found;, +		ArgType superClass = cls.getSuperClass();, +		if (superClass != null) {, +			ClassNode superNode = resolveClass(superClass);, +			if (superNode != null) {, +				found = deepResolveField(superNode, fieldInfo);, +				if (found != null) {, +					return found;, +				}, +			}, +		}, +		for (ArgType iFaceType : cls.getInterfaces()) {, +			ClassNode iFaceNode = resolveClass(iFaceType);, +			if (iFaceNode != null) {, +				found = deepResolveField(iFaceNode, fieldInfo);, +				if (found != null) {, +					return found;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static final ArgType NARROW_NUMBERS = unknown(, +			PrimitiveType.INT, PrimitiveType.FLOAT,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, +			if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, +			} else {, +				return 1;, +			}, +		}, +		if (!isTypeKnown()) {, +			return 0;, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static final ArgType NARROW_NUMBERS = unknown(, +			PrimitiveType.INT, PrimitiveType.FLOAT,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, +			if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, +			} else {, +				return 1;, +			}, +		}, +		if (!isTypeKnown()) {, +			return 0;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +		if (value != 0) {, +			if (type.isObject()) {, +				throw new JadxRuntimeException("Wrong literal type: " + type + " for value: " + value);, +			} else if (!type.isTypeKnown(), +					&& !type.contains(PrimitiveType.LONG), +					&& !type.contains(PrimitiveType.DOUBLE)) {, +				ArgType m = ArgType.merge(type, ArgType.NARROW_NUMBERS);, +				if (m != null) {, +					type = m;, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +			if (Math.abs(lit) > 100) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +	public static final ArgType NARROW_NUMBERS = unknown(, +			PrimitiveType.INT, PrimitiveType.FLOAT,, +			PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, +			if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, +			} else {, +				return 1;, +			}, +		}, +		if (!isTypeKnown()) {, +			return 0;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +		if (value != 0) {, +			if (type.isObject()) {, +				throw new JadxRuntimeException("Wrong literal type: " + type + " for value: " + value);, +			} else if (!type.isTypeKnown(), +					&& !type.contains(PrimitiveType.LONG), +					&& !type.contains(PrimitiveType.DOUBLE)) {, +				ArgType m = ArgType.merge(type, ArgType.NARROW_NUMBERS);, +				if (m != null) {, +					type = m;, +				}, +			}, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +			if (arg.isLiteral()) {, +				ArgType resType = insn.getResult().getType();, +				// make sure arg has correct type, +				if (!arg.getType().isTypeKnown()) {, +					arg.merge(resType);, +				}, +					LiteralArg litArg = InsnArg.lit(literal, ArgType.UNKNOWN);, +						fixTypes(mth, useInsn, litArg);, +	private static void fixTypes(MethodNode mth, InsnNode insn, LiteralArg litArg) {, +			case IF: {, +					InsnArg arg0 = insn.getArg(0);, +					InsnArg arg1 = insn.getArg(1);, +					if (arg0 == litArg) {, +						arg0.merge(arg1);, +					} else {, +						arg1.merge(arg0);, +					}, +			}, +			case CMP_G:, +			case CMP_L: {, +				InsnArg arg0 = insn.getArg(0);, +				InsnArg arg1 = insn.getArg(1);, +				if (arg0 == litArg) {, +					arg0.merge(arg1);, +				} else {]
[+++ b/jadx-gui/build.gradle, +    compile 'com.googlecode.concurrent-trees:concurrent-trees:2.4.0', +++ b/jadx-gui/build.gradle, +    compile 'com.googlecode.concurrent-trees:concurrent-trees:2.4.0', +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +package jadx.gui.treemodel;, +, +import jadx.api.JavaClass;, +import jadx.gui.utils.Utils;, +, +import javax.swing.Icon;, +import javax.swing.ImageIcon;, +, +public class CodeNode extends JClass {, +, +	private static final ImageIcon ICON = Utils.openIcon("file_obj");, +, +	private final String line;, +	private final int lineNum;, +, +	public CodeNode(JavaClass javaClass, int lineNum, String line) {, +		super(javaClass, (JClass) makeFrom(javaClass.getDeclaringClass()));, +		this.line = line;, +		this.lineNum = lineNum;, +	}, +, +	@Override, +	public Icon getIcon() {, +		return ICON;, +	}, +, +	@Override, +	public int getLine() {, +		return lineNum;, +	}, +, +	@Override, +	public String makeString() {, +		return getCls().getFullName() + ":" + lineNum + "   " + line;, +	}, +, +	@Override, +	public String makeLongString() {, +		return makeString();, +	}, +, +	@Override, +	public String toString() {, +		return makeString();, +	}, +}, +++ b/jadx-gui/build.gradle, +    compile 'com.googlecode.concurrent-trees:concurrent-trees:2.4.0', +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +package jadx.gui.treemodel;, +, +import jadx.api.JavaClass;, +import jadx.gui.utils.Utils;, +, +import javax.swing.Icon;, +import javax.swing.ImageIcon;, +, +public class CodeNode extends JClass {, +, +	private static final ImageIcon ICON = Utils.openIcon("file_obj");, +, +	private final String line;, +	private final int lineNum;, +, +	public CodeNode(JavaClass javaClass, int lineNum, String line) {, +		super(javaClass, (JClass) makeFrom(javaClass.getDeclaringClass()));, +		this.line = line;, +		this.lineNum = lineNum;, +	}, +, +	@Override, +	public Icon getIcon() {, +		return ICON;, +	}, +, +	@Override, +	public int getLine() {, +		return lineNum;, +	}, +, +	@Override, +	public String makeString() {, +		return getCls().getFullName() + ":" + lineNum + "   " + line;, +	}, +, +	@Override, +	public String makeLongString() {, +		return makeString();, +	}, +, +	@Override, +	public String toString() {, +		return makeString();, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, +			if(f.getFieldInfo().isRenamed()) {, +				code.startLine("/* renamed from: ").add(f.getName()).add(" */");, +			}, +		if (classInfo.isRenamed()) {, +			code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, +		if(mth.getMethodInfo().isRenamed()) {, +			code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, +		}]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +		code.add(callMth.getAlias());, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {, +				&& dex.root().getClsp().isImplements(from.getObject(), to.getObject())) {, +	public static boolean isInstanceOf(DexNode dex, ArgType type, ArgType of) {, +		return dex.root().getClsp().isImplements(type.getObject(), of.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {, +				&& dex.root().getClsp().isImplements(from.getObject(), to.getObject())) {, +	public static boolean isInstanceOf(DexNode dex, ArgType type, ArgType of) {, +		return dex.root().getClsp().isImplements(type.getObject(), of.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +				ArgType m = ArgType.merge(null, type, ArgType.NARROW_NUMBERS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {, +				&& dex.root().getClsp().isImplements(from.getObject(), to.getObject())) {, +	public static boolean isInstanceOf(DexNode dex, ArgType type, ArgType of) {, +		return dex.root().getClsp().isImplements(type.getObject(), of.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +				ArgType m = ArgType.merge(null, type, ArgType.NARROW_NUMBERS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/Typed.java, +import jadx.core.dex.nodes.DexNode;, +, +	public boolean merge(DexNode dex, ArgType newType) {, +		ArgType m = ArgType.merge(dex, type, newType);, +	public boolean merge(DexNode dex, InsnArg arg) {, +		return merge(dex, arg.getType());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +import java.util.*;, +	public static final int RESULTS_PER_PAGE = 100;, +	protected JLabel resultsInfoLabel;, +	protected synchronized void performSearch() {, +		resultsTable.updateTable();, +		updateProgressLabel();, +	}, +, +		resultsModel.addTableModelListener((e) -> updateProgressLabel());, +		resultsTable.setDefaultRenderer(Object.class, renderer);, +, +		JPanel paginationPanel = new JPanel();, +		paginationPanel.setAlignmentX( Component.LEFT_ALIGNMENT );, +		paginationPanel.setLayout(new BoxLayout(paginationPanel, BoxLayout.X_AXIS));, +		resultsInfoLabel = new JLabel("");, +, +		JButton nextPageButton = new JButton("->");, +		nextPageButton.setToolTipText(NLS.str("search_dialog.next_page"));, +		nextPageButton.addActionListener((e) -> {, +			resultsModel.nextPage();, +			resultsTable.updateTable();, +			resultsTable.scrollRectToVisible(new Rectangle(0,0,1,1));, +		});, +, +		JButton prevPageButton = new JButton("<-");, +		prevPageButton.setToolTipText(NLS.str("search_dialog.prev_page"));, +		prevPageButton.addActionListener((e) -> {, +			resultsModel.prevPage();, +			resultsTable.updateTable();, +			resultsTable.scrollRectToVisible(new Rectangle(0,0,1,1));, +		});, +, +		paginationPanel.add(prevPageButton);, +		paginationPanel.add(nextPageButton);, +		paginationPanel.add(resultsInfoLabel);, +, +		resultsPanel.add(paginationPanel);, +	protected void updateProgressLabel() {, +		String statusText = String.format(NLS.str("search_dialog.info_label"), resultsModel.getDisplayedResultsStart(),, +				resultsModel.getDisplayedResultsEnd(), resultsModel.getResultCount());, +		resultsInfoLabel.setText(statusText);, +	}, +, +		private final transient ArrayList<JNode> rows = new ArrayList<>();, +		private transient int start = 0;, +		protected void addAll(Collection<? extends JNode> nodes) {, +			rows.ensureCapacity(rows.size() + nodes.size());, +			start = 0;, +		public int getResultCount() {, +			return rows.size();, +		}, +, +		public int getDisplayedResultsStart() {, +			if (rows.size() == 0), +				return 0;, +			return start + 1;, +		}, +, +		public int getDisplayedResultsEnd() {, +			return Math.min(rows.size(), start + RESULTS_PER_PAGE);, +		}, +, +		public void nextPage() {, +			if (start + RESULTS_PER_PAGE < rows.size()) {, +				renderer.clear();, +				start += RESULTS_PER_PAGE;, +				fireTableStructureChanged();, +			}, +		}, +, +		public void prevPage() {, +			if (start - RESULTS_PER_PAGE >= 0) {, +				renderer.clear();, +				start -= RESULTS_PER_PAGE;, +				fireTableStructureChanged();, +			}, +		}, +, +			return rows.size() - start;, +			return rows.get(rowIndex + start);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +import java.util.*;, +	public static final int RESULTS_PER_PAGE = 100;, +	protected JLabel resultsInfoLabel;, +	protected synchronized void performSearch() {, +		resultsTable.updateTable();, +		updateProgressLabel();, +	}, +, +		resultsModel.addTableModelListener((e) -> updateProgressLabel());, +		resultsTable.setDefaultRenderer(Object.class, renderer);, +, +		JPanel paginationPanel = new JPanel();, +		paginationPanel.setAlignmentX( Component.LEFT_ALIGNMENT );, +		paginationPanel.setLayout(new BoxLayout(paginationPanel, BoxLayout.X_AXIS));, +		resultsInfoLabel = new JLabel("");, +, +		JButton nextPageButton = new JButton("->");, +		nextPageButton.setToolTipText(NLS.str("search_dialog.next_page"));]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// *** Additional instructions ***, +, +	// replacement for removed instructions, +	NOP,, +, +	TERNARY,, +, +	// strings concatenation, +	STR_CONCAT,, +	// just generate one argument, +	ONE_ARG,, +	// TODO: now multidimensional arrays created using Array.newInstance function, +	NEW_MULTIDIM_ARRAY, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// *** Additional instructions ***, +, +	// replacement for removed instructions, +	NOP,, +, +	TERNARY,, +, +	// strings concatenation, +	STR_CONCAT,, +	// just generate one argument, +	ONE_ARG,, +	// TODO: now multidimensional arrays created using Array.newInstance function, +	NEW_MULTIDIM_ARRAY, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +		InsnNode insn = new InsnNode(InsnType.ONE_ARG, 1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// *** Additional instructions ***, +, +	// replacement for removed instructions, +	NOP,, +, +	TERNARY,, +, +	// strings concatenation, +	STR_CONCAT,, +	// just generate one argument, +	ONE_ARG,, +	// TODO: now multidimensional arrays created using Array.newInstance function, +	NEW_MULTIDIM_ARRAY, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +		InsnNode insn = new InsnNode(InsnType.ONE_ARG, 1);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.NotNull;, +	public SSAVar makeNewSVar(int regNum, int[] versions, @NotNull RegisterArg arg) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// *** Additional instructions ***, +, +	// replacement for removed instructions, +	NOP,, +, +	TERNARY,, +, +	// strings concatenation, +	STR_CONCAT,, +	// just generate one argument, +	ONE_ARG,, +	// TODO: now multidimensional arrays created using Array.newInstance function, +	NEW_MULTIDIM_ARRAY, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +		InsnNode insn = new InsnNode(InsnType.ONE_ARG, 1);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.NotNull;, +	public SSAVar makeNewSVar(int regNum, int[] versions, @NotNull RegisterArg arg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +				// insert additional blocks for possible 'break' insertion, +				// insert additional blocks for possible 'continue' insertion, +				BlockNode loopEnd = loop.getEnd();, +				if (loopEnd.getPredecessors().size() > 1) {, +					boolean change = false;, +					List<BlockNode> nodes = new ArrayList<BlockNode>(loopEnd.getPredecessors());, +					for (BlockNode pred : nodes) {, +						if (!pred.contains(AFlag.SYNTHETIC)) {, +							insertBlockBetween(mth, pred, loopEnd);, +							change = true;, +						}, +					}, +					if (change) {, +						return true;, +					}, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// *** Additional instructions ***, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.io.PrintWriter;, +	PrintWriter writer;, +	public BinaryXMLParser(String xmlfilepath, String xmloutfilepath) {, +		//System.out.println(xmlfilepath);, +		try {, +			writer = new PrintWriter(xmloutfilepath,"UTF-8");, +		} catch(FileNotFoundException fnfe) { die("FNFE"); }, +		catch(UnsupportedEncodingException uee) { die("UEE"); }, +		if(null==writer) die("null==writer");, +		writer.close();, +			//System.out.println("index i["+i+"] string: " + strings[i]);, +		//System.out.println("RHeader Size: " + rhsize);, +			//System.out.println("i["+i+"] ID: "+ids[i]);, +			//System.out.println("Hex: 0x0" + Integer.toHexString(ids[i]) + " should be: " + strings[i]);, +		//System.out.println("Prefix: " + strings[beginPrefix]);, +		//System.out.println("URI: " + strings[beginURI]);, +		//System.out.println("Prefix: " + strings[endPrefix]);, +		//System.out.println("URI: " + strings[endURI]);, +		for(int i=0; i<numtabs; i++) writer.print("\t");, +		writer.print("<" + strings[startNSName]);, +		if(attributeCount>0) writer.print(" ");, +			if(attributeNS != -1) writer.print(nsPrefix+":");, +			if(attrValDataType==0x3) writer.print(strings[attributeName] + "=\"" + strings[attrValData]+"\"");, +			else if(attrValDataType==0x10) writer.print(strings[attributeName] + "=\"" + attrValData+"\"");, +				if(attrValData==0) writer.print(strings[attributeName] + "=\"false\"");, +				else if(attrValData==1 || attrValData==-1) writer.print(strings[attributeName] + "=\"true\"");, +				else writer.print(strings[attributeName] + "=\"UNKNOWN\"");, +			else writer.print(strings[attributeName] + " = UNKNOWN DATA TYPE: " + attrValDataType);, +			writer.print(" ");, +		writer.println(">");, +		for(int i=0; i<numtabs; i++) writer.print("\t");, +		writer.print("</");, +		if(elementNS != -1) writer.print(strings[elementNS]+":");, +		writer.println(strings[elementName]+">");]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		arg.setName(name);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		arg.setName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public RegisterArg duplicate() {, +		RegisterArg dup = new RegisterArg(getRegNum(), getType());, +		dup.setSVar(sVar);, +		return dup;, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		arg.setName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public RegisterArg duplicate() {, +		RegisterArg dup = new RegisterArg(getRegNum(), getType());, +		dup.setSVar(sVar);, +		return dup;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import java.util.ArrayList;, +					InsnNode newInstInsn = removeAssignChain(instArgAssignInsn, remover, InsnType.NEW_INSTANCE);, +					if (newInstInsn != null) {, +						RegisterArg instArg = newInstInsn.getResult();, +						RegisterArg resultArg = co.getResult();, +						if (!resultArg.equals(instArg)) {, +							// replace all usages of 'instArg' with result of this constructor instruction, +							for (RegisterArg useArg : new ArrayList<RegisterArg>(instArg.getSVar().getUseList())) {, +								RegisterArg dup = resultArg.duplicate();, +								InsnNode parentInsn = useArg.getParentInsn();, +								parentInsn.replaceArg(useArg, dup);, +								dup.setParentInsn(parentInsn);, +								resultArg.getSVar().use(dup);, +							}, +						}, +					}, +		if (callMth == null, +				|| !callMth.getAccessFlags().isSynthetic(), +				|| !allArgsNull(co)) {, +			return null;, +		}, +		if (classNode == null) {, +			return null;, +		}, +		if (defCtr == null) {, +			return null;, +		}, +	private static InsnNode removeAssignChain(InsnNode insn, InstructionRemover remover, InsnType insnType) {, +			return null;, +			return insn;, +			return removeAssignChain(arg.getAssignInsn(), remover, insnType);, +		return null;]
[+++ b/build.gradle, +    compileJava {, +        options.encoding = "UTF-8", +    }, +, +++ b/build.gradle, +    compileJava {, +        options.encoding = "UTF-8", +    }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.Iterator;, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +			ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());, +, +				default:, +					return true;, +, +++ b/build.gradle, +    compileJava {, +        options.encoding = "UTF-8", +    }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.Iterator;, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +			ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());, +, +				default:, +					return true;, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +			Arrays.asList(, +					"while", +			), +, +	private NameMapper() {, +	}, +++ b/build.gradle, +    compileJava {, +        options.encoding = "UTF-8", +    }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.Iterator;, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +			ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());, +, +				default:, +					return true;, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +			Arrays.asList(, +					"while", +			), +, +	private NameMapper() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.info.MethodInfo;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.utils.files.DexFile;, +++ b/build.gradle, +    compileJava {, +        options.encoding = "UTF-8", +    }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.Iterator;, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +			ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());, +, +				default:, +					return true;, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			case MOVE:, +				InsnArg firstArg = insn.getArg(0);, +				if (firstArg.isLiteral()) {, +					InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, +					constInsn.setResult(insn.getResult());, +					constInsn.addArg(firstArg);, +					constInsn.copyAttributesFrom(insn);, +					return constInsn;, +				}, +				break;, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +, +	private DepthTraversal() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +, +	private DepthTraversal() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +import jadx.core.Jadx;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.IgnoreEdgeAttr;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.trycatch.CatchAttr;, +import jadx.core.dex.trycatch.ExceptionHandler;, +import jadx.core.dex.trycatch.SplitterBlockAttr;, +import jadx.core.dex.trycatch.TryCatchBlock;, +import jadx.core.dex.visitors.AbstractVisitor;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.dex.visitors.blocksmaker.helpers.BlocksPair;, +import jadx.core.dex.visitors.blocksmaker.helpers.BlocksRemoveInfo;, +import jadx.core.dex.visitors.ssa.LiveVarAnalysis;, +import jadx.core.utils.BlockUtils;, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +		try {, +		} catch (Exception e) {, +			LOG.warn("Undo finally extract visitor, mth: {}", mth, e);, +			try {, +				// reload method without applying this visitor, +				// TODO: make more common and less hacky, +				mth.unload();, +				mth.load();, +				List<IDexTreeVisitor> passes = Jadx.getPassesList(mth.root().getArgs());, +				for (IDexTreeVisitor visitor : passes) {, +					if (visitor instanceof BlockFinallyExtract) {, +						break;, +					}, +					DepthTraversal.visit(visitor, mth);, +				}, +			} catch (Exception ee) {, +				LOG.error("Undo finally extract failed, mth: {}", mth, e);, +			}, +		}, +		if (removeInfo.getOuts().isEmpty()) {, +			ErrorsCounter.methodError(mth, "Failed to extract finally block: empty outs");, +			return false;, +		}, +		// safe checks finished, altering blocks tree, +		// all error must throw exception to undo changes, +		Set<BlocksPair> outs = removeInfo.getOuts();, +		if (outs.isEmpty()) {, +			throw new JadxRuntimeException("Failed to extract finally block: all outs is deleted");, +		}, +		BlocksPair out = outs.iterator().next();, +				throw new JadxRuntimeException("Block not found by " + pred + ", in " + removeInfo);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected String sfield(FieldInfo field) {, +		ClassInfo declClass = field.getDeclClass();, +		if (thisClass.startsWith(declClass.getFullName())) {, +		// Android specific resources class handler, +		ClassInfo parentClass = declClass.getParentClass();, +		if (parentClass != null && parentClass.getShortName().equals("R")) {, +			return  useClass(parentClass) + "." + declClass.getShortName() + "." + field.getName();, +		}, +		return useClass(declClass) + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	protected String sfield(FieldInfo field) {, +		ClassInfo declClass = field.getDeclClass();, +		if (thisClass.startsWith(declClass.getFullName())) {, +		// Android specific resources class handler, +		ClassInfo parentClass = declClass.getParentClass();, +		if (parentClass != null && parentClass.getShortName().equals("R")) {, +			return  useClass(parentClass) + "." + declClass.getShortName() + "." + field.getName();, +		}, +		return useClass(declClass) + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +//		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +//		bxp.parse();, +//		System.exit(4);]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +	private static final int MAX_SIZE_DIFF = 25;, +			LOG.error("Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",, +					compressedSize, uncompressedSize, entry.getName());]
[+++ b/.gitignore, +jadx-output/, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			throw new DecodeException(this, "Load method exception: " + e.getMessage(), e);, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			throw new DecodeException(this, "Load method exception: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		JavaToDex j2d = new JavaToDex();, +				throw new JadxException("Empty dx output");, +		} finally {, +			if (j2d.isError()) {, +				LOG.warn("dx message: {}", j2d.getDxErrors());, +			}, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +		throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			throw new DecodeException(this, "Load method exception: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		JavaToDex j2d = new JavaToDex();, +				throw new JadxException("Empty dx output");, +		} finally {, +			if (j2d.isError()) {, +				LOG.warn("dx message: {}", j2d.getDxErrors());, +			}, +++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import jadx.core.utils.exceptions.JadxException;, +	private static final Logger LOG = LoggerFactory.getLogger(JavaToDex.class);, +		public DxArgs(DxContext context, String dexFile, String[] input) {, +			super(context);, +			warnings = true;, +			minSdkVersion = 28;, +		try (ByteArrayOutputStream out = new ByteArrayOutputStream();, +		     ByteArrayOutputStream errOut = new ByteArrayOutputStream()) {, +			DxArgs args = new DxArgs(context, "-", new String[]{javaFile});, +			dxErrors = errOut.toString(CHARSET_NAME);]
[+++ b/NOTICE, +Copyright 2013, Skylot, +, +Jadx-gui components, +===================, +, +RSyntaxTextArea library licensed under modified BSD liense:, +, +*******************************************************************************, +Copyright (c) 2012, Robert Futrell, +All rights reserved., +, +Redistribution and use in source and binary forms, with or without, +modification, are permitted provided that the following conditions are met:, +    * Redistributions of source code must retain the above copyright, +      notice, this list of conditions and the following disclaimer., +    * Redistributions in binary form must reproduce the above copyright, +      notice, this list of conditions and the following disclaimer in the, +      documentation and/or other materials provided with the distribution., +    * Neither the name of the author nor the names of its contributors may, +      be used to endorse or promote products derived from this software, +      without specific prior written permission., +, +THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND, +ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED, +WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE, +DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY, +DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES, +(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;, +LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND, +ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT, +(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS, +SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE., +*******************************************************************************, +, +, +Icons copied from several places:, +++ b/NOTICE, +Copyright 2013, Skylot, +, +Jadx-gui components, +===================, +, +RSyntaxTextArea library licensed under modified BSD liense:, +, +*******************************************************************************, +Copyright (c) 2012, Robert Futrell, +All rights reserved., +, +Redistribution and use in source and binary forms, with or without, +modification, are permitted provided that the following conditions are met:, +    * Redistributions of source code must retain the above copyright, +      notice, this list of conditions and the following disclaimer., +    * Redistributions in binary form must reproduce the above copyright, +      notice, this list of conditions and the following disclaimer in the, +      documentation and/or other materials provided with the distribution., +    * Neither the name of the author nor the names of its contributors may, +      be used to endorse or promote products derived from this software, +      without specific prior written permission., +, +THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND, +ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED, +WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE, +DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY, +DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES, +(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;, +LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND, +ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT, +(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS, +SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE., +*******************************************************************************, +, +, +Icons copied from several places:, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import javax.swing.text.BadLocationException;, +	private void treeClickAction() {, +		Object obj = tree.getLastSelectedPathComponent();, +		if (obj instanceof JNode) {, +			JNode node = (JNode) obj;, +			if (node.getJParent() != null) {, +				textArea.setText(node.getJParent().getCode());, +				scrollToLine(node.getLine());, +	}, +, +	private void scrollToLine(int line) {, +		if (line < 2) {, +			return;, +		}, +		try {, +			textArea.setCaretPosition(textArea.getLineStartOffset(line - 1));, +		} catch (BadLocationException e) {, +			LOG.error("Can't scroll to " + line, e);, +		}, +			public void valueChanged(TreeSelectionEvent event) {, +				treeClickAction();, +++ b/NOTICE, +Copyright 2013, Skylot, +, +Jadx-gui components]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (fileName.endsWith(".apk") || fileName.endsWith(".zip")) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && callMthNode.isArgsOverload()) {, +			int argsCount = insn.getArgsCount();, +			List<ArgType> originalType = callMth.getArgumentsTypes();, +			int origPos = 0;, +, +			code.add('(');, +			for (int i = k; i < argsCount; i++) {, +				InsnArg arg = insn.getArg(i);, +				ArgType origType = originalType.get(origPos);, +				if (!arg.getType().equals(origType)) {, +					code.add('(').add(useType(origType)).add(')').add(arg(arg));, +				} else {, +					code.add(arg(arg));, +				}, +				if (i < argsCount - 1) {, +					code.add(", ");, +				}, +				origPos++;, +			}, +			code.add(')');, +		} else {, +	}, +		int argsCount = insn.getArgsCount();, +		if (k < argsCount) {, +			code.add(arg(insn, k));, +			for (int i = k + 1; i < argsCount; i++) {, +				code.add(arg(insn, i));, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && callMthNode.isArgsOverload()) {, +			int argsCount = insn.getArgsCount();, +			List<ArgType> originalType = callMth.getArgumentsTypes();, +			int origPos = 0;, +, +			code.add('(');, +			for (int i = k; i < argsCount; i++) {, +				InsnArg arg = insn.getArg(i);, +				ArgType origType = originalType.get(origPos);, +				if (!arg.getType().equals(origType)) {, +					code.add('(').add(useType(origType)).add(')').add(arg(arg));, +				} else {, +					code.add(arg(arg));, +				}, +				if (i < argsCount - 1) {, +					code.add(", ");, +				}, +				origPos++;, +			}, +			code.add(')');, +		} else {, +	}, +		int argsCount = insn.getArgsCount();, +		if (k < argsCount) {, +			code.add(arg(insn, k));, +			for (int i = k + 1; i < argsCount; i++) {, +				code.add(arg(insn, i));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	/**, +	 * Return true if exists method with same name and arguments count, +	 */, +	public boolean isArgsOverload() {, +		int argsCount = mthInfo.getArgumentsTypes().size();, +		if (argsCount == 0) {, +			return false;, +		}, +, +		String name = getName();, +		List<MethodNode> methods = parentClass.getMethods();, +		for (MethodNode method : methods) {, +			if (this != method, +					&& method.getName().equals(name), +					&& method.mthInfo.getArgumentsTypes().size() == argsCount), +				return true;, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && callMthNode.isArgsOverload()) {, +			int argsCount = insn.getArgsCount();, +			List<ArgType> originalType = callMth.getArgumentsTypes();, +			int origPos = 0;, +, +			code.add('(');, +			for (int i = k; i < argsCount; i++) {, +				InsnArg arg = insn.getArg(i);, +				ArgType origType = originalType.get(origPos);, +				if (!arg.getType().equals(origType)) {, +					code.add('(').add(useType(origType)).add(')').add(arg(arg));, +				} else {, +					code.add(arg(arg));, +				}, +				if (i < argsCount - 1) {, +					code.add(", ");, +				}, +				origPos++;, +			}, +			code.add(')');, +		} else {, +	}, +		int argsCount = insn.getArgsCount();]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Modifier;, +		System.out.println(cls.getCode());, +, +		runAutoCheck(clsName);, +, +			@Override, +			public boolean isShowInconsistentCode() {, +				return true;, +			}, +	private void runAutoCheck(String clsName) {, +		try {, +			// run 'check' method from original class, +			Class<?> origCls;, +			try {, +				origCls = Class.forName(clsName);, +			} catch (ClassNotFoundException e) {, +				// ignore, +				return;, +			}, +			Method checkMth;, +			try {, +				checkMth = origCls.getMethod("check");, +			} catch (NoSuchMethodException e) {, +				// ignore, +				return;, +			}, +			if (!checkMth.getReturnType().equals(void.class), +					|| !Modifier.isPublic(checkMth.getModifiers()), +					|| Modifier.isStatic(checkMth.getModifiers())) {, +				fail("Wrong 'check' method");, +				return;, +			}, +			try {, +				checkMth.invoke(origCls.newInstance());, +			} catch (InvocationTargetException ie) {, +				rethrow("Java check failed", ie);, +			}, +			// run 'check' method from decompiled class, +			try {, +				invoke("check");, +			} catch (InvocationTargetException ie) {, +				rethrow("Decompiled check failed", ie);, +			}, +		} catch (Exception e) {, +			e.printStackTrace();, +			fail("Auto check exception: " + e.getMessage());, +		}, +	}, +, +	private void rethrow(String msg, InvocationTargetException ie) {, +		Throwable cause = ie.getCause();, +		if (cause instanceof AssertionError) {, +			System.err.println(msg);, +			throw ((AssertionError) cause);, +		} else {, +			cause.printStackTrace();, +			fail(msg + cause.getMessage());, +		}, +	}, +, +	public Object invoke(String method, Class[] types, Object... args) throws Exception {, +	public Object invoke(Method mth, Object... args) throws Exception {, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Modifier;, +		System.out.println(cls.getCode());, +, +		runAutoCheck(clsName);, +, +			@Override, +			public boolean isShowInconsistentCode() {, +				return true;, +			}, +	private void runAutoCheck(String clsName) {, +		try {, +			// run 'check' method from original class, +			Class<?> origCls;, +			try {, +				origCls = Class.forName(clsName);, +			} catch (ClassNotFoundException e) {, +				// ignore, +				return;, +			}, +			Method checkMth;, +			try {, +				checkMth = origCls.getMethod("check");, +			} catch (NoSuchMethodException e) {, +				// ignore, +				return;, +			}, +			if (!checkMth.getReturnType().equals(void.class), +					|| !Modifier.isPublic(checkMth.getModifiers()), +					|| Modifier.isStatic(checkMth.getModifiers())) {, +				fail("Wrong 'check' method");, +				return;, +			}, +			try {, +				checkMth.invoke(origCls.newInstance());]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +	ZipRef getZipRef() {, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +	ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +		ZipRef zipRef = rf.getZipRef();, +		if (zipRef == null) {, +			return null;, +		}, +			result = decoder.decode(entry.getSize(), inputStream);, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +				LOG.error("Error close zip file: {}", zipRef, e);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +	ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +		ZipRef zipRef = rf.getZipRef();, +		if (zipRef == null) {, +			return null;, +		}, +			result = decoder.decode(entry.getSize(), inputStream);, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +				LOG.error("Error close zip file: {}", zipRef, e);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		InputFile firstInputFile = root.getDexNodes().get(0).getDexFile().getInputFile();, +		deobfuscator = new Deobfuscator(args, root.getDexNodes(), deobfMapFile);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +	ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +		ZipRef zipRef = rf.getZipRef();, +		if (zipRef == null) {, +			return null;, +		}, +			result = decoder.decode(entry.getSize(), inputStream);, +			throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, +				LOG.error("Error close zip file: {}", zipRef, e);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		InputFile firstInputFile = root.getDexNodes().get(0).getDexFile().getInputFile();, +		deobfuscator = new Deobfuscator(args, root.getDexNodes(), deobfMapFile);, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +		DexNode firstDex = root.getDexNodes().get(0);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +	ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +		ZipRef zipRef = rf.getZipRef();, +		if (zipRef == null) {, +			return null;, +		}, +			result = decoder.decode(entry.getSize(), inputStream);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +		} catch (Exception e) {, +			try {, +			} catch (Exception e) {, +				LOG.error("Field signature parse error: {}.{}", this.getFullName(), field.getName(), e);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +		} catch (Exception e) {, +			try {, +			} catch (Exception e) {, +				LOG.error("Field signature parse error: {}.{}", this.getFullName(), field.getName(), e);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +				if (inner == null) {, +					throw new JadxRuntimeException("No inner type found: " + debugString());, +				}, +		if (pos >= sign.length()) {, +			return sign;, +		}]
[+++ b/.travis.yml, +script: gradle clean build, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, +    ./gradlew dist, +     --cfg           - save methods control flow graph to dot file, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, +    ./gradlew dist, +     --cfg           - save methods control flow graph to dot file, +++ b/build.gradle, +            if (!"${it}".contains(":jadx-samples:")) {, +    }, +    }, +task dist(dependsOn: pack) {, +task samples(dependsOn: 'jadx-samples:samples') {, +}, +, +task build(dependsOn: [dist, samples]) {, +}, +, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, +    ./gradlew dist, +     --cfg           - save methods control flow graph to dot file, +++ b/build.gradle, +            if (!"${it}".contains(":jadx-samples:")) {, +    }, +    }, +task dist(dependsOn: pack) {, +task samples(dependsOn: 'jadx-samples:samples') {, +}, +, +task build(dependsOn: [dist, samples]) {, +}, +, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String JADX_VERSION = Jadx.getVersion();, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, +    ./gradlew dist, +     --cfg           - save methods control flow graph to dot file, +++ b/build.gradle, +            if (!"${it}".contains(":jadx-samples:")) {, +    }, +    }, +task dist(dependsOn: pack) {, +task samples(dependsOn: 'jadx-samples:samples') {, +}, +, +task build(dependsOn: [dist, samples]) {, +}, +, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String JADX_VERSION = Jadx.getVersion();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.utils.Utils;, +import java.io.IOException;, +import java.net.URL;, +import java.util.Enumeration;, +import java.util.jar.Manifest;, +, +	public static String getVersion() {, +		try {, +			Enumeration<URL> resources = Utils.class.getClassLoader().getResources("META-INF/MANIFEST.MF");, +			while (resources.hasMoreElements()) {, +				Manifest manifest = new Manifest(resources.nextElement().openStream());, +				String ver = manifest.getMainAttributes().getValue("jadx-version");, +				if (ver != null), +					return ver;, +			}, +		} catch (IOException e) {, +			LOG.error("Can't get manifest file", e);, +		}, +		return "dev";, +	}, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, +    ./gradlew dist, +     --cfg           - save methods control flow graph to dot file, +++ b/build.gradle, +            if (!"${it}".contains(":jadx-samples:")) {, +    }, +    }, +task dist(dependsOn: pack) {, +task samples(dependsOn: 'jadx-samples:samples') {, +}, +, +task build(dependsOn: [dist, samples]) {, +}, +, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +	public static final String JADX_VERSION = Jadx.getVersion();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.utils.Utils;]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		List<File> files = compileClass(cls);, +		assertThat("File list is empty", files, not(empty()));, +		String path = cls.getPackage().getName().replace('.', '/');, +			for (File file : files) {, +		String clsFullName = cls.getName();, +		String rootClsName;, +		int end = clsFullName.indexOf('$');, +			rootClsName = clsFullName.substring(0, end);, +		} else {, +			rootClsName = clsFullName;, +		String javaFileName = rootClsName.replace('.', '/') + ".java";, +		File file = new File(TEST_DIRECTORY, javaFileName);, +			file = new File(TEST_DIRECTORY2, javaFileName);, +		assertThat("Test source file not found: " + javaFileName, file.exists(), is(true));, +		files.forEach(File::deleteOnExit);, +		String clsName = clsFullName.substring(clsFullName.lastIndexOf('.') + 1);, +		files.removeIf(next -> !next.getName().contains(clsName));, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		List<File> files = compileClass(cls);, +		assertThat("File list is empty", files, not(empty()));, +		String path = cls.getPackage().getName().replace('.', '/');, +			for (File file : files) {, +		String clsFullName = cls.getName();, +		String rootClsName;, +		int end = clsFullName.indexOf('$');, +			rootClsName = clsFullName.substring(0, end);, +		} else {, +			rootClsName = clsFullName;, +		String javaFileName = rootClsName.replace('.', '/') + ".java";, +		File file = new File(TEST_DIRECTORY, javaFileName);, +			file = new File(TEST_DIRECTORY2, javaFileName);, +		assertThat("Test source file not found: " + javaFileName, file.exists(), is(true));, +		files.forEach(File::deleteOnExit);, +		String clsName = clsFullName.substring(clsFullName.lastIndexOf('.') + 1);, +		files.removeIf(next -> !next.getName().contains(clsName));, +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestImportGenericMap.java, +	public static class SuperClass<O extends SuperClass.ToImport> {, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(SuperClass.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString(, +			"import " + SuperClass.ToImport.class.getName().replace("$ToImport", ".ToImport") + ';'));, +		assertThat(code, not(containsString(, +			"import " + SuperClass.NotToImport.class.getName().replace("NotToImport", ".NotToImport") + ';')));, +	}, +}, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		List<File> files = compileClass(cls);, +		assertThat("File list is empty", files, not(empty()));, +		String path = cls.getPackage().getName().replace('.', '/');, +			for (File file : files) {, +		String clsFullName = cls.getName();, +		String rootClsName;, +		int end = clsFullName.indexOf('$');, +			rootClsName = clsFullName.substring(0, end);, +		} else {, +			rootClsName = clsFullName;, +		String javaFileName = rootClsName.replace('.', '/') + ".java";, +		File file = new File(TEST_DIRECTORY, javaFileName);, +			file = new File(TEST_DIRECTORY2, javaFileName);, +		assertThat("Test source file not found: " + javaFileName, file.exists(), is(true));, +		files.forEach(File::deleteOnExit);, +		String clsName = clsFullName.substring(clsFullName.lastIndexOf('.') + 1);, +		files.removeIf(next -> !next.getName().contains(clsName));, +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/TestImportGenericMap.java, +	public static class SuperClass<O extends SuperClass.ToImport> {, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(SuperClass.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString(, +			"import " + SuperClass.ToImport.class.getName().replace("$ToImport", ".ToImport") + ';'));, +		assertThat(code, not(containsString(, +			"import " + SuperClass.NotToImport.class.getName().replace("NotToImport", ".NotToImport") + ';')));, +	}, +}, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java]
[+++ /dev/null, +++ /dev/null, +++ b/.gitignore, +**/.DS_Store, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public int length() {, +		return buf.length();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public int length() {, +		return buf.length();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	@Deprecated, +	@Deprecated, +	@Deprecated, +		addArg(code, arg, wrap);, +		return code;, +	}, +, +	public void addArg(CodeWriter code, InsnArg arg) throws CodegenException {, +		addArg(code, arg, true);, +	}, +, +	public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenException {, +				code.add(staticField(f.getField()));, +				instanceField(code, f.getField(), regArg);, +	private void instanceField(CodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {, +			return;, +		int len = code.length();, +		addArg(code, arg);, +		if (code.length() != len) {, +			code.add('.');, +		code.add(field.getName());, +	protected String staticField(FieldInfo field) {, +				addArg(code, insn.getArg(0), false);, +				addArg(code, insn.getArg(0), true);, +					code.add("return ");, +					addArg(code, insn.getArg(0), false);, +				code.add("throw ");, +				addArg(code, insn.getArg(0), true);, +				addArg(code, insn.getArg(0));, +				code.add('[');, +				addArg(code, insn.getArg(1), false);, +				code.add(']');, +				addArg(code, insn.getArg(0));, +				code.add('[');, +				addArg(code, insn.getArg(1), false);, +				code.add("] = ");, +				addArg(code, insn.getArg(2), false);, +				instanceField(code, fieldInfo, insn.getArg(0));, +				instanceField(code, fieldInfo, insn.getArg(1));, +				code.add(" = ");, +				addArg(code, insn.getArg(0), false);, +				code.add(staticField((FieldInfo) ((IndexInsnNode) insn).getIndex()));, +				code.add(staticField((FieldInfo) node.getIndex())).add(" = ");, +				addArg(code, node.getArg(0), false);, +					code.add('(').add(useType(origType)).add(')');, +					addArg(code, arg, true);, +					addArg(code, arg, false);, +				addArg(code, insn.getArg(k), false);, +					addArg(code, insn.getArg(i), false);, +			for (Map.Entry<RegisterArg, InsnArg> e : toRevert.entrySet()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +	public int length() {, +		return buf.length();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	@Deprecated, +	@Deprecated, +	@Deprecated, +		addArg(code, arg, wrap);, +		return code;, +	}, +, +	public void addArg(CodeWriter code, InsnArg arg) throws CodegenException {, +		addArg(code, arg, true);, +	}, +, +	public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenException {, +				code.add(staticField(f.getField()));, +				instanceField(code, f.getField(), regArg);, +	private void instanceField(CodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {, +			return;, +		int len = code.length();, +		addArg(code, arg);, +		if (code.length() != len) {, +			code.add('.');, +		code.add(field.getName());, +	protected String staticField(FieldInfo field) {, +				addArg(code, insn.getArg(0), false);, +				addArg(code, insn.getArg(0), true);, +					code.add("return ");, +					addArg(code, insn.getArg(0), false);, +				code.add("throw ");, +				addArg(code, insn.getArg(0), true);, +				addArg(code, insn.getArg(0));, +				code.add('[');, +				addArg(code, insn.getArg(1), false);, +				code.add(']');, +				addArg(code, insn.getArg(0));]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments == null || arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +		addNamesUsedInClass();, +	}, +, +	private void addNamesUsedInClass() {, +		ClassNode parentClass = mth.getParentClass();, +		for (FieldNode field : parentClass.getFields()) {, +			varNames.add(field.getAlias());, +		}, +		for (ClassNode innerClass : parentClass.getInnerClasses()) {, +			varNames.add(innerClass.getAlias().getShortName());, +		}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +		addNamesUsedInClass();, +	}, +, +	private void addNamesUsedInClass() {, +		ClassNode parentClass = mth.getParentClass();, +		for (FieldNode field : parentClass.getFields()) {, +			varNames.add(field.getAlias());, +		}, +		for (ClassNode innerClass : parentClass.getInnerClasses()) {, +			varNames.add(innerClass.getAlias().getShortName());, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Objects;, +import jadx.core.utils.BlockUtils;, +		if (block.contains(AFlag.DONT_GENERATE)) {, +			return;, +		}, +, +		SwitchNode insn = (SwitchNode) BlockUtils.getLastInsn(sw.getHeader());, +		Objects.requireNonNull(insn, "Switch insn not found in header");, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +		addNamesUsedInClass();, +	}, +, +	private void addNamesUsedInClass() {, +		ClassNode parentClass = mth.getParentClass();, +		for (FieldNode field : parentClass.getFields()) {, +			varNames.add(field.getAlias());, +		}, +		for (ClassNode innerClass : parentClass.getInnerClasses()) {, +			varNames.add(innerClass.getAlias().getShortName());, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Objects;, +import jadx.core.utils.BlockUtils;, +		if (block.contains(AFlag.DONT_GENERATE)) {, +			return;, +		}, +, +		SwitchNode insn = (SwitchNode) BlockUtils.getLastInsn(sw.getHeader());, +		Objects.requireNonNull(insn, "Switch insn not found in header");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		String name = field.getName();, +		if (arg.isThis()) {, +			boolean useShort = true;, +			List<RegisterArg> args = mth.getArguments(false);, +			for (RegisterArg param : args) {, +				String paramName = param.getTypedVar().getName();, +				if (paramName != null && paramName.equals(name)) {, +					useShort = false;, +				}, +			}, +			if (useShort) {, +				return name; // FIXME: check variable names in scope, +			}, +		}, +		return arg(arg) + "." + name;, +				InsnArg arg = insn.getArg(0);, +				if (!arg.isThis()) { // FIXME: add 'this' for equals methods in scope, +					code.add(arg(arg)).add('.');, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		String name = field.getName();, +		if (arg.isThis()) {, +			boolean useShort = true;, +			List<RegisterArg> args = mth.getArguments(false);, +			for (RegisterArg param : args) {, +				String paramName = param.getTypedVar().getName();, +				if (paramName != null && paramName.equals(name)) {, +					useShort = false;, +				}, +			}, +			if (useShort) {, +				return name; // FIXME: check variable names in scope, +			}, +		}, +		return arg(arg) + "." + name;, +				InsnArg arg = insn.getArg(0);, +				if (!arg.isThis()) { // FIXME: add 'this' for equals methods in scope, +					code.add(arg(arg)).add('.');, +				}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestRedundantThis.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestRedundantThis extends InternalJadxTest {, +, +	public static class TestCls {, +		public int field1 = 1;, +		public int field2 = 2;, +, +		public boolean f1() {, +			return false;, +		}, +, +		public int method() {, +			f1();, +			return field1;, +		}, +, +		public void method2(int field2) {, +			this.field2 = field2;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +, +		String code = cls.getCode().toString();, +, +		assertThat(code, not(containsString("this.f1();")));, +		assertThat(code, not(containsString("return this.field1;")));, +, +		assertThat(code, containsString("this.field2 = field2;"));, +	}, +}]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) throws JadxException {, +		} catch (Throwable e) {, +			LOG.error("jadx error: " + e.getMessage(), e);, +		jadx.loadFiles(jadxArgs.getInput());, +		if (jadx.getErrorsCount() != 0) {, +			jadx.printErrorsReport();, +			LOG.error("finished with errors");, +		} else {, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) throws JadxException {, +		} catch (Throwable e) {, +			LOG.error("jadx error: " + e.getMessage(), e);, +		jadx.loadFiles(jadxArgs.getInput());, +		if (jadx.getErrorsCount() != 0) {, +			jadx.printErrorsReport();, +			LOG.error("finished with errors");, +		} else {, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import jadx.api.JadxDecompiler;, +		out.println("jadx - dex to java decompiler, version: " + JadxDecompiler.getVersion());, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) throws JadxException {, +		} catch (Throwable e) {, +			LOG.error("jadx error: " + e.getMessage(), e);, +		jadx.loadFiles(jadxArgs.getInput());, +		if (jadx.getErrorsCount() != 0) {, +			jadx.printErrorsReport();, +			LOG.error("finished with errors");, +		} else {, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import jadx.api.JadxDecompiler;, +		out.println("jadx - dex to java decompiler, version: " + JadxDecompiler.getVersion());, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +import java.io.File;, +, +	public File getOutDir() {, +		return new File("jadx-output");, +	}, +, +	@Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) throws JadxException {, +		} catch (Throwable e) {, +			LOG.error("jadx error: " + e.getMessage(), e);, +		jadx.loadFiles(jadxArgs.getInput());, +		if (jadx.getErrorsCount() != 0) {, +			jadx.printErrorsReport();, +			LOG.error("finished with errors");, +		} else {, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import jadx.api.JadxDecompiler;, +		out.println("jadx - dex to java decompiler, version: " + JadxDecompiler.getVersion());, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +import java.io.File;, +, +	public File getOutDir() {, +		return new File("jadx-output");, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +import java.io.File;, +, +	File getOutDir();, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +	public static void main(String[] args) throws JadxException {, +		} catch (Throwable e) {, +			LOG.error("jadx error: " + e.getMessage(), e);, +		jadx.loadFiles(jadxArgs.getInput());, +		if (jadx.getErrorsCount() != 0) {, +			jadx.printErrorsReport();, +			LOG.error("finished with errors");, +		} else {, +		}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import jadx.api.JadxDecompiler;, +		out.println("jadx - dex to java decompiler, version: " + JadxDecompiler.getVersion());, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +import java.io.File;, +, +	public File getOutDir() {, +		return new File("jadx-output");, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +import java.io.File;, +, +	File getOutDir();, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import java.util.Enumeration;, +, +		// Input file could be .apk or .zip files, +		// we should consider the input file could contain only one single dex, multi-dex, or instantRun support dex for Android .apk files, +		String instantRunDexSuffix = "classes" + ext;, +		for (Enumeration<? extends ZipEntry> e = zf.entries(); e.hasMoreElements(); ) {, +			ZipEntry entry = e.nextElement();, +			String entryName = entry.getName();, +, +				if ((entryName.startsWith("classes") && entryName.endsWith(ext)) || entryName.endsWith(instantRunDexSuffix)) {, +						index++;, +						index++;, +				} else if (entryName.equals("instant-run.zip") && ext.equals(".dex")) {, +					File jarFile = FileUtils.createTempFile("instant-run.zip");, +					FileOutputStream fos = new FileOutputStream(jarFile);, +					try {, +						IOUtils.copy(inputStream, fos);, +					} finally {, +						close(fos);, +					}, +					InputFile tempFile = new InputFile(jarFile);, +					tempFile.loadFromZip(ext);, +					List<DexFile> dexFiles = tempFile.getDexFiles();, +					if (!dexFiles.isEmpty()) {, +						index += dexFiles.size();, +						this.dexFiles.addAll(dexFiles);, +					}, +				}]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + "." + getName();, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + "/" + CLST_FILENAME));, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + "/" + CLST_FILENAME));, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ")");, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + "/" + CLST_FILENAME));, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					return parent + "." + shortName;, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +				opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + "}";, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +					out.putNextEntry(new ZipEntry(CLST_PKG_PATH + "/" + CLST_FILENAME));, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +			throw new JadxRuntimeException("Can't decode value: " + val + " (" + val.getClass() + ")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +					return parent + "." + shortName;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add(insn.getType().toString()).add("(");]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +	private IRegion parent;, +	public void setParent(IRegion parent) {, +		this.parent = parent;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +	private IRegion parent;, +	public void setParent(IRegion parent) {, +		this.parent = parent;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.AbstractRegion;, +, +			// fix parents, +			for (IContainer cont : newRegion.getSubBlocks()) {, +				if (cont instanceof AbstractRegion) {, +					AbstractRegion aReg = (AbstractRegion) cont;, +					aReg.setParent(newRegion);, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +	private IRegion parent;, +	public void setParent(IRegion parent) {, +		this.parent = parent;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.AbstractRegion;, +, +			// fix parents, +			for (IContainer cont : newRegion.getSubBlocks()) {, +				if (cont instanceof AbstractRegion) {, +					AbstractRegion aReg = (AbstractRegion) cont;, +					aReg.setParent(newRegion);, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +			return arg + ", a:" + assigns + ", u:" + usage;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +	private IRegion parent;, +	public void setParent(IRegion parent) {, +		this.parent = parent;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.AbstractRegion;, +, +			// fix parents, +			for (IContainer cont : newRegion.getSubBlocks()) {, +				if (cont instanceof AbstractRegion) {, +					AbstractRegion aReg = (AbstractRegion) cont;, +					aReg.setParent(newRegion);, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +			return arg + ", a:" + assigns + ", u:" + usage;, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestVariablesDefinitions.java, +import java.util.Iterator;, +import org.junit.Test;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +				Iterator<IDexTreeVisitor> iterator = passes.iterator();, +				while (iterator.hasNext()) {, +					DepthTraverser.visit(iterator.next(), cls);, +	@Test, +, +		// 'iterator' variable must be declared inside 'try' block, +		assertThat(code, containsString(makeIndent(3) + "Iterator<IDexTreeVisitor> iterator = "));, +		assertThat(code, not(containsString("iterator;")));]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +				if (!(container instanceof BlockNode)) {, +					return;, +				}, +				BlockNode block = (BlockNode) container;, +				if (blocksInRegions.add(block)) {, +					return;, +				}, +				if (!block.contains(AFlag.RETURN), +						&& !block.contains(AFlag.SKIP), +						&& !block.contains(AFlag.SYNTHETIC), +						&& !block.getInstructions().isEmpty()) {, +					// TODO, +					// mth.add(AFlag.INCONSISTENT_CODE);, +					LOG.debug(" Duplicated block: {} in {}", block, mth);]
[+++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +certificate.serialSigVer=Version, +certificate.cert_issuer=Issuer, +certificate.cert_subject=Subject, +certificate.serialPubKeyType=Public key type, +certificate.serialPubKeyExponent=Exponent, +certificate.serialPubKeyModulus=Modulus, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +certificate.serialSigVer=Version, +certificate.cert_issuer=Issuer, +certificate.cert_subject=Subject, +certificate.serialPubKeyType=Public key type, +certificate.serialPubKeyExponent=Exponent, +certificate.serialPubKeyModulus=Modulus, +++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.recent_files=最近打开的文件, +menu.no_recent_files=无最近打开的文件, +menu.preferences=设置, +menu.flatten=展开显示代码包, +menu.text_search=搜索文本, +menu.deobfuscation=反混淆, +file.open_action=打开..., +file.open_title=打开文件, +file.save_all=全部保存, +file.export_gradle=另存为 Gradle 项目, +tree.sources_title=源代码, +tree.resources_title=资源文件, +tabs.closeOthers=关闭其他文件, +tabs.closeAll=全部关闭, +nav.forward=前进, +search_dialog.open=转到, +search_dialog.open_by_name=搜索文本：, +search_dialog.search_in=在以下位置搜索：, +search_dialog.class=类名, +search_dialog.method=方法名, +search_dialog.field=变量名, +search_dialog.options=搜索选项：, +search_dialog.ignorecase=忽略大小写, +search_dialog.next_page=下一页, +search_dialog.prev_page=上一页, +search_dialog.info_label=显示了 %3$d 个结果中的第 %1$d 至第 %3$d 个, +search_dialog.col_node=节点, +search_dialog.col_code=代码, +usage_dialog.title=查找, +usage_dialog.label=查找用例：, +log_viewer.title=日志查看器, +log_viewer.log_level=日志等级：, +, +about_dialog.title=关于 JADX, +, +preferences.title=设置, +preferences.deobfuscation=反混淆, +preferences.fallback=输出中间代码, +preferences.escapeUnicode=将 Unicode 字符转义, +preferences.skipResourcesDecode=不反编译资源文件, +preferences.threads=并行线程数, +preferences.language=语言, +preferences.check_for_updates=启动时检查更新, +preferences.cfg=生成方法的 CFG 图（以 .dot 格式保存）, +preferences.raw_cfg=生成原始的 CFG 图, +preferences.theme=编辑器主题, +preferences.start_jobs=自动进行后台反编译, +preferences.deobfuscation_on=启用反混淆, +preferences.deobfuscation_force=强制覆盖反混淆映射文件, +preferences.reset_message=要恢复默认设置吗？, +msg.saving_sources=正在导出源代码..., +msg.index_not_initialized=索引尚未初始化，无法进行搜索！, +popup.redo=重做, +, +certificate.title=证书, +certificate.cert_type=类型, +certificate.serialSigVer=版本, +certificate.serialNumber=序列号, +certificate.cert_issuer=颁发者, +certificate.cert_subject=主题, +certificate.serialValidFrom=有效期始, +certificate.serialValidUntil=有效期至, +certificate.serialPubKeyType=公钥类型, +certificate.serialPubKeyExponent=指数, +certificate.serialPubKeyModulus=模数, +certificate.serialSigType=签名算法, +certificate.serialSigOID=签名 OID, +certificate.serialMD5=MD5 签名, +certificate.serialSHA1=SHA-1 签名, +certificate.serialSHA256=SHA-256 签名, +certificate.serialPubKeyY=Y]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public void mergeName(InsnArg arg) {, +		if (arg instanceof Named) {, +			Named otherArg = (Named) arg;, +			String otherName = otherArg.getName();, +			String name = getName();, +			if (!Objects.equals(name, otherName)) {, +				if (name == null) {, +					setName(otherName);, +				} else if (otherName == null) {, +					otherArg.setName(name);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public void mergeName(InsnArg arg) {, +		if (arg instanceof Named) {, +			Named otherArg = (Named) arg;, +			String otherName = otherArg.getName();, +			String name = getName();, +			if (!Objects.equals(name, otherName)) {, +				if (name == null) {, +					setName(otherName);, +				} else if (otherName == null) {, +					otherArg.setName(name);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		boolean varsInfoFound = false;, +, +					varsInfoFound = true;, +					varsInfoFound = true;, +					varsInfoFound = true;, +					varsInfoFound = true;, +		if (varsInfoFound) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public void mergeName(InsnArg arg) {, +		if (arg instanceof Named) {, +			Named otherArg = (Named) arg;, +			String otherName = otherArg.getName();, +			String name = getName();, +			if (!Objects.equals(name, otherName)) {, +				if (name == null) {, +					setName(otherName);, +				} else if (otherName == null) {, +					otherArg.setName(name);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		boolean varsInfoFound = false;, +, +					varsInfoFound = true;, +					varsInfoFound = true;, +					varsInfoFound = true;, +					varsInfoFound = true;, +		if (varsInfoFound) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +					insn.getResult().mergeName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public void mergeName(InsnArg arg) {, +		if (arg instanceof Named) {, +			Named otherArg = (Named) arg;, +			String otherName = otherArg.getName();, +			String name = getName();, +			if (!Objects.equals(name, otherName)) {, +				if (name == null) {, +					setName(otherName);, +				} else if (otherName == null) {, +					otherArg.setName(name);, +				}, +			}, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +		boolean varsInfoFound = false;, +, +					varsInfoFound = true;, +					varsInfoFound = true;, +					varsInfoFound = true;, +					varsInfoFound = true;, +		if (varsInfoFound) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +					insn.getResult().mergeName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public void mergeName(InsnArg arg) {, +		if (arg instanceof Named) {, +			Named otherArg = (Named) arg;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +import jadx.core.utils.BlockUtils;, +				LOG.warn("Initial immutable type set rejected: {} -> {}", ssaVar, initType);, +				BlockNode blockNode = entry.getValue();, +				InsnNode lastInsn = BlockUtils.getLastInsn(blockNode);, +				if (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {, +					if (Consts.DEBUG) {, +						LOG.warn("Can't insert move for PHI in block with separate insn: {}", lastInsn);, +					}, +					return false;, +				}, +, +				blockNode.getInstructions().add(moveInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +import jadx.core.utils.BlockUtils;, +				LOG.warn("Initial immutable type set rejected: {} -> {}", ssaVar, initType);, +				BlockNode blockNode = entry.getValue();, +				InsnNode lastInsn = BlockUtils.getLastInsn(blockNode);, +				if (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {, +					if (Consts.DEBUG) {, +						LOG.warn("Can't insert move for PHI in block with separate insn: {}", lastInsn);, +					}, +					return false;, +				}, +, +				blockNode.getInstructions().add(moveInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +import jadx.core.dex.attributes.AFlag;, +			allowReject = arg.isThis() || arg.contains(AFlag.IMMUTABLE_TYPE);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +import jadx.core.utils.BlockUtils;, +				LOG.warn("Initial immutable type set rejected: {} -> {}", ssaVar, initType);, +				BlockNode blockNode = entry.getValue();, +				InsnNode lastInsn = BlockUtils.getLastInsn(blockNode);, +				if (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {, +					if (Consts.DEBUG) {, +						LOG.warn("Can't insert move for PHI in block with separate insn: {}", lastInsn);, +					}, +					return false;, +				}, +, +				blockNode.getInstructions().add(moveInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +import jadx.core.dex.attributes.AFlag;, +			allowReject = arg.isThis() || arg.contains(AFlag.IMMUTABLE_TYPE);, +++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java, +import jadx.core.dex.visitors.AbstractVisitor;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.utils.exceptions.JadxException;, +	public static IDexTreeVisitor printRegionsVisitor() {, +		return new AbstractVisitor() {, +			@Override, +			public void visit(MethodNode mth) throws JadxException {, +				printRegions(mth, true);, +			}, +		};, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.Comparator;, +		for (JavaPackage pkg : packages) {, +			Collections.sort(pkg.getClasses(), new Comparator<JavaClass>() {, +				@Override, +				public int compare(JavaClass o1, JavaClass o2) {, +					return o1.getShortName().compareTo(o2.getShortName());, +				}, +			});, +		}, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.Comparator;, +		for (JavaPackage pkg : packages) {, +			Collections.sort(pkg.getClasses(), new Comparator<JavaClass>() {, +				@Override, +				public int compare(JavaClass o1, JavaClass o2) {, +					return o1.getShortName().compareTo(o2.getShortName());, +				}, +			});, +		}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import java.util.Comparator;, +			Collections.sort(mths, new Comparator<JavaMethod>() {, +				@Override, +				public int compare(JavaMethod o1, JavaMethod o2) {, +					return o1.getName().compareTo(o2.getName());, +				}, +			});]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), +	protected String outDirNameSrc;, +, +	@Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), +	protected String outDirNameRes;, +, +	private File outputDirSrc;, +	private File outputDirRes;, +			if(outDirNameSrc != null) {, +				outputDirSrc = new File(outDirNameSrc);, +			}, +			if(outDirNameRes != null) {, +				outputDirRes = new File(outDirNameRes);, +			}, +				if(outputDirSrc == null) {, +					outputDirSrc = new File(outputDir, "source");, +				if(outputDirRes == null) {, +					outputDirRes = new File(outputDir, "res");, +				}, +			}, +			, +	@Override, +	public File getOutDirSrc() {, +		return outputDirSrc;, +	}, +, +	@Override, +	public File getOutDirRes() {, +		return outputDirRes;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), +	protected String outDirNameSrc;, +, +	@Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), +	protected String outDirNameRes;, +, +	private File outputDirSrc;, +	private File outputDirRes;, +			if(outDirNameSrc != null) {, +				outputDirSrc = new File(outDirNameSrc);, +			}, +			if(outDirNameRes != null) {, +				outputDirRes = new File(outDirNameRes);, +			}, +				if(outputDirSrc == null) {, +					outputDirSrc = new File(outputDir, "source");, +				if(outputDirRes == null) {, +					outputDirRes = new File(outputDir, "res");, +				}, +			}, +			, +	@Override, +	public File getOutDirSrc() {, +		return outputDirSrc;, +	}, +, +	@Override, +	public File getOutDirRes() {, +		return outputDirRes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +	, +	File getOutDirSrc();, +	, +	File getOutDirRes();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), +	protected String outDirNameSrc;, +, +	@Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), +	protected String outDirNameRes;, +, +	private File outputDirSrc;, +	private File outputDirRes;, +			if(outDirNameSrc != null) {, +				outputDirSrc = new File(outDirNameSrc);, +			}, +			if(outDirNameRes != null) {, +				outputDirRes = new File(outDirNameRes);, +			}, +				if(outputDirSrc == null) {, +					outputDirSrc = new File(outputDir, "source");, +				if(outputDirRes == null) {, +					outputDirRes = new File(outputDir, "res");, +				}, +			}, +			, +	@Override, +	public File getOutDirSrc() {, +		return outputDirSrc;, +	}, +, +	@Override, +	public File getOutDirRes() {, +		return outputDirRes;, +	}]
[+++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			String fileName = file.getName();, +			if (fileName.endsWith(".dex"), +					|| fileName.endsWith(".jar"), +					|| fileName.endsWith(".apk")) {, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			String fileName = file.getName();, +			if (fileName.endsWith(".dex"), +					|| fileName.endsWith(".jar"), +					|| fileName.endsWith(".apk")) {, +++ /dev/null, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			String fileName = file.getName();, +			if (fileName.endsWith(".dex"), +					|| fileName.endsWith(".jar"), +					|| fileName.endsWith(".apk")) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private static final String ANDROID_R_STYLE_CLS = "android.R$style";, +			try {, +				Class rStyleCls = Class.forName(ANDROID_R_STYLE_CLS);, +				for (Field f : rStyleCls.getFields()) {, +			} catch (Throwable th) {, +				LOG.error("R class loading failed", th);, +			}, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			String fileName = file.getName();, +			if (fileName.endsWith(".dex"), +					|| fileName.endsWith(".jar"), +					|| fileName.endsWith(".apk")) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private static final String ANDROID_R_STYLE_CLS = "android.R$style";, +			try {, +				Class rStyleCls = Class.forName(ANDROID_R_STYLE_CLS);, +				for (Field f : rStyleCls.getFields()) {, +			} catch (Throwable th) {, +				LOG.error("R class loading failed", th);, +			}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +import jadx.core.utils.exceptions.JadxException;, +, +	private static final String MANIFEST_ATTR_XML = "/android/attrs_manifest.xml";, +			if (xmlStream == null) {, +				throw new JadxException(MANIFEST_ATTR_XML + " not found in classpath");, +			}, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +			String fileName = file.getName();, +			if (fileName.endsWith(".dex"), +					|| fileName.endsWith(".jar"), +					|| fileName.endsWith(".apk")) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private static final String ANDROID_R_STYLE_CLS = "android.R$style";, +			try {, +				Class rStyleCls = Class.forName(ANDROID_R_STYLE_CLS);, +				for (Field f : rStyleCls.getFields()) {, +			} catch (Throwable th) {, +				LOG.error("R class loading failed", th);, +			}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java]
[+++ b/jadx-core/src/test/java/jadx/NotYetImplemented.java, +package jadx;, +, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +, +/**, + * Indicates a test which is known to fail., + * , + * <p>This would cause a failure to be considered as success and a success as failure,, + * with the benefit of updating the related issue when it has been resolved even unintentionally.</p>, + * , + * <p>To have an effect, the test class must be annotated with:, + * , + * <code>, + *      &#064;ExtendWith(NotYetImplementedExtension.class), + * </code>, + * </p>, + */, +@Retention(RetentionPolicy.RUNTIME), +@Target({ElementType.TYPE, ElementType.METHOD}), +public @interface NotYetImplemented {, +}, +++ b/jadx-core/src/test/java/jadx/NotYetImplemented.java, +package jadx;, +, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +, +/**, + * Indicates a test which is known to fail., + * , + * <p>This would cause a failure to be considered as success and a success as failure,, + * with the benefit of updating the related issue when it has been resolved even unintentionally.</p>, + * , + * <p>To have an effect, the test class must be annotated with:, + * , + * <code>, + *      &#064;ExtendWith(NotYetImplementedExtension.class), + * </code>, + * </p>, + */, +@Retention(RetentionPolicy.RUNTIME), +@Target({ElementType.TYPE, ElementType.METHOD}), +public @interface NotYetImplemented {, +}, +++ b/jadx-core/src/test/java/jadx/NotYetImplementedExtension.java, +package jadx;, +, +import java.lang.reflect.Method;, +import java.util.HashSet;, +import java.util.Set;, +, +import org.junit.jupiter.api.extension.AfterTestExecutionCallback;, +import org.junit.jupiter.api.extension.ExtensionContext;, +import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;, +, +public class NotYetImplementedExtension implements AfterTestExecutionCallback, TestExecutionExceptionHandler {, +, +	private Set<Method> knownFailedMethods = new HashSet<>();, +, +	@Override, +	public void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {, +		if (!isNotYetImplemented(context)) {, +			throw throwable;, +		}, +		knownFailedMethods.add(context.getTestMethod().get());, +	}, +, +	@Override, +	public void afterTestExecution(ExtensionContext context) throws Exception {, +		if (!knownFailedMethods.contains(context.getTestMethod().get()), +				&& isNotYetImplemented(context), +				&& !context.getExecutionException().isPresent()) {, +			throw new AssertionError("Test ", +					+ context.getTestClass().get().getName() + '.' + context.getTestMethod().get().getName(), +					+ " is marked as @NotYetImplemented, but passes!");, +		}, +	}, +, +	private static boolean isNotYetImplemented(ExtensionContext context) {, +		return context.getTestMethod().get().getAnnotation(NotYetImplemented.class) != null, +				|| context.getTestClass().get().getAnnotation(NotYetImplemented.class) != null;, +	}, +, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	private static enum IGState {, +		BODY_ONLY_NOWRAP,, +		return arg(arg, true);, +	}, +, +	public String arg(InsnArg arg, boolean wrap) throws CodegenException {, +			IGState flag = wrap ? IGState.BODY_ONLY : IGState.BODY_ONLY_NOWRAP;, +			makeInsn(((InsnWrapArg) arg).getWrapInsn(), code, flag);, +		return makeInsn(insn, code, null);, +	private boolean makeInsn(InsnNode insn, CodeWriter code, IGState flag) throws CodegenException {, +			EnumSet<IGState> state = EnumSet.noneOf(IGState.class);, +			if (flag == IGState.BODY_ONLY || flag == IGState.BODY_ONLY_NOWRAP) {, +				state.add(flag);, +				if (state.contains(IGState.SKIP)) {, +				if (insn.getResult() != null && !state.contains(IGState.NO_RESULT)) {, +				}, +				if (!state.contains(IGState.NO_SEMICOLON)) {, +			}, +	private void makeInsnBody(CodeWriter code, InsnNode insn, EnumSet<IGState> state) throws CodegenException {, +				code.add(arg(insn.getArg(0), false));, +				code.add(arg(insn.getArg(0), false));, +				if (state.contains(IGState.BODY_ONLY)) {, +				} else {, +				}, +					code.add("return ").add(arg(insn.getArg(0), false));, +				code.add("throw ").add(arg(insn.getArg(0), true));, +				code.add(arg(insn.getArg(0))).add('[').add(arg(insn.getArg(1), false)).add(']');, +				code.add(ifield(fieldInfo, insn.getArg(1))).add(" = ").add(arg(insn.getArg(0), false));, +				code.add(sfield((FieldInfo) node.getIndex())).add(" = ").add(arg(node.getArg(0), false));, +				if (state.contains(IGState.BODY_ONLY)) {, +					state.add(IGState.SKIP);, +					state.add(IGState.SKIP);, +				state.add(IGState.SKIP);, +				state.add(IGState.NO_SEMICOLON);, +	private void makeConstructor(ConstructorInsn insn, CodeWriter code, EnumSet<IGState> state), +			state.add(IGState.SKIP);, +					code.add('(').add(useType(origType)).add(')').add(arg(arg, true));, +					code.add(arg(arg, false));, +			makeInsn(inl, code, IGState.BODY_ONLY);, +			makeInsn(inl, code, IGState.BODY_ONLY);, +			code.add(arg(insn.getArg(k), false));, +				code.add(arg(insn.getArg(i), false));, +	private void makeArith(ArithNode insn, CodeWriter code, EnumSet<IGState> state) throws CodegenException {, +		if (state.contains(IGState.BODY_ONLY)) {, +		} else if (state.contains(IGState.BODY_ONLY_NOWRAP)) {, +			code.add(v1).add(' ').add(op.getSymbol()).add(' ').add(v2);, +				state.add(IGState.NO_RESULT);, +				v2 = arg(insn.getArg(1), false);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	private static enum IGState {, +		BODY_ONLY_NOWRAP,, +		return arg(arg, true);, +	}, +, +	public String arg(InsnArg arg, boolean wrap) throws CodegenException {, +			IGState flag = wrap ? IGState.BODY_ONLY : IGState.BODY_ONLY_NOWRAP;, +			makeInsn(((InsnWrapArg) arg).getWrapInsn(), code, flag);, +		return makeInsn(insn, code, null);, +	private boolean makeInsn(InsnNode insn, CodeWriter code, IGState flag) throws CodegenException {, +			EnumSet<IGState> state = EnumSet.noneOf(IGState.class);, +			if (flag == IGState.BODY_ONLY || flag == IGState.BODY_ONLY_NOWRAP) {, +				state.add(flag);, +				if (state.contains(IGState.SKIP)) {, +				if (insn.getResult() != null && !state.contains(IGState.NO_RESULT)) {, +				}, +				if (!state.contains(IGState.NO_SEMICOLON)) {, +			}, +	private void makeInsnBody(CodeWriter code, InsnNode insn, EnumSet<IGState> state) throws CodegenException {, +				code.add(arg(insn.getArg(0), false));, +				code.add(arg(insn.getArg(0), false));, +				if (state.contains(IGState.BODY_ONLY)) {, +				} else {, +				}, +					code.add("return ").add(arg(insn.getArg(0), false));, +				code.add("throw ").add(arg(insn.getArg(0), true));, +				code.add(arg(insn.getArg(0))).add('[').add(arg(insn.getArg(1), false)).add(']');, +				code.add(ifield(fieldInfo, insn.getArg(1))).add(" = ").add(arg(insn.getArg(0), false));, +				code.add(sfield((FieldInfo) node.getIndex())).add(" = ").add(arg(node.getArg(0), false));, +				if (state.contains(IGState.BODY_ONLY)) {, +					state.add(IGState.SKIP);, +					state.add(IGState.SKIP);, +				state.add(IGState.SKIP);, +				state.add(IGState.NO_SEMICOLON);, +	private void makeConstructor(ConstructorInsn insn, CodeWriter code, EnumSet<IGState> state), +			state.add(IGState.SKIP);, +					code.add('(').add(useType(origType)).add(')').add(arg(arg, true));, +					code.add(arg(arg, false));, +			makeInsn(inl, code, IGState.BODY_ONLY);, +			makeInsn(inl, code, IGState.BODY_ONLY);, +			code.add(arg(insn.getArg(k), false));, +				code.add(arg(insn.getArg(i), false));, +	private void makeArith(ArithNode insn, CodeWriter code, EnumSet<IGState> state) throws CodegenException {, +		if (state.contains(IGState.BODY_ONLY)) {, +		} else if (state.contains(IGState.BODY_ONLY_NOWRAP)) {, +			code.add(v1).add(' ').add(op.getSymbol()).add(' ').add(v2);, +				state.add(IGState.NO_RESULT);, +				v2 = arg(insn.getArg(1), false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +					InsnType wrapType = wrap.getType();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +				if (sVar.getAssign() == null) {, +					continue;, +				}, +				// allow inline only one use arg or 'this', +				if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +				if (sVar.getAssign() == null) {, +					continue;, +				}, +				// allow inline only one use arg or 'this', +				if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +				if (sVar.getAssign() == null) {, +					continue;, +				}, +				// allow inline only one use arg or 'this', +				if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/usethis/TestInlineThis.java, +package jadx.tests.internal.usethis;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestInlineThis extends InternalJadxTest {, +, +	public static class TestCls {, +		public int field;, +, +		private void test() {, +			TestCls something = this;, +			something.method();, +			something.field = 123;, +		}, +, +		private void method() {, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, not(containsString("something")));, +		assertThat(code, not(containsString("something.method()")));, +		assertThat(code, not(containsString("something.field")));, +		assertThat(code, not(containsString("= this")));, +, +		assertThat(code, containsOne("this.field = 123;"));, +		assertThat(code, containsOne("method();"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +				if (sVar.getAssign() == null) {, +					continue;, +				}, +				// allow inline only one use arg or 'this', +				if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/usethis/TestInlineThis.java, +package jadx.tests.internal.usethis;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestInlineThis extends InternalJadxTest {, +, +	public static class TestCls {, +		public int field;, +, +		private void test() {, +			TestCls something = this;, +			something.method();, +			something.field = 123;, +		}, +, +		private void method() {, +		}, +	}, +, +	@Test, +	public void test() {]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxArgs.java, +package jadx.cli;, +, +import jadx.core.Consts;, +import jadx.api.IJadxArgs;, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.Parameter;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +, +public class JadxArgs implements IJadxArgs {, +	private static final Logger LOG = LoggerFactory.getLogger(JadxArgs.class);, +, +	@Parameter(description = "<input files> (.dex, .apk, .jar or .class)"), +	protected List<String> files;, +, +	@Parameter(names = {"-d", "--output-dir"}, description = "output directory"), +	protected String outDirName;, +, +	@Parameter(names = {"-j", "--threads-count"}, description = "processing threads count"), +	protected int threadsCount = Runtime.getRuntime().availableProcessors();, +, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)", help = true), +	protected boolean fallbackMode = false;, +, +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph"), +	protected boolean cfgOutput = false;, +, +	@Parameter(names = {"--raw-cfg"}, description = "save methods control flow graph (use raw instructions)"), +	protected boolean rawCfgOutput = false;, +, +	@Parameter(names = {"-v", "--verbose"}, description = "verbose output"), +	protected boolean verbose = false;, +, +	@Parameter(names = {"-h", "--help"}, description = "print this help", help = true), +	protected boolean printHelp = false;, +, +	private final List<File> input = new ArrayList<File>();, +	private File outputDir;, +, +	private final boolean inputRequired;, +, +	public JadxArgs(String[] args, boolean inputRequired) {, +		this.inputRequired = inputRequired;, +		parse(args);, +		checkArguments();, +	}, +, +	private void parse(String[] args) {, +		try {, +			new JCommander(this, args);, +		} catch (ParameterException e) {, +			System.out.println("Arguments parse error: " + e.getMessage());, +			System.out.println();, +			printHelp = true;, +		}, +	}, +, +	private void checkArguments() {, +		if (isPrintHelp()) {, +			printUsage();, +			System.exit(0);, +		}, +		if (isVerbose()) {, +			ch.qos.logback.classic.Logger rootLogger =, +					(ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);, +			rootLogger.setLevel(ch.qos.logback.classic.Level.DEBUG);, +		}, +		try {, +			processArgs();, +		} catch (JadxException e) {, +			LOG.error(e.getMessage());, +			System.exit(1);, +		}, +	}, +, +	public void processArgs() throws JadxException {, +		if (printHelp), +			return;, +, +		if (threadsCount <= 0), +			throw new JadxException("Threads count must be positive");, +, +		if (files != null) {, +			for (String fileName : files) {, +				File file = new File(fileName);, +				if (file.exists()), +					input.add(file);, +				else]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile inputFile = new InputFile(file);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(file, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile inputFile = new InputFile(file);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(file, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +				InputFile inputFile = new InputFile(f);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(f, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +				InputFile inputFile = new InputFile(file);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(file, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +				InputFile inputFile = new InputFile(file);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(file, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, +				InputFile inputFile = new InputFile(f);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(f, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +				InputFile inputFile = new InputFile(file);, +				inputFiles.add(inputFile);, +				while (inputFile.nextDexIndex != -1) {, +					inputFile = new InputFile(file, inputFile.nextDexIndex);, +					inputFiles.add(inputFile);, +				}, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +	public int nextDexIndex = -1;, +	private final int dexIndex;, +		this(file, 0);, +	}, +, +	public InputFile(File file, int dexIndex) throws IOException, DecodeException {, +		this.dexIndex = dexIndex;, +			Dex dex = loadFromZip(this,file);, +			Dex dex = loadFromZip(this,file);, +	private static Dex loadFromZip(InputFile ipf, File file) throws IOException {, +		String dexName = "classes.dex";, +		String futureDexName = "classes2.dex";, +		if (ipf.dexIndex != 0) {, +			dexName = "classes" + ipf.dexIndex + ".dex";, +			futureDexName = "classes" + (ipf.dexIndex + 1) + ".dex";, +		}, +		ZipEntry dex = zf.getEntry(dexName);, +		try {, +			ZipEntry futureDex = zf.getEntry(futureDexName);, +			if (futureDex != null) {, +				ipf.nextDexIndex = ipf.dexIndex == 0 ? 2 : ipf.dexIndex + 1;, +			}, +		} catch (Exception ex) {, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +				CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +				CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runBefore = CodeShrinkVisitor.class, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +				CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runBefore = CodeShrinkVisitor.class, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ClassModifier.class, ProcessVariables.class}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +				CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runBefore = CodeShrinkVisitor.class, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ClassModifier.class, ProcessVariables.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = CodeShrinkVisitor.class, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +			passes.add(new CodeShrinkVisitor());, +			passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +				CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runBefore = CodeShrinkVisitor.class, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = {CodeShrinkVisitor.class, ClassModifier.class, ProcessVariables.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +		runAfter = CodeShrinkVisitor.class, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java]
[+++ b/src/main/java/jadx/Consts.java, +package jadx;, +, +public class Consts {, +	public static final String JADX_VERSION = "dev";, +, +	public static final boolean DEBUG = false;, +, +	public static final String CLASS_OBJECT = "java.lang.Object";, +	public static final String CLASS_STRING = "java.lang.String";, +	public static final String CLASS_CLASS = "java.lang.Class";, +	public static final String CLASS_THROWABLE = "java.lang.Throwable";, +	public static final String CLASS_ENUM = "java.lang.Enum";, +}, +++ b/src/main/java/jadx/Consts.java, +package jadx;, +, +public class Consts {, +	public static final String JADX_VERSION = "dev";, +, +	public static final boolean DEBUG = false;, +, +	public static final String CLASS_OBJECT = "java.lang.Object";, +	public static final String CLASS_STRING = "java.lang.String";, +	public static final String CLASS_CLASS = "java.lang.Class";, +	public static final String CLASS_THROWABLE = "java.lang.Throwable";, +	public static final String CLASS_ENUM = "java.lang.Enum";, +}, +++ b/src/main/java/jadx/JadxArgs.java, +package jadx;, +, +import jadx.utils.exceptions.JadxException;, +import jadx.utils.files.InputFile;, +, +import java.io.File;, +import java.io.IOException;, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.Parameter;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +, +public class JadxArgs {, +	private final static Logger LOG = LoggerFactory.getLogger(JadxArgs.class);, +, +	@Parameter(description = "<input files> (.dex, .apk, .jar or .class)", required = true), +	protected List<String> files;, +, +	@Parameter(names = { "-d", "--output-dir" }, description = "output directory"), +	protected String outDirName;, +, +	@Parameter(names = { "-j", "--threads-count" }, description = "processing threads count"), +	protected int threadsCount = Runtime.getRuntime().availableProcessors();, +, +	@Parameter(names = { "-f", "--fallback" }, description = "make simple dump (using goto instead of 'if', 'for', etc)", help = true), +	protected boolean fallbackMode = false;, +, +	@Parameter(names = { "--not-obfuscated" }, description = "set this flag if code not obfuscated"), +	protected boolean notObfuscated = false;, +, +	@Parameter(names = { "--cfg" }, description = "save methods control flow graph"), +	protected boolean cfgOutput = false;, +, +	@Parameter(names = { "--raw-cfg" }, description = "save methods control flow graph (use raw instructions)"), +	protected boolean rawCfgOutput = false;, +, +	@Parameter(names = { "-v", "--verbose" }, description = "verbose output"), +	protected boolean verbose = false;, +, +	@Parameter(names = { "-h", "--help" }, description = "print this help", help = true), +	protected boolean printHelp = false;, +, +	private final List<InputFile> input = new ArrayList<InputFile>();, +	private File outputDir;, +, +	public void parse(String[] args) throws JadxException {, +		try {, +			new JCommander(this, args);, +			processArgs();, +		} catch (ParameterException e) {, +			System.out.println("Arguments parse error: " + e.getMessage());, +			System.out.println();, +			printHelp = true;, +		}, +	}, +, +	private void processArgs() throws JadxException {, +		if (printHelp), +			return;, +, +		if (files == null || files.isEmpty()), +			throw new JadxException("Please specify at least one input file");, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +		if (isEmptySyntheticClass(cls)) {, +	private static boolean isEmptySyntheticClass(ClassNode cls) {, +		return cls.getAccessFlags().isSynthetic(), +				&& cls.getFields().isEmpty(), +				&& cls.getMethods().isEmpty(), +				&& cls.getInnerClasses().isEmpty();, +	}, +, +				if (argCls.contains(AFlag.DONT_GENERATE) || isEmptySyntheticClass(argCls)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +		for (MethodNode mth : cls.getMethods()) {, +				mth.getAttributes().add(AttributeFlag.DONT_GENERATE);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, +	public InsnArg wrapInstruction(InsnNode insn) {, +				InsnArg arg;, +				if (insn.getType() == InsnType.MOVE) {, +					arg = insn.getArg(0);, +				} else {, +					arg = wrap(insn);, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, +	public InsnArg wrapInstruction(InsnNode insn) {, +				InsnArg arg;, +				if (insn.getType() == InsnType.MOVE) {, +					arg = insn.getArg(0);, +				} else {, +					arg = wrap(insn);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +		prettify(mth);, +	private static void prettify(MethodNode mth) {, +			List<InsnNode> list = block.getInstructions();, +			for (int i = 0; i < list.size(); i++) {, +				InsnNode modInsn = pretifyInsn(mth, list.get(i));, +				if (modInsn != null) {, +					list.set(i, modInsn);, +				}, +					try {, +					} catch (Throwable e) {, +						LOG.debug("Can't convert string concatenation: {} insn: {}", mth, insn, e);, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, +	public InsnArg wrapInstruction(InsnNode insn) {, +				InsnArg arg;, +				if (insn.getType() == InsnType.MOVE) {, +					arg = insn.getArg(0);, +				} else {, +					arg = wrap(insn);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +		prettify(mth);, +	private static void prettify(MethodNode mth) {, +			List<InsnNode> list = block.getInstructions();, +			for (int i = 0; i < list.size(); i++) {, +				InsnNode modInsn = pretifyInsn(mth, list.get(i));, +				if (modInsn != null) {, +					list.set(i, modInsn);, +				}, +					try {, +					} catch (Throwable e) {, +						LOG.debug("Can't convert string concatenation: {} insn: {}", mth, insn, e);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +					LiteralArg litArg;, +					if (use.size() == 2) {, +						// arg used only in one place, +						litArg = InsnArg.lit(literal, arg.getType());, +					} else {, +						litArg = InsnArg.lit(literal, ArgType.UNKNOWN);, +					}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +				node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +					LiteralArg litArg;, +					if (use.size() == 2) {, +						// arg used only in one place, +						litArg = InsnArg.lit(literal, arg.getType());, +					} else {, +						litArg = InsnArg.lit(literal, ArgType.UNKNOWN);, +					}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestWrongCode.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestWrongCode extends InternalJadxTest {, +, +	public static class TestCls {, +		private int f() {, +			int[] a = null;, +			return a.length;, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, not(containsString("return false.length;")));, +		assertThat(code, containsString("return null.length;"));, +	}, +}]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-debug-info"}, description = "disable debug info"), +	protected boolean debugInfo = true;, +, +		args.setDebugInfo(debugInfo);, +	public boolean isDebugInfo() {, +		return debugInfo;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-debug-info"}, description = "disable debug info"), +	protected boolean debugInfo = true;, +, +		args.setDebugInfo(debugInfo);, +	public boolean isDebugInfo() {, +		return debugInfo;, +	}, +, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +		assertThat(override(new JadxCLIArgs(), "--no-debug-info").isDebugInfo(), is(false));, +		args.debugInfo = false;, +		assertThat(override(args, "--no-debug-info").isDebugInfo(), is(false));, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-debug-info"}, description = "disable debug info"), +	protected boolean debugInfo = true;, +, +		args.setDebugInfo(debugInfo);, +	public boolean isDebugInfo() {, +		return debugInfo;, +	}, +, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +		assertThat(override(new JadxCLIArgs(), "--no-debug-info").isDebugInfo(), is(false));, +		args.debugInfo = false;, +		assertThat(override(args, "--no-debug-info").isDebugInfo(), is(false));, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean debugInfo = true;, +	public boolean isDebugInfo() {, +		return debugInfo;, +	}, +	, +	public void setDebugInfo(boolean debugInfo) {, +		this.debugInfo = debugInfo;, +	}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--no-debug-info"}, description = "disable debug info"), +	protected boolean debugInfo = true;, +, +		args.setDebugInfo(debugInfo);, +	public boolean isDebugInfo() {, +		return debugInfo;, +	}, +, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +		assertThat(override(new JadxCLIArgs(), "--no-debug-info").isDebugInfo(), is(false));, +		args.debugInfo = false;, +		assertThat(override(args, "--no-debug-info").isDebugInfo(), is(false));, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean debugInfo = true;, +	public boolean isDebugInfo() {, +		return debugInfo;, +	}, +	, +	public void setDebugInfo(boolean debugInfo) {, +		this.debugInfo = debugInfo;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isDebugInfo()) {, +			}]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/build.gradle, +        google(), +++ b/.gitignore, +++ b/build.gradle, +        google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/build.gradle, +        google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/build.gradle, +        google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/build.gradle, +        google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +		code.add(callMth.getAlias());, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/build.gradle, +        google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	private int startUseAddr;, +	private int endUseAddr;, +, +, +		startUseAddr = -1;, +		endUseAddr = -1;, +	public int getStartAddr() {, +		if (startUseAddr == -1) {, +			calcUsageAddrRange();, +		}, +		return startUseAddr;, +	}, +, +	public int getEndAddr() {, +		if (endUseAddr == -1) {, +			calcUsageAddrRange();, +		}, +, +		return endUseAddr;, +	}, +, +	private void calcUsageAddrRange() {, +		int start = Integer.MAX_VALUE;, +		int end = Integer.MIN_VALUE;, +, +		if (assign != null) {, +			if (assign.getParentInsn() != null) {, +				int insnAddr = assign.getParentInsn().getOffset();, +, +				if (insnAddr >= 0) {, +					start = Math.min(insnAddr, start);, +					end = Math.max(insnAddr, end);, +				}, +			}, +		}, +, +		for (RegisterArg arg : useList) {, +			if (arg.getParentInsn() != null) {, +				int insnAddr = arg.getParentInsn().getOffset();, +, +				if (insnAddr >= 0) {, +					start = Math.min(insnAddr, start);, +					end = Math.max(insnAddr, end);, +				}, +			}, +		}, +, +		if ((start != Integer.MAX_VALUE) , +				&& (end != Integer.MIN_VALUE)) {, +			startUseAddr = start;, +			endUseAddr = end;, +		}, +	} , +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +	private int startUseAddr;, +	private int endUseAddr;, +, +, +		startUseAddr = -1;, +		endUseAddr = -1;, +	public int getStartAddr() {, +		if (startUseAddr == -1) {, +			calcUsageAddrRange();, +		}, +		return startUseAddr;, +	}, +, +	public int getEndAddr() {, +		if (endUseAddr == -1) {, +			calcUsageAddrRange();, +		}, +, +		return endUseAddr;, +	}, +, +	private void calcUsageAddrRange() {, +		int start = Integer.MAX_VALUE;, +		int end = Integer.MIN_VALUE;, +, +		if (assign != null) {, +			if (assign.getParentInsn() != null) {, +				int insnAddr = assign.getParentInsn().getOffset();, +, +				if (insnAddr >= 0) {, +					start = Math.min(insnAddr, start);, +					end = Math.max(insnAddr, end);, +				}, +			}, +		}, +, +		for (RegisterArg arg : useList) {, +			if (arg.getParentInsn() != null) {, +				int insnAddr = arg.getParentInsn().getOffset();, +, +				if (insnAddr >= 0) {, +					start = Math.min(insnAddr, start);, +					end = Math.max(insnAddr, end);, +				}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static boolean canRemoveBlock(BlockNode block) {, +		return block.getInstructions().isEmpty(), +				&& block.getSuccessors().size() <= 1, +				&& !block.getPredecessors().isEmpty();, +	}, +, +	private static boolean removeEmptyBlock(BlockNode block) {, +		if (canRemoveBlock(block)) {, +			try {, +			} catch (StackOverflowError e) {, +				throw new JadxOverflowException("Failed compute block dominance frontier");, +			} catch (Exception e) {, +				throw new JadxRuntimeException("Failed compute block dominance frontier", e);, +			}, +		block.getDominatesOn().forEach(domBlock -> computeBlockDF(mth, domBlock));, +			if (removeEmptyBlock(basicBlock)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static boolean canRemoveBlock(BlockNode block) {, +		return block.getInstructions().isEmpty(), +				&& block.getSuccessors().size() <= 1, +				&& !block.getPredecessors().isEmpty();, +	}, +, +	private static boolean removeEmptyBlock(BlockNode block) {, +		if (canRemoveBlock(block)) {, +			try {, +			} catch (StackOverflowError e) {, +				throw new JadxOverflowException("Failed compute block dominance frontier");, +			} catch (Exception e) {, +				throw new JadxRuntimeException("Failed compute block dominance frontier", e);, +			}, +		block.getDominatesOn().forEach(domBlock -> computeBlockDF(mth, domBlock));, +			if (removeEmptyBlock(basicBlock)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestLoopCondition5.java, +package jadx.tests.integration.loops;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static jadx.tests.api.utils.JadxMatchers.countString;, +import static org.hamcrest.Matchers.anyOf;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopCondition5 extends SmaliTest {, +, +	public static class TestCls {, +		private static int lastIndexOf(int[] array, int target, int start, int end) {, +			for (int i = end - 1; i >= start; i--) {, +				if (array[i] == target) {, +					return i;, +				}, +			}, +			return -1;, +		}, +	}, +, +	@Test, +	public void test0() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("for ("));, +		assertThat(code, containsOne("return -1;"));, +		assertThat(code, countString(2, "return "));, +	}, +, +	@Test, +	public void test1() {, +		ClassNode cls = getClassNodeFromSmaliWithPath("loops", "TestLoopCondition5");, +		String code = cls.getCode().toString();, +, +		assertThat(code, anyOf(containsOne("for ("), containsOne("while (true) {")));, +		assertThat(code, containsOne("return -1;"));, +		assertThat(code, countString(2, "return "));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static boolean canRemoveBlock(BlockNode block) {, +		return block.getInstructions().isEmpty(), +				&& block.getSuccessors().size() <= 1, +				&& !block.getPredecessors().isEmpty();, +	}, +, +	private static boolean removeEmptyBlock(BlockNode block) {, +		if (canRemoveBlock(block)) {, +			try {, +			} catch (StackOverflowError e) {, +				throw new JadxOverflowException("Failed compute block dominance frontier");, +			} catch (Exception e) {, +				throw new JadxRuntimeException("Failed compute block dominance frontier", e);, +			}, +		block.getDominatesOn().forEach(domBlock -> computeBlockDF(mth, domBlock));, +			if (removeEmptyBlock(basicBlock)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +	private IRegion body;, +	public IRegion getBody() {, +	public void setBody(IRegion body) {, +	public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +	private IRegion body;, +	public IRegion getBody() {, +	public void setBody(IRegion body) {, +	public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, +		return false;, +	}, +, +	@Override, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.loops.LoopRegion;, +	private static boolean wrapBlocks(IRegion replaceRegion, TryCatchBlock tb, BlockNode dominator) {, +		IRegion region = replaceRegion;, +		if (region instanceof LoopRegion) {, +			LoopRegion loop = (LoopRegion) region;, +			region = loop.getBody();, +		}, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +import jadx.core.dex.nodes.InsnNode;, +import java.util.HashMap;, +import java.util.Map;, +	private static final Map<String, String> OBJ_ALIAS;, +, +	static {, +		OBJ_ALIAS = new HashMap<String, String>();, +		OBJ_ALIAS.put(Consts.CLASS_STRING, "str");, +		OBJ_ALIAS.put(Consts.CLASS_CLASS, "cls");, +		OBJ_ALIAS.put(Consts.CLASS_THROWABLE, "th");, +		OBJ_ALIAS.put(Consts.CLASS_OBJECT, "obj");, +		OBJ_ALIAS.put("java.util.Iterator", "it");, +		OBJ_ALIAS.put("java.lang.Boolean", "bool");, +		OBJ_ALIAS.put("java.lang.Short", "sh");, +		OBJ_ALIAS.put("java.lang.Integer", "num");, +		OBJ_ALIAS.put("java.lang.Character", "ch");, +		OBJ_ALIAS.put("java.lang.Byte", "b");, +		OBJ_ALIAS.put("java.lang.Float", "f");, +		OBJ_ALIAS.put("java.lang.Long", "l");, +		OBJ_ALIAS.put("java.lang.Double", "d");, +	}, +, +			if ("this".equals(name)) {, +			String alias = getAliasForObject(type.getObject());, +			if (alias != null) {, +				return alias;, +			String vName = fromName(shortName);, +			if (vName != null) {, +				return vName;, +, +	private static String fromName(String name) {, +		if (name == null || name.isEmpty()) {, +			return null;, +		}, +		if (name.toUpperCase().equals(name)) {, +			// all characters are upper case, +			return name.toLowerCase();, +		}, +		String v1 = Character.toLowerCase(name.charAt(0)) + name.substring(1);, +		if (!v1.equals(name)) {, +			return v1;, +		}, +		if (name.length() < 3) {, +			return name + "Var";, +		}, +		return null;, +	}, +, +	public static void guessName(RegisterArg arg) {, +		SSAVar sVar = arg.getSVar();, +		if (sVar == null || sVar.getName() != null) {, +			return;, +		}, +		RegisterArg assignArg = sVar.getAssign();, +		InsnNode assignInsn = assignArg.getParentInsn();, +		String name = makeNameFromInsn(assignInsn);, +		if (name != null && !NameMapper.isReserved(name)) {, +			assignArg.setName(name);, +		}, +	}, +, +	public static String getAliasForObject(String name) {, +		return OBJ_ALIAS.get(name);, +	}, +, +	private static String makeNameFromInsn(InsnNode insn) {, +		switch (insn.getType()) {, +			case INVOKE:, +				InvokeNode inv = (InvokeNode) insn;, +				String name = inv.getCallMth().getName();, +				if (name.startsWith("get") || name.startsWith("set")) {, +					return fromName(name.substring(3));, +				}, +				if ("iterator".equals(name)) {, +					return "it";, +				}, +				return name;, +, +			case CONSTRUCTOR:, +				ConstructorInsn co = (ConstructorInsn) insn;, +				return makeNameForObject(co.getClassType().getType());, +, +			case ARRAY_LENGTH:, +				return "length";, +, +			case ARITH:, +			case TERNARY:, +			case CAST:, +				for (InsnArg arg : insn.getArguments()) {, +					if (arg.isInsnWrap()) {, +						InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +						String wName = makeNameFromInsn(wrapInsn);, +						if (wName != null) {, +							return wName;, +						}]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), +	protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return deobfuscationUseSourceNameAsAlias;, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), +	protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return deobfuscationUseSourceNameAsAlias;, +	}, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return false;, +	}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), +	protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return deobfuscationUseSourceNameAsAlias;, +	}, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean useSourceNameAsClassAlias();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), +	protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return deobfuscationUseSourceNameAsAlias;, +	}, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean useSourceNameAsClassAlias();, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	private final boolean useSourceNameAsAlias;, +, +		this.useSourceNameAsAlias = args.useSourceNameAsClassAlias();, +		String alias = null;, +, +		if (this.useSourceNameAsAlias) {, +			alias = getAliasFromSourceFile(cls);, +		}, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), +	protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return deobfuscationUseSourceNameAsAlias;, +	}, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, +	@Override, +	public boolean useSourceNameAsClassAlias() {, +		return false;, +	}, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +, +	boolean useSourceNameAsClassAlias();, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	private final boolean useSourceNameAsAlias;, +, +		this.useSourceNameAsAlias = args.useSourceNameAsClassAlias();, +		String alias = null;, +, +		if (this.useSourceNameAsAlias) {, +			alias = getAliasFromSourceFile(cls);, +		}, +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +	public void setUseSourceNameAsClassAlias(boolean useSourceNameAsAlias) {]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +	private Set<String> getAncestors(String clsName) {, +++ b/.gitignore]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			af = af.remove(AccessFlags.ACC_ABSTRACT), +					.remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			af = af.remove(AccessFlags.ACC_ABSTRACT), +					.remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +			return new AccessInfo(accFlags & ~flag, type);, +		return this;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			af = af.remove(AccessFlags.ACC_ABSTRACT), +					.remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +			return new AccessInfo(accFlags & ~flag, type);, +		return this;, +++ b/jadx-core/src/test/java/jadx/tests/integration/TestClassGen.java, +		public interface I {, +		assertThat(code, containsString("public interface I {"));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			af = af.remove(AccessFlags.ACC_ABSTRACT), +					.remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, +			return new AccessInfo(accFlags & ~flag, type);, +		return this;, +++ b/jadx-core/src/test/java/jadx/tests/integration/TestClassGen.java, +		public interface I {, +		assertThat(code, containsString("public interface I {"));, +++ b/jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotations2.java, +		public @interface A {, +		assertThat(code, containsString("public @interface A {"));]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.Consts;, +				if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, +			if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.Consts;, +				if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, +			if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +import jadx.core.Consts;, +			if (Consts.DEBUG && LOG.isDebugEnabled()) {, +					return !boundType.isTypeKnown() && checkAssignForUnknown(boundType, candidateType);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().add("/*");, +				code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().add(Utils.getStackTrace(e));, +				code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().add("/*");, +				code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().add(Utils.getStackTrace(e));, +				code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getType().toString());, +				break;, +, +			case PHI:, +			case MERGE:, +				fallbackOnlyInsn(insn);, +				code.add(insn.getType().toString()).add("(");, +				for (InsnArg insnArg : insn.getArguments()) {, +					addArg(code, insnArg);, +					code.add(' ');, +				}, +				code.add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().add("/*");, +				code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().add(Utils.getStackTrace(e));, +				code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getType().toString());, +				break;, +, +			case PHI:, +			case MERGE:, +				fallbackOnlyInsn(insn);, +				code.add(insn.getType().toString()).add("(");, +				for (InsnArg insnArg : insn.getArguments()) {, +					addArg(code, insnArg);, +					code.add(' ');, +				}, +				code.add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +					code.newLine().add("Error: ").add(Utils.getStackTrace(cause));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().add("/*");, +				code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().add(Utils.getStackTrace(e));, +				code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getType().toString());, +				break;, +, +			case PHI:, +			case MERGE:, +				fallbackOnlyInsn(insn);, +				code.add(insn.getType().toString()).add("(");, +				for (InsnArg insnArg : insn.getArguments()) {, +					addArg(code, insnArg);, +					code.add(' ');, +				}, +				code.add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +					code.newLine().add("Error: ").add(Utils.getStackTrace(cause));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// merge all arguments in one, +	MERGE,, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				code.newLine().add("/*");, +				code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, +				code.newLine().add(Utils.getStackTrace(e));, +				code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				code.add("new ").add(insn.getResult().getType().toString());, +				break;, +, +			case PHI:, +			case MERGE:, +				fallbackOnlyInsn(insn);, +				code.add(insn.getType().toString()).add("(");, +				for (InsnArg insnArg : insn.getArguments()) {, +					addArg(code, insnArg);, +					code.add(' ');, +				}, +				code.add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +					code.newLine().add("Error: ").add(Utils.getStackTrace(cause));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, +	// merge all arguments in one, +	MERGE,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +		return duplicate(getRegNum(), sVar);, +	}, +, +	public RegisterArg duplicate(int regNum, SSAVar sVar) {, +		RegisterArg dup = new RegisterArg(regNum, getType());, +		if (sVar != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java]
[+++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, +	public static RootNode getRoot(JadxDecompiler d) {, +		return d.getRoot();, +	}, +}, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, +	public static RootNode getRoot(JadxDecompiler d) {, +		return d.getRoot();, +	}, +}, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, +	public static RootNode getRoot(JadxDecompiler d) {, +		return d.getRoot();, +	}, +}, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, +	public static RootNode getRoot(JadxDecompiler d) {, +		return d.getRoot();, +	}, +}, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +package jadx.tests.api;, +, +import jadx.api.JadxInternalAccess;, +import jadx.api.DefaultJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.Jadx;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.FileUtils;, +import jadx.tests.api.utils.TestUtils;, +, +import java.io.File;, +import java.io.FileOutputStream;, +import java.io.IOException;, +import java.net.URISyntaxException;, +import java.net.URL;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.jar.JarOutputStream;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, +, +public abstract class IntegrationTest extends TestUtils {, +, +	protected boolean outputCFG = false;, +	protected boolean isFallback = false;, +	protected boolean deleteTmpFiles = true;, +, +	protected String outDir = "test-out-tmp";, +, +	public ClassNode getClassNode(Class<?> clazz) {, +		try {, +			File jar = getJarForClass(clazz);, +			return getClassNodeFromFile(jar, clazz.getName());]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, +		} catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, +		} catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.IJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +	private final List<File> input = new ArrayList<>(1);, +		Map<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, +		} catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.IJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +	private final List<File> input = new ArrayList<>(1);, +		Map<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import java.util.concurrent.ConcurrentHashMap;, +	private final List<InputFile> inputFiles = new ArrayList<>();, +		try {, +			LOG.error("Save interrupted", e);, +			Thread.currentThread().interrupt();, +	private void appendSourcesSave(ExecutorService executor, File outDir) {, +		for (JavaClass cls : getClasses()) {, +			executor.execute(() -> {, +			List<JavaClass> clsList = new ArrayList<>(classNodeList.size());, +		Map<String, List<JavaClass>> map = new HashMap<>();, +			List<JavaClass> clsList = map.computeIfAbsent(pkg, k -> new ArrayList<>());, +		List<JavaPackage> packages = new ArrayList<>(map.size());, +			pkg.getClasses().sort(Comparator.comparing(JavaClass::getName));, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, +		} catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.IJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +	private final List<File> input = new ArrayList<>(1);, +		Map<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import java.util.concurrent.ConcurrentHashMap;, +	private final List<InputFile> inputFiles = new ArrayList<>();, +		try {, +			LOG.error("Save interrupted", e);, +			Thread.currentThread().interrupt();, +	private void appendSourcesSave(ExecutorService executor, File outDir) {, +		for (JavaClass cls : getClasses()) {, +			executor.execute(() -> {, +			List<JavaClass> clsList = new ArrayList<>(classNodeList.size());, +		Map<String, List<JavaClass>> map = new HashMap<>();, +			List<JavaClass> clsList = map.computeIfAbsent(pkg, k -> new ArrayList<>());, +		List<JavaPackage> packages = new ArrayList<>(map.size());, +			pkg.getClasses().sort(Comparator.comparing(JavaClass::getName));, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +			List<JavaClass> list = new ArrayList<>(inClsCount);, +			List<JavaField> flds = new ArrayList<>(fieldsCount);, +			List<JavaMethod> mths = new ArrayList<>(methodsCount);, +		Map<CodePosition, JavaNode> resultMap = new HashMap<>(map.size());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, +		} catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.IJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;]
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java, +				new ProcessBuilder(), +					.command(new String[] {"rundll32", "url.dll,FileProtocolHandler", url}), +					.start();, +				new ProcessBuilder(), +					.command(new String[] {"open", url}), +					.start();, +				new ProcessBuilder(), +					.command(new String[] {env.get("BROWSER"), url}), +					.start();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		if (!NameMapper.isValidIdentifier(clsName)) {, +			return 'C' + clsName;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		if (!NameMapper.isValidIdentifier(clsName)) {, +			return 'C' + clsName;, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java, +package jadx.tests.integration.names;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.not;, +import static org.junit.Assert.assertThat;, +, +import java.io.File;, +, +public class TestReservedClassNames extends SmaliTest {, +	/*, +		public class do {, +		}, +	*/, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNodeFromSmali("names" + File.separatorChar + "TestReservedClassNames", "do");, +		String code = cls.getCode().toString();, +, +		assertThat(code, not(containsString("public class do")));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		if (!NameMapper.isValidIdentifier(clsName)) {, +			return 'C' + clsName;, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java, +package jadx.tests.integration.names;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.not;, +import static org.junit.Assert.assertThat;, +, +import java.io.File;, +, +public class TestReservedClassNames extends SmaliTest {, +	/*, +		public class do {, +		}, +	*/, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNodeFromSmali("names" + File.separatorChar + "TestReservedClassNames", "do");, +		String code = cls.getCode().toString();, +, +		assertThat(code, not(containsString("public class do")));, +	}, +}, +++ b/jadx-core/src/test/smali/names/TestReservedClassNames.smali, +.class public Ldo;, +.super Ljava/lang/Object;, +, +# direct methods, +.method public constructor <init>()V, +    .locals 0, +, +    .line 3, +    invoke-direct {p0}, Ljava/lang/Object;-><init>()V, +, +    return-void, +.end method]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.InsnUtils;, +		ArgType insnArrayType = insn.getResult().getType();, +		ArgType insnElementType = insnArrayType.getArrayElement();, +		ArgType elType = insn.getElementType();, +		if (!elType.equals(insnElementType) && !insnArrayType.equals(ArgType.OBJECT)) {, +			ErrorsCounter.methodError(mth,, +					"Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()));, +		Object data = insn.getData();, +				byte[] array = (byte[]) data;, +				short[] sarray = (short[]) data;, +				int[] iarray = (int[]) data;, +				long[] larray = (long[]) data;, +		code.add("new ").add(useType(elType)).add("[]{").add(str.toString()).add('}');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.InsnUtils;, +		ArgType insnArrayType = insn.getResult().getType();, +		ArgType insnElementType = insnArrayType.getArrayElement();, +		ArgType elType = insn.getElementType();, +		if (!elType.equals(insnElementType) && !insnArrayType.equals(ArgType.OBJECT)) {, +			ErrorsCounter.methodError(mth,, +					"Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()));, +		Object data = insn.getData();, +				byte[] array = (byte[]) data;, +				short[] sarray = (short[]) data;, +				int[] iarray = (int[]) data;, +				long[] larray = (long[]) data;, +		code.add("new ").add(useType(elType)).add("[]{").add(str.toString()).add('}');, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private ArgType elemType;, +				throw new JadxRuntimeException("Unknown array element width: " + payload.getElementWidthUnit());, +, +		this.data = payload.getData();, +		this.elemType = elType;, +, +	public ArgType getElementType() {, +		return elemType;, +	}, +, +	public void mergeElementType(ArgType foundElemType) {, +		ArgType r = ArgType.merge(elemType, foundElemType);, +		if (r != null) {, +			elemType = r;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.InsnUtils;, +		ArgType insnArrayType = insn.getResult().getType();, +		ArgType insnElementType = insnArrayType.getArrayElement();, +		ArgType elType = insn.getElementType();, +		if (!elType.equals(insnElementType) && !insnArrayType.equals(ArgType.OBJECT)) {, +			ErrorsCounter.methodError(mth,, +					"Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()));, +		Object data = insn.getData();, +				byte[] array = (byte[]) data;, +				short[] sarray = (short[]) data;, +				int[] iarray = (int[]) data;, +				long[] larray = (long[]) data;, +		code.add("new ").add(useType(elType)).add("[]{").add(str.toString()).add('}');, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private ArgType elemType;, +				throw new JadxRuntimeException("Unknown array element width: " + payload.getElementWidthUnit());, +, +		this.data = payload.getData();, +		this.elemType = elType;, +, +	public ArgType getElementType() {, +		return elemType;, +	}, +, +	public void mergeElementType(ArgType foundElemType) {, +		ArgType r = ArgType.merge(elemType, foundElemType);, +		if (r != null) {, +			elemType = r;, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +		if (a.equals(b)), +		if (a == UNKNOWN) {, +		}, +			if (a.isArray()) {, +				if (b.isArray()) {, +					ArgType ea = a.getArrayElement();, +					ArgType eb = b.getArrayElement();, +					if (ea.isPrimitive() && eb.isPrimitive()) {, +						return OBJECT;, +					} else {, +						ArgType res = merge(ea, eb);, +				} else if (b.equals(OBJECT)) {, +					return OBJECT;, +				} else {, +					return null;, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java]
[+++ b/.travis.yml, +sudo: false, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.LinkedList;, +import java.util.Queue;, +	private static class CondStack {, +		private final Queue<IfCondition> stack = new LinkedList<IfCondition>();, +, +		public Queue<IfCondition> getStack() {, +			return stack;, +		}, +, +		public void push(IfCondition cond) {, +			stack.add(cond);, +		}, +, +		public IfCondition pop() {, +			return stack.poll();, +		}, +	}, +, +		add(code, new CondStack(), condition);, +	}, +, +	void wrap(CodeWriter code, IfCondition condition) throws CodegenException {, +		wrap(code, new CondStack(), condition);, +	}, +, +	private void add(CodeWriter code, CondStack stack, IfCondition condition) throws CodegenException {, +		stack.push(condition);, +				addCompare(code, stack, condition.getCompare());, +				addTernary(code, stack, condition);, +				addNot(code, stack, condition);, +				addAndOr(code, stack, condition);, +		stack.pop();, +	private void wrap(CodeWriter code, CondStack stack, IfCondition cond) throws CodegenException {, +		add(code, stack, cond);, +	private void wrap(CodeWriter code, InsnArg firstArg) throws CodegenException {, +		boolean wrap = isArgWrapNeeded(firstArg);, +		if (wrap) {, +			code.add('(');, +		}, +		addArg(code, firstArg, false);, +		if (wrap) {, +			code.add(')');, +		}, +	}, +, +	private void addCompare(CodeWriter code, CondStack stack, Compare compare) throws CodegenException {, +				if (stack.getStack().size() == 1) {, +				} else {, +					wrap(code, firstArg);, +				}, +				wrap(code, firstArg);, +	private void addTernary(CodeWriter code, CondStack stack, IfCondition condition) throws CodegenException {, +		add(code, stack, condition.first());, +		add(code, stack, condition.second());, +		add(code, stack, condition.third());, +	private void addNot(CodeWriter code, CondStack stack, IfCondition condition) throws CodegenException {, +		wrap(code, stack, condition.getArgs().get(0));, +	private void addAndOr(CodeWriter code, CondStack stack, IfCondition condition) throws CodegenException {, +			wrap(code, stack, it.next());, +		if (condition.isCompare()) {, +			return false;, +		}, +		if (condition.getMode() != Mode.NOT) {, +			return true;, +		}, +		return false;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.LinkedList;, +import java.util.Queue;, +	private static class CondStack {, +		private final Queue<IfCondition> stack = new LinkedList<IfCondition>();, +, +		public Queue<IfCondition> getStack() {, +			return stack;, +		}, +, +		public void push(IfCondition cond) {, +			stack.add(cond);, +		}, +, +		public IfCondition pop() {, +			return stack.poll();, +		}, +	}, +, +		add(code, new CondStack(), condition);, +	}, +, +	void wrap(CodeWriter code, IfCondition condition) throws CodegenException {, +		wrap(code, new CondStack(), condition);, +	}, +, +	private void add(CodeWriter code, CondStack stack, IfCondition condition) throws CodegenException {, +		stack.push(condition);, +				addCompare(code, stack, condition.getCompare());, +				addTernary(code, stack, condition);, +				addNot(code, stack, condition);, +				addAndOr(code, stack, condition);, +		stack.pop();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.FieldArg;, +			return mgen.makeArgName((RegisterArg) arg);, +		} else if (arg.isField()) {, +			FieldArg f = (FieldArg) arg;, +			if (f.isStatic()) {, +				return sfield(f.getField());, +			} else {, +				RegisterArg regArg = new RegisterArg(f.getRegNum());, +				regArg.setTypedVar(f.getTypedVar());, +				return ifield(f.getField(), regArg);, +			}, +	public String assignVar(InsnNode insn) throws CodegenException {, +	private String ifield(FieldInfo field, InsnArg arg) throws CodegenException {, +		return arg(arg) + "." + field.getName();, +	private String sfield(FieldInfo field) {, +			case IGET: {, +				FieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) insn).getIndex();, +				code.add(ifield(fieldInfo, insn.getArg(0)));, +			}, +			case IPUT: {, +				FieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) insn).getIndex();, +				code.add(ifield(fieldInfo, insn.getArg(1))).add(" = ").add(arg(insn.getArg(0)));, +			}, +				code.add(sfield((FieldInfo) ((IndexInsnNode) insn).getIndex()));, +				code.add(sfield((FieldInfo) node.getIndex())).add(" = ").add(arg(node.getArg(0)));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.FieldArg;, +			return mgen.makeArgName((RegisterArg) arg);, +		} else if (arg.isField()) {, +			FieldArg f = (FieldArg) arg;, +			if (f.isStatic()) {, +				return sfield(f.getField());, +			} else {, +				RegisterArg regArg = new RegisterArg(f.getRegNum());, +				regArg.setTypedVar(f.getTypedVar());, +				return ifield(f.getField(), regArg);, +			}, +	public String assignVar(InsnNode insn) throws CodegenException {, +	private String ifield(FieldInfo field, InsnArg arg) throws CodegenException {, +		return arg(arg) + "." + field.getName();, +	private String sfield(FieldInfo field) {, +			case IGET: {, +				FieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) insn).getIndex();, +				code.add(ifield(fieldInfo, insn.getArg(0)));, +			}, +			case IPUT: {, +				FieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) insn).getIndex();, +				code.add(ifield(fieldInfo, insn.getArg(1))).add(" = ").add(arg(insn.getArg(0)));, +			}, +				code.add(sfield((FieldInfo) ((IndexInsnNode) insn).getIndex()));, +				code.add(sfield((FieldInfo) node.getIndex())).add(" = ").add(arg(node.getArg(0)));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +package jadx.core.dex.instructions.args;, +, +import jadx.core.dex.info.FieldInfo;, +, +public final class FieldArg extends RegisterArg {, +, +	private final FieldInfo field;, +, +	public FieldArg(FieldInfo field, int regNum) {, +		super(regNum, field.getType());, +		this.field = field;, +	}, +, +	public FieldInfo getField() {, +		return field;, +	}, +, +	public boolean isStatic() {, +		return regNum == -1;, +	}, +, +	@Override, +	public boolean isField() {, +		return true;, +	}, +, +	@Override, +	public boolean isRegister() {, +		return false;, +	}, +, +	@Override, +	public String toString() {, +		return "(" + field + ")";, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.FieldArg;, +			return mgen.makeArgName((RegisterArg) arg);, +		} else if (arg.isField()) {, +			FieldArg f = (FieldArg) arg;, +			if (f.isStatic()) {, +				return sfield(f.getField());, +			} else {, +				RegisterArg regArg = new RegisterArg(f.getRegNum());, +				regArg.setTypedVar(f.getTypedVar());, +				return ifield(f.getField(), regArg);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +				// all args must be registers passed from method args (allow only casts insns), +				for (InsnArg arg : insn.getArguments()) {, +					if (!registersAndCastsOnly(arg)) {, +						return false;, +					}, +				}, +	private static boolean registersAndCastsOnly(InsnArg arg) {, +		if (arg.isRegister()) {, +			return true;, +		}, +		if (arg.isInsnWrap()) {, +			InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +			if (wrapInsn.getType() == InsnType.CHECK_CAST) {, +				return registersAndCastsOnly(wrapInsn.getArg(0));, +			}, +		}, +		return false;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +		if(c >= 0 && c <= 0x1F) {, +			return "\\" + (int) c;, +		}, +			case '\\':, +				return "\\\\";]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +			passes.add(new DebugInfoParseVisitor());, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new ConstructorVisitor());, +			passes.add(new TypeInferenceVisitor());, +			passes.add(new DebugInfoApplyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<>());, +	public boolean isClsKnown(String fullName) {, +		return nameMap.containsKey(fullName);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				String arrStr = arrayNode.dataToString();, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments == null || arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +			out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +			out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case MOVE_EXCEPTION:, +				assert isFallback();, +				code.add("move-exception");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +			out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case MOVE_EXCEPTION:, +				assert isFallback();, +				code.add("move-exception");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +import jadx.core.dex.regions.TryCatchRegion;, +				} else if (cont instanceof TryCatchRegion) {, +					makeTryCatch((TryCatchRegion) cont, code);, +	private void makeTryCatch(TryCatchRegion region, CodeWriter code) throws CodegenException {, +		TryCatchBlock tryCatchBlock = region.geTryCatchBlock();, +		makeRegionIndent(code, region.getTryRegion());, +		// TODO: move search of 'allHandler' to 'TryCatchRegion', +	private void makeCatchBlock(CodeWriter code, ExceptionHandler handler) throws CodegenException {, +		if (region == null) {, +			return;, +		}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			declareVar(code, (RegisterArg) arg);, +		} else if (arg instanceof NamedArg) {, +			code.add(mgen.getNameGen().assignNamedArg((NamedArg) arg));, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +			out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case MOVE_EXCEPTION:, +				assert isFallback();, +				code.add("move-exception");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +import jadx.core.dex.regions.TryCatchRegion;, +				} else if (cont instanceof TryCatchRegion) {, +					makeTryCatch((TryCatchRegion) cont, code);, +	private void makeTryCatch(TryCatchRegion region, CodeWriter code) throws CodegenException {, +		TryCatchBlock tryCatchBlock = region.geTryCatchBlock();, +		makeRegionIndent(code, region.getTryRegion());, +		// TODO: move search of 'allHandler' to 'TryCatchRegion', +	private void makeCatchBlock(CodeWriter code, ExceptionHandler handler) throws CodegenException {, +		if (region == null) {, +			return;, +		}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			declareVar(code, (RegisterArg) arg);, +		} else if (arg instanceof NamedArg) {, +			code.add(mgen.getNameGen().assignNamedArg((NamedArg) arg));, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +						InsnArg.reg(insn, 0, ArgType.unknown(PrimitiveType.OBJECT)));, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +			out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			case MOVE_EXCEPTION:, +				assert isFallback();, +				code.add("move-exception");, +				break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +import jadx.core.dex.regions.TryCatchRegion;, +				} else if (cont instanceof TryCatchRegion) {, +					makeTryCatch((TryCatchRegion) cont, code);, +	private void makeTryCatch(TryCatchRegion region, CodeWriter code) throws CodegenException {, +		TryCatchBlock tryCatchBlock = region.geTryCatchBlock();, +		makeRegionIndent(code, region.getTryRegion());, +		// TODO: move search of 'allHandler' to 'TryCatchRegion', +	private void makeCatchBlock(CodeWriter code, ExceptionHandler handler) throws CodegenException {, +		if (region == null) {, +			return;, +		}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			declareVar(code, (RegisterArg) arg);, +		} else if (arg instanceof NamedArg) {, +			code.add(mgen.getNameGen().assignNamedArg((NamedArg) arg));, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +						InsnArg.reg(insn, 0, ArgType.unknown(PrimitiveType.OBJECT)));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +	public static TypeImmutableArg typeImmutableReg(int regNum, ArgType type) {, +		return new TypeImmutableArg(regNum, type);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +			out.println(code);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +		int argAndType = readByte();, +				return (char) parseUnsignedInt(size);, +, +				return Float.intBitsToFloat((int) parseNumber(size, false, 4));, +				return Double.longBitsToDouble(parseNumber(size, false, 8));, +				return dex.getString(parseUnsignedInt(size));, +				return dex.getType(parseUnsignedInt(size));, +				return MethodInfo.fromDex(dex, parseUnsignedInt(size));, +				return FieldInfo.fromDex(dex, parseUnsignedInt(size));, +	private int parseUnsignedInt(int byteCount) {, +		return (int) parseNumber(byteCount, false, 0);, +, +	private long parseNumber(int byteCount, boolean isSignExtended) {, +		return parseNumber(byteCount, isSignExtended, 0);, +	}, +, +	private long parseNumber(int byteCount, boolean isSignExtended, int fillOnRight) {, +		long result = 0;, +		long last = 0;, +		for (int i = 0; i < byteCount; i++) {, +			last = readByte();, +			result |= last << i * 8;, +		}, +		if (fillOnRight != 0) {, +			for (int i = byteCount; i < fillOnRight; i++) {, +				result <<= 8;, +			}, +		} else {, +			if (isSignExtended && (last & 0x80) != 0) {, +				for (int i = byteCount; i < 8; i++) {, +					result |= (long) 0xFF << i * 8;, +				}, +			}, +, +	private int readByte() {, +		return in.readByte() & 0xFF;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +		int argAndType = readByte();, +				return (char) parseUnsignedInt(size);, +, +				return Float.intBitsToFloat((int) parseNumber(size, false, 4));, +				return Double.longBitsToDouble(parseNumber(size, false, 8));, +				return dex.getString(parseUnsignedInt(size));, +				return dex.getType(parseUnsignedInt(size));, +				return MethodInfo.fromDex(dex, parseUnsignedInt(size));, +				return FieldInfo.fromDex(dex, parseUnsignedInt(size));, +	private int parseUnsignedInt(int byteCount) {, +		return (int) parseNumber(byteCount, false, 0);, +, +	private long parseNumber(int byteCount, boolean isSignExtended) {, +		return parseNumber(byteCount, isSignExtended, 0);, +	}, +, +	private long parseNumber(int byteCount, boolean isSignExtended, int fillOnRight) {, +		long result = 0;, +		long last = 0;, +		for (int i = 0; i < byteCount; i++) {, +			last = readByte();, +			result |= last << i * 8;, +		}, +		if (fillOnRight != 0) {, +			for (int i = byteCount; i < fillOnRight; i++) {, +				result <<= 8;, +			}, +		} else {, +			if (isSignExtended && (last & 0x80) != 0) {, +				for (int i = byteCount; i < 8; i++) {, +					result |= (long) 0xFF << i * 8;, +				}, +			}, +, +	private int readByte() {, +		return in.readByte() & 0xFF;, +	}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestAnnotations.java, +		public void methodA1() {, +		}, +, +		@A(a = -253), +		public void methodA2() {, +		}, +, +		@A(a = -11253), +		public void methodA3() {, +		public void methodV() {, +		public void methodD() {, +		System.out.println(code);, +		assertThat(code, containsString("@A(a = -253)"));, +		assertThat(code, containsString("@A(a = -11253)"));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, +		int argAndType = readByte();, +				return (char) parseUnsignedInt(size);, +, +				return Float.intBitsToFloat((int) parseNumber(size, false, 4));, +				return Double.longBitsToDouble(parseNumber(size, false, 8));, +				return dex.getString(parseUnsignedInt(size));, +				return dex.getType(parseUnsignedInt(size));, +				return MethodInfo.fromDex(dex, parseUnsignedInt(size));]
[+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java, +package jadx.tests.integration.enums;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import jadx.tests.api.utils.JadxMatchers;, +import org.junit.Test;, +, +import static org.junit.Assert.assertThat;, +, +public class TestEnumsInterface extends IntegrationTest {, +, +	public static class TestCls {, +, +		public enum Operation implements IOperation {, +			PLUS {, +				public int apply(int x, int y) {, +					return x + y;, +				}, +			},, +			MINUS {, +				public int apply(int x, int y) {, +					return x - y;, +				}, +			};, +		}, +, +		public interface IOperation {, +			int apply(int x, int y);, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, JadxMatchers.containsLines(1,, +				"public enum Operation implements IOperation {",, +				indent(1) + "PLUS {",, +				indent(2) + "public int apply(int x, int y) {",, +				indent(3) + "return x + y;",, +				indent(2) + "}",, +				indent(1) + "},",, +				indent(1) + "MINUS {",, +				indent(2) + "public int apply(int x, int y) {",, +				indent(3) + "return x - y;",, +				indent(2) + "}",, +				indent(1) + "}",, +				"}", +		));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private int[] resourceIds;, +		int size = is.readInt32();, +		int len = (size - 8) / 4;, +		resourceIds = new int[len];, +		for (int i = 0; i < len; i++) {, +			resourceIds[i] = is.readInt32();, +		nsMap.computeIfAbsent(getString(beginURI), k -> getString(beginPrefix));, +		nsMap.computeIfAbsent(getString(endURI), k -> getString(endPrefix));, +		String str = getString(strIndex);, +		currentTag = getString(startNSName);, +			writer.add(getAttributeNS(attributeNS)).add(':');, +		String attrName = getAttributeName(attributeName);, +	private String getAttributeNS(int attributeNS) {, +		String attrUrl = getString(attributeNS);, +		if (attrUrl == null || attrUrl.isEmpty()) {, +			if (isResInternalId(attributeNS)) {, +				return null;, +			} else {, +				attrUrl = ANDROID_NS_URL;, +			}, +		}, +		String attrName = nsMap.get(attrUrl);, +		if (attrName == null) {, +			return "NOT_FOUND_NS_0x" + Integer.toHexString(attributeNS) + "_" + attrUrl;, +		}, +		return attrName;, +	}, +, +	private String getAttributeName(int id) {, +		String str = getString(id);, +		if (str == null || str.isEmpty()) {, +			int resId = resourceIds[id];, +			str = ValuesParser.getAndroidResMap().get(resId);, +			if (str == null) {, +				return "NOT_FOUND_0x" + Integer.toHexString(id);, +			}, +			// cut type before /, +			int typeEnd = str.indexOf('/');, +			if (typeEnd != -1) {, +				return str.substring(typeEnd + 1);, +			}, +			return str;, +		}, +		return str;, +	}, +, +	private String getString(int strId) {, +		if (0 <= strId && strId < strings.length) {, +			return strings[strId];, +		}, +		return "NOT_FOUND_STR_0x" + Integer.toHexString(strId);, +	}, +, +					writer.add(getAttributeNS(attributeNS)).add(':');, +		if (currentTag.equals(getString(elementName)) && isOneLine && !isLastEnd) {, +				writer.add(getString(elementNS)).add(':');, +			writer.add(getString(elementName)).add(">");, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private int[] resourceIds;, +		int size = is.readInt32();, +		int len = (size - 8) / 4;, +		resourceIds = new int[len];, +		for (int i = 0; i < len; i++) {, +			resourceIds[i] = is.readInt32();, +		nsMap.computeIfAbsent(getString(beginURI), k -> getString(beginPrefix));, +		nsMap.computeIfAbsent(getString(endURI), k -> getString(endPrefix));, +		String str = getString(strIndex);, +		currentTag = getString(startNSName);, +			writer.add(getAttributeNS(attributeNS)).add(':');, +		String attrName = getAttributeName(attributeName);, +	private String getAttributeNS(int attributeNS) {, +		String attrUrl = getString(attributeNS);, +		if (attrUrl == null || attrUrl.isEmpty()) {, +			if (isResInternalId(attributeNS)) {, +				return null;, +			} else {, +				attrUrl = ANDROID_NS_URL;, +			}, +		}, +		String attrName = nsMap.get(attrUrl);, +		if (attrName == null) {, +			return "NOT_FOUND_NS_0x" + Integer.toHexString(attributeNS) + "_" + attrUrl;, +		}, +		return attrName;, +	}, +, +	private String getAttributeName(int id) {, +		String str = getString(id);, +		if (str == null || str.isEmpty()) {, +			int resId = resourceIds[id];, +			str = ValuesParser.getAndroidResMap().get(resId);, +			if (str == null) {, +				return "NOT_FOUND_0x" + Integer.toHexString(id);, +			}, +			// cut type before /, +			int typeEnd = str.indexOf('/');, +			if (typeEnd != -1) {, +				return str.substring(typeEnd + 1);, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	public void forceRenameField(FieldNode field) {, +		field.getFieldInfo().setAlias(makeFieldAlias(field));, +	}, +, +	public void forceRenameMethod(MethodNode mth) {, +		mth.getMethodInfo().setAlias(makeMethodAlias(mth));, +		if (mth.isVirtual()) {, +			resolveOverriding(mth);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	public void forceRenameField(FieldNode field) {, +		field.getFieldInfo().setAlias(makeFieldAlias(field));, +	}, +, +	public void forceRenameMethod(MethodNode mth) {, +		mth.getMethodInfo().setAlias(makeMethodAlias(mth));, +		if (mth.isVirtual()) {, +			resolveOverriding(mth);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +	public boolean equalsNameAndType(FieldInfo other) {, +		return name.equals(other.name) && type.equals(other.type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	public void forceRenameField(FieldNode field) {, +		field.getFieldInfo().setAlias(makeFieldAlias(field));, +	}, +, +	public void forceRenameMethod(MethodNode mth) {, +		mth.getMethodInfo().setAlias(makeMethodAlias(mth));, +		if (mth.isVirtual()) {, +			resolveOverriding(mth);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +	public boolean equalsNameAndType(FieldInfo other) {, +		return name.equals(other.name) && type.equals(other.type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +	public FieldNode searchFieldByNameAndType(FieldInfo field) {, +		for (FieldNode f : fields) {, +			if (f.getFieldInfo().equalsNameAndType(field)) {, +				return f;, +			}, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	public void forceRenameField(FieldNode field) {, +		field.getFieldInfo().setAlias(makeFieldAlias(field));, +	}, +, +	public void forceRenameMethod(MethodNode mth) {, +		mth.getMethodInfo().setAlias(makeMethodAlias(mth));, +		if (mth.isVirtual()) {, +			resolveOverriding(mth);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +	public boolean equalsNameAndType(FieldInfo other) {, +		return name.equals(other.name) && type.equals(other.type);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +	public FieldNode searchFieldByNameAndType(FieldInfo field) {, +		for (FieldNode f : fields) {, +			if (f.getFieldInfo().equalsNameAndType(field)) {, +				return f;, +			}, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		FieldNode field = cls.searchFieldByNameAndType(fieldInfo);, +				FieldNode found = deepResolveField(superNode, fieldInfo);, +				FieldNode found = deepResolveField(iFaceNode, fieldInfo);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +	public void forceRenameField(FieldNode field) {, +		field.getFieldInfo().setAlias(makeFieldAlias(field));, +	}, +, +	public void forceRenameMethod(MethodNode mth) {, +		mth.getMethodInfo().setAlias(makeMethodAlias(mth));, +		if (mth.isVirtual()) {, +			resolveOverriding(mth);, +		}, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java]
[+++ b/.gitignore, +classes/, +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.13.jar'), +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.13.jar'), +++ b/jadx-core/lib/dx-1.13.jar, +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.13.jar'), +++ b/jadx-core/lib/dx-1.13.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java, +import com.android.dx.command.dexer.DxContext;, +import jadx.core.utils.exceptions.JadxException;, +, +		ByteArrayOutputStream out = new ByteArrayOutputStream();, +			DxContext context = new DxContext(out, errOut);, +			int result = (new Main(context)).runDx(args);, +			if (result != 0) {, +				throw new JadxException("Java to dex conversion error, code: " + result);, +			}, +			dxErrors = errOut.toString(CHARSET_NAME);, +			return out.toByteArray();, +		} catch (Exception e) {, +			close(out);, +			close(errOut);]
[+++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		StringBuilder signature = new StringBuilder();, +		signature.append(name);, +		signature.append('(');, +		for (ArgType arg : args) {, +			signature.append(TypeGen.signature(arg));, +		}, +		signature.append(')');, +		signature.append(TypeGen.signature(retType));, +		shortId = signature.toString();, +		return declClass.getFullName() + "." + name, +				+ "(" + Utils.listToString(args) + "):" + retType;, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		StringBuilder signature = new StringBuilder();, +		signature.append(name);, +		signature.append('(');, +		for (ArgType arg : args) {, +			signature.append(TypeGen.signature(arg));, +		}, +		signature.append(')');, +		signature.append(TypeGen.signature(retType));, +		shortId = signature.toString();, +		return declClass.getFullName() + "." + name, +				+ "(" + Utils.listToString(args) + "):" + retType;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		return parentClass.getFullName() + "." + mthInfo.getName(), +				+ "(" + Utils.listToString(mthInfo.getArgumentsTypes()) + "):", +				+ retType;, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		StringBuilder signature = new StringBuilder();, +		signature.append(name);, +		signature.append('(');, +		for (ArgType arg : args) {, +			signature.append(TypeGen.signature(arg));, +		}, +		signature.append(')');, +		signature.append(TypeGen.signature(retType));, +		shortId = signature.toString();, +		return declClass.getFullName() + "." + name, +				+ "(" + Utils.listToString(args) + "):" + retType;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		return parentClass.getFullName() + "." + mthInfo.getName(), +				+ "(" + Utils.listToString(mthInfo.getArgumentsTypes()) + "):", +				+ retType;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.codegen.TypeGen;, +import jadx.core.dex.instructions.args.ArgType;, +		if (!cls.isEnum()) {, +		}, +		ArgType clsType = cls.getClassInfo().getType();, +		String enumConstructor = "<init>(Ljava/lang/String;I)V";, +		String valuesOfMethod = "valueOf(Ljava/lang/String;)" + TypeGen.signature(clsType);, +		String valuesMethod = "values()" + TypeGen.signature(ArgType.array(clsType));, +, +			} else {, +				String shortId = mi.getShortId();, +				boolean isSynthetic = mth.getAccessFlags().isSynthetic();, +				if (mi.isConstructor() && !isSynthetic) {, +					if (shortId.equals(enumConstructor)) {, +					}, +				} else if (isSynthetic, +						|| shortId.equals(valuesMethod), +						|| shortId.equals(valuesOfMethod)) {, +		}, +					if (i == size - 1) {, +					} else {, +					}, +				if (insn.getArgsCount() < 2) {, +				}, +				if (constrCls == null) {, +				}, +				if (!clsInfo.equals(cls.getClassInfo()) && !constrCls.getAccessFlags().isEnum()) {, +				}, +						if (constrArg == null) {, +					}, +								if (innerMth.getAccessFlags().isConstructor()) {, +							}, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		StringBuilder signature = new StringBuilder();, +		signature.append(name);, +		signature.append('(');, +		for (ArgType arg : args) {, +			signature.append(TypeGen.signature(arg));, +		}, +		signature.append(')');]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.utils.Utils;, +		if (Consts.DEBUG) {, +			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.utils.Utils;, +		if (Consts.DEBUG) {, +			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import com.android.dx.rop.code.AccessFlags;, +, +		runAfter = {, +				ModVisitor.class,, +				FixAccessModifiers.class, +		}, +				AccessInfo wrappedAccFlags = wrappedMth.getAccessFlags();, +				if (wrappedAccFlags.isStatic()) {, +					return false;, +				}, +				if (!wrappedAccFlags.isPublic()) {, +					// must be public, +					FixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.utils.Utils;, +		if (Consts.DEBUG) {, +			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import com.android.dx.rop.code.AccessFlags;, +, +		runAfter = {, +				ModVisitor.class,, +				FixAccessModifiers.class, +		}, +				AccessInfo wrappedAccFlags = wrappedMth.getAccessFlags();, +				if (wrappedAccFlags.isStatic()) {, +					return false;, +				}, +				if (!wrappedAccFlags.isPublic()) {, +					// must be public, +					FixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java, +		int newVisFlag = fixVisibility(mth);, +			changeVisibility(mth, newVisFlag);, +	public static void changeVisibility(MethodNode mth, int newVisFlag) {, +		AccessInfo accessFlags = mth.getAccessFlags();, +		AccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);, +		if (newAccFlags != accessFlags) {, +			mth.setAccFlags(newAccFlags);, +			mth.addAttr(AType.COMMENTS, "access modifiers changed from: " + accessFlags.rawString());, +		}, +	}, +, +	private static int fixVisibility(MethodNode mth) {, +			AccessInfo accessFlags = mth.getAccessFlags();, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.utils.Utils;, +		if (Consts.DEBUG) {, +			code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import com.android.dx.rop.code.AccessFlags;, +, +		runAfter = {, +				ModVisitor.class,, +				FixAccessModifiers.class, +		}, +				AccessInfo wrappedAccFlags = wrappedMth.getAccessFlags();, +				if (wrappedAccFlags.isStatic()) {, +					return false;, +				}, +				if (!wrappedAccFlags.isPublic()) {, +					// must be public, +					FixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/FixAccessModifiers.java, +		int newVisFlag = fixVisibility(mth);, +			changeVisibility(mth, newVisFlag);, +	public static void changeVisibility(MethodNode mth, int newVisFlag) {, +		AccessInfo accessFlags = mth.getAccessFlags();, +		AccessInfo newAccFlags = accessFlags.changeVisibility(newVisFlag);, +		if (newAccFlags != accessFlags) {, +			mth.setAccFlags(newAccFlags);, +			mth.addAttr(AType.COMMENTS, "access modifiers changed from: " + accessFlags.rawString());, +		}, +	}, +, +	private static int fixVisibility(MethodNode mth) {, +			AccessInfo accessFlags = mth.getAccessFlags();, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInner2Samples.java, +package jadx.tests.integration.inner;]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ClassNode superClass = cls.getSuperClassNode();, +				collectClassHierarchy(superClass, collected);, +			for (ClassNode interfaceNode : cls.getInterfaceNodes()) {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ClassNode superClass = cls.getSuperClassNode();, +				collectClassHierarchy(superClass, collected);, +			for (ClassNode interfaceNode : cls.getInterfaceNodes()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dx.io.instructions.DecodedInstruction;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ClassNode superClass = cls.getSuperClassNode();, +				collectClassHierarchy(superClass, collected);, +			for (ClassNode interfaceNode : cls.getInterfaceNodes()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dx.io.instructions.DecodedInstruction;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.ClassData;, +import com.android.dex.FieldId;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +		FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, +		if (fieldNode == null) {, +		} else {, +			code.add(fieldNode.getAlias());, +		}, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +			ClassNode superClass = cls.getSuperClassNode();, +				collectClassHierarchy(superClass, collected);, +			for (ClassNode interfaceNode : cls.getInterfaceNodes()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +		// remove public empty constructors (static or default), +				&& mth.getArguments(false).isEmpty()) {, +				if (af.isStatic() && mth.getMethodInfo().isClassInit()) {, +					mth.add(AFlag.DONT_GENERATE);, +				} else {, +					// don't remove default constructor if other constructors exists, +					if (mth.isDefaultConstructor() && !isNonDefaultConstructorExists(mth)) {, +	}, +, +	private static boolean isNonDefaultConstructorExists(MethodNode defCtor) {, +		ClassNode parentClass = defCtor.getParentClass();, +		for (MethodNode mth : parentClass.getMethods()) {, +			if (mth != defCtor, +					&& mth.getAccessFlags().isConstructor(), +					&& mth.getMethodInfo().isConstructor(), +					&& !mth.isDefaultConstructor()) {, +				return true;, +			}, +		}, +		return false;, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +		// remove public empty constructors (static or default), +				&& mth.getArguments(false).isEmpty()) {, +				if (af.isStatic() && mth.getMethodInfo().isClassInit()) {, +					mth.add(AFlag.DONT_GENERATE);, +				} else {, +					// don't remove default constructor if other constructors exists, +					if (mth.isDefaultConstructor() && !isNonDefaultConstructorExists(mth)) {, +	}, +, +	private static boolean isNonDefaultConstructorExists(MethodNode defCtor) {, +		ClassNode parentClass = defCtor.getParentClass();, +		for (MethodNode mth : parentClass.getMethods()) {, +			if (mth != defCtor, +					&& mth.getAccessFlags().isConstructor(), +					&& mth.getMethodInfo().isConstructor(), +					&& !mth.isDefaultConstructor()) {, +				return true;, +			}, +		}, +		return false;, +	}, +}, +++ b/jadx-core/src/test/java/jadx/tests/integration/others/TestDefConstructorNotRemoved.java, +package jadx.tests.integration.others;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestDefConstructorNotRemoved extends IntegrationTest {, +, +	public static class TestCls {, +, +		static {, +			// empty, +		}, +, +		public static class A {, +			private final String s;, +, +			public A() {, +				s = "a";, +			}, +, +			public A(String str) {, +				s = str;, +			}, +		}, +, +		public static class B extends A {, +			public B() {, +				super();, +			}, +, +			public B(String s) {, +				super(s);, +			}, +		}, +, +		public void check() {, +			new A();, +			new A("a");, +			new B();, +			new B("b");, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +			passes.add(new CodeShrinker());, +, +			passes.add(new CodeShrinker());, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +		return parents.toArray(new NClass[parents.size()]);, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.instructions.args.RegisterArg;, +import org.jetbrains.annotations.Nullable;, +			return castConstructorInsn(((InsnWrapArg) arg).getWrapInsn());, +		if (arg.isRegister()) {, +			return castConstructorInsn(((RegisterArg) arg).getAssignInsn());, +		}, +		return null;, +	}, +, +	@Nullable, +	private ConstructorInsn castConstructorInsn(InsnNode coCandidate) {, +		if (coCandidate != null && coCandidate.getType() == InsnType.CONSTRUCTOR) {, +			return (ConstructorInsn) coCandidate;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +, +/* TODO:, +	Don't die when error occurs, +	Check error cases, maybe checked const values are not always the same, +	Better error messages, +	What to do, when Binary XML Manifest is > size(int)?, +	Check for missung chunk size types, +	Implement missing data types, +	Use linenumbers to recreate EXACT AndroidManifest, +	Check Element chunk size, +*/, +	private PrintWriter writer;, +	private Map<Integer, String> styleMap = null;, +, +		count+=4; // TODO: Check element chunk size, +				// FIXME: What to do, when data is always -1?]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +import java.io.IOException;, +	private static boolean isInSubDirectoryInternal(File baseDir, File canonFile) {, +		if (canonFile == null) {, +		if (canonFile.equals(baseDir)) {, +		return isInSubDirectoryInternal(baseDir, canonFile.getParentFile());, +	}, +	, +	public static boolean isInSubDirectory(File baseDir, File file) {, +		try {, +			file = file.getCanonicalFile();, +		}, +		catch(IOException e) {, +			return false;, +		}, +		return isInSubDirectoryInternal(baseDir, file);, +			if (isInSubDirectoryInternal(currentPath, canonical)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +import java.io.IOException;, +	private static boolean isInSubDirectoryInternal(File baseDir, File canonFile) {, +		if (canonFile == null) {, +		if (canonFile.equals(baseDir)) {, +		return isInSubDirectoryInternal(baseDir, canonFile.getParentFile());, +	}, +	, +	public static boolean isInSubDirectory(File baseDir, File file) {, +		try {, +			file = file.getCanonicalFile();, +		}, +		catch(IOException e) {, +			return false;, +		}, +		return isInSubDirectoryInternal(baseDir, file);, +			if (isInSubDirectoryInternal(currentPath, canonical)) {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java, +import jadx.core.utils.files.ZipSecurity;, +				, +				if(!ZipSecurity.isInSubDirectory(outDir, outFile)) {, +					LOG.error("Path traversal attack detected, invalid resource name: {}",, +							outFile.getPath());, +					return;, +				}, +				, +		, +		if(!ZipSecurity.isInSubDirectory(outDir, outFile)) {, +			LOG.error("Path traversal attack detected, invalid resource name: {}",, +					rc.getFileName());, +			return;, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		int importsCount = imports.size();, +		if (importsCount != 0) {, +			List<String> sortImports = new ArrayList<String>(importsCount);, +			for (ClassInfo ic : imports) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		int importsCount = imports.size();, +		if (importsCount != 0) {, +			List<String> sortImports = new ArrayList<String>(importsCount);, +			for (ClassInfo ic : imports) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		return fullName;, +		return fullName.hashCode();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +						// print original value, sometimes replace with incorrect field, +						FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, +						if (valueAttr != null && valueAttr.getValue() != null) {, +							code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, +					}, +				} else if (k instanceof Integer) {, +				} else {, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +						// print original value, sometimes replace with incorrect field, +						FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, +						if (valueAttr != null && valueAttr.getValue() != null) {, +							code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, +					}, +				} else if (k instanceof Integer) {, +				} else {, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +								sn.getKeys()[k] = f;, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +						// print original value, sometimes replace with incorrect field, +						FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, +						if (valueAttr != null && valueAttr.getValue() != null) {, +							code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, +					}, +				} else if (k instanceof Integer) {, +				} else {, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +								sn.getKeys()[k] = f;, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchLabels.java, +		assertThat(code, containsString("case CONST_ABC"));, +		assertThat(code, containsString("case CONST_CDE_PRIVATE"));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +						// print original value, sometimes replace with incorrect field, +						FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, +						if (valueAttr != null && valueAttr.getValue() != null) {, +							code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, +					}, +				} else if (k instanceof Integer) {, +				} else {, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +								sn.getKeys()[k] = f;, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchLabels.java, +		assertThat(code, containsString("case CONST_ABC"));, +		assertThat(code, containsString("case CONST_CDE_PRIVATE"));, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java, +	@SuppressWarnings("fallthrough"), +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +						// print original value, sometimes replace with incorrect field, +						FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, +						if (valueAttr != null && valueAttr.getValue() != null) {, +							code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, +					}, +				} else if (k instanceof Integer) {, +				} else {, +					throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +								sn.getKeys()[k] = f;, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchLabels.java, +		assertThat(code, containsString("case CONST_ABC"));, +		assertThat(code, containsString("case CONST_CDE_PRIVATE"));, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java, +	@SuppressWarnings("fallthrough"), +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase2.java, +	@SuppressWarnings("fallthrough")]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				ClassInfo importClassInfo = ClassInfo.fromName(cls.dex().root(), imp);, +				ClassNode classNode = cls.dex().resolveClass(importClassInfo);, +				// Clickable element seems to be limited by the next dot, therefore, +				// we can't just use the complete class name including packagename, +				int clsDotIdx = imp.lastIndexOf('.');, +				String pkg = "";, +				if (clsDotIdx >= 0) {, +					pkg = imp.substring(0, clsDotIdx + 1);, +					imp = imp.substring(clsDotIdx + 1);, +				}, +				clsCode.startLine("import ");, +				clsCode.add(pkg);, +				if (classNode != null) {, +					// attach the clickable link info to the class name, +					clsCode.attachAnnotation(classNode);, +				}, +				clsCode.add(imp);, +				clsCode.add(';');]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +package jadx.core.xmlgen;, +, +import java.nio.ByteBuffer;, +import java.nio.charset.Charset;, +import java.io.BufferedInputStream;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.InputStream;, +import java.io.IOException;, +import java.io.UnsupportedEncodingException;, +, +public class BinaryXMLParser {, +	private byte[] bytes;, +	private String[] strings;, +	private int count;, +	private String nsPrefix="ERROR";, +	public BinaryXMLParser(String xmlfilepath) {, +		System.out.println(xmlfilepath);, +		File manifest = new File(xmlfilepath);, +		if(null==manifest) die("null==manifest");, +		bytes = new byte[(int) manifest.length()];, +		try {, +			InputStream is = null;, +			try {, +				is = new BufferedInputStream(new FileInputStream(manifest));, +				int total = 0;, +				while(total < bytes.length) {, +					int remain = bytes.length - total;, +					int read = is.read(bytes, total, remain);, +					if(read > 0) total += read;, +				}, +			} finally {, +				is.close();, +			}, +		} catch(FileNotFoundException fnfe) { die("FILE NOT FOUND"); }, +		catch(IOException ioe) { die("IOE"); }, +		count=0;, +	}, +, +	public void parse() {, +		if(cInt16(bytes, count) != 0x0003) die("Version is not 3");, +		if(cInt16(bytes, count) != 0x0008) die("Size of header is not 8");, +		if(cInt32(bytes, count) != bytes.length) die("Size of manifest doesn't match");, +		while(true) {, +			int type = cInt16(bytes, count);, +			if(type==0x0001) parseStringPool();, +			else if(type==0x0180) parseResourceMap();, +			else if(type==0x0100) parseNameSpace();, +			else if(type==0x0102) parseElement();, +			else die("Type: " + Integer.toHexString(type) + " not yet implemented");, +			System.out.println("COUNT: "+Integer.toHexString(count));, +		}, +		//die("Done");, +	}, +, +	private void parseStringPool() {, +		if(cInt16(bytes, count) != 0x001c) die("Header header size not 28");, +		int hsize = cInt32(bytes, count);, +		int stringCount = cInt32(bytes, count);, +		int styleCount = cInt32(bytes, count);, +		int flags = cInt32(bytes, count);, +		int stringsStart = cInt32(bytes, count);, +		int stylesStart = cInt32(bytes, count);, +/*, +		System.out.println(hsize);, +		System.out.println(stringCount);, +		System.out.println(styleCount);, +		System.out.println(flags);, +		System.out.println(stringsStart);, +		System.out.println(stylesStart);, +*/, +		int[] stringsOffsets = new int[stringCount];, +		for(int i=0; i<stringCount; i++) {, +			stringsOffsets[i] = cInt32(bytes, count);, +			//System.out.println("i["+i+"]: " + stringsOffsets[i]);, +		}, +		strings = new String[stringCount];, +		for(int i=0; i<stringCount; i++) {, +			int off = 8 + stringsStart + stringsOffsets[i];, +			int strlen = cInt16(bytes, off);, +			//System.out.println("strlen: " + strlen);, +			byte[] str = new byte[strlen*2];, +			System.arraycopy(bytes, count, str, 0, strlen*2);, +			count+=strlen*2;, +			strings[i] = new String(str, Charset.forName("UTF-16LE"));, +			System.out.println("index i["+i+"] string: " + strings[i]);]
[+++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/build.gradle, +	id 'org.ec4j.editorconfig' version '0.0.3', +editorconfig {, +	excludes = ['gradle/', +				, 'jadx-test-app/test-app' // ignore issues in submodule, +				, '**/out/' // IntelliJ Idea build dirs, +				, '**/certificate-test/' // binary test files (.RSA), +				, '**/*.svg', +				, '**/*.arsc', +	], +}, +, +check.dependsOn editorconfigCheck, +, +test.dependsOn(samples), +++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/build.gradle, +	id 'org.ec4j.editorconfig' version '0.0.3', +editorconfig {, +	excludes = ['gradle/', +				, 'jadx-test-app/test-app' // ignore issues in submodule, +				, '**/out/' // IntelliJ Idea build dirs, +				, '**/certificate-test/' // binary test files (.RSA), +				, '**/*.svg', +				, '**/*.arsc', +	], +}, +, +check.dependsOn editorconfigCheck, +, +test.dependsOn(samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +	public boolean checkOffset(int dataOffset) {, +		return dataOffset >= 0 && dataOffset < dexBuf.getLength();, +	}, +, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +	public boolean checkOffset(int dataOffset) {, +		return dataOffset >= 0 && dataOffset < dexBuf.getLength();, +	}, +, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DebugInfoVisitor.java, +			if (debugOffset > 0 && mth.dex().checkOffset(debugOffset)) {]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +		BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +		bxp.parse();, +		System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +		writer.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, +	private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;, +, +			case ARSC:, +				return new ResTableParser().decodeToCodeWriter(inputStream);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, +	private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;, +, +			case ARSC:, +				return new ResTableParser().decodeToCodeWriter(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +public class BinaryXMLParser extends CommonBinaryParser {, +					strings = parseStringPoolNoType();, +				writer.add("UNKNOWN_DATA_TYPE_0x" + Integer.toHexString(attrValDataType));, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, +	private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;, +, +			case ARSC:, +				return new ResTableParser().decodeToCodeWriter(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +public class BinaryXMLParser extends CommonBinaryParser {, +					strings = parseStringPoolNoType();, +				writer.add("UNKNOWN_DATA_TYPE_0x" + Integer.toHexString(attrValDataType));, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +package jadx.core.xmlgen;, +, +import java.io.IOException;, +, +public class CommonBinaryParser extends ParserConstants {, +, +	protected ParserStream is;, +, +	protected String[] parseStringPool() throws IOException {, +		is.checkInt16(RES_STRING_POOL_TYPE, "String pool expected");, +		return parseStringPoolNoType();, +	}, +, +	protected String[] parseStringPoolNoType() throws IOException {, +		long start = is.getPos() - 2;, +		is.checkInt16(0x001c, "String pool header size not 0x001c");, +		long size = is.readUInt32();, +, +		int stringCount = is.readInt32();, +		int styleCount = is.readInt32();, +		int flags = is.readInt32();, +		long stringsStart = is.readInt32();, +		long stylesStart = is.readInt32();, +, +		int[] stringsOffset = is.readInt32Array(stringCount);, +		int[] stylesOffset = is.readInt32Array(styleCount);, +, +		is.checkPos(start + stringsStart, "Expected strings start");, +		String[] strings = new String[stringCount];, +		if ((flags & UTF8_FLAG) != 0) {, +			// UTF-8, +			for (int i = 0; i < stringCount; i++) {, +				// is.checkPos(start + stringsStart + stringsOffset[i], "Expected string start");, +				strings[i] = is.readString8();, +			}, +		} else {, +			// UTF-16, +			long stringsStartOffset = start + stringsStart;, +			for (int i = 0; i < stringCount; i++) {, +				// is.checkPos(stringsStartOffset + stringsOffset[i], "Expected string start");, +				// TODO: don't trust specified string length, read until \0, +				// TODO: stringsOffset can be same for different indexes, +				strings[i] = is.readString16();, +			}, +		}, +		if (stylesStart != 0) {, +			is.checkPos(start + stylesStart, "Expected styles start");, +			if (styleCount != 0) {, +				// TODO: implement styles parsing, +			}, +		}, +		// skip padding zeroes, +		is.skip(start + size - is.getPos());, +		return strings;, +	}, +, +	protected void die(String message) throws IOException {, +		throw new IOException("Decode error: " + message, +				+ ", position: 0x" + Long.toHexString(is.getPos()));, +	}, +, +}, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, +	private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +			outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	List<IDexTreeVisitor> getPasses() {, +		return passes;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +		return parent.getFullName() + '.' + getName();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +		return "ResourceFile{name='" + name + '\'' + ", type=" + type + '}';, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, +				passes.add(new DebugInfoParseVisitor());, +			passes.add(new BlockSplitter());, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new ConstructorVisitor());, +			passes.add(new InitCodeVariables());, +			passes.add(new MarkFinallyVisitor());, +			passes.add(new TypeInferenceVisitor());, +			if (args.isDebugInfo()) {, +				passes.add(new DebugInfoApplyVisitor());, +			}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +			case TERNARY:, +				addTernary(code, condition);, +				break;, +, +				throw new JadxRuntimeException("Unknown condition mode: " + condition.getMode());, +	private void addTernary(CodeWriter code, IfCondition condition) throws CodegenException {, +		add(code, condition.first());, +		code.add(" ? ");, +		add(code, condition.second());, +		code.add(" : ");, +		add(code, condition.third());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +			case TERNARY:, +				addTernary(code, condition);, +				break;, +, +				throw new JadxRuntimeException("Unknown condition mode: " + condition.getMode());, +	private void addTernary(CodeWriter code, IfCondition condition) throws CodegenException {, +		add(code, condition.first());, +		code.add(" ? ");, +		add(code, condition.second());, +		code.add(" : ");, +		add(code, condition.third());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +	private IfCondition condition;, +, +	public TernaryInsn(IfCondition condition, RegisterArg result) {, +		this(condition, result, LiteralArg.TRUE, LiteralArg.FALSE);, +	}, +	public void simplifyCondition() {, +		condition = IfCondition.simplify(condition);, +		if (condition.getMode() == IfCondition.Mode.NOT) {, +			invert();, +		}, +	}, +, +	private void invert() {, +		condition = IfCondition.invert(condition);, +		InsnArg tmp = getArg(0);, +		setArg(0, getArg(1));, +		setArg(1, tmp);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +			case TERNARY:, +				addTernary(code, condition);, +				break;, +, +				throw new JadxRuntimeException("Unknown condition mode: " + condition.getMode());, +	private void addTernary(CodeWriter code, IfCondition condition) throws CodegenException {, +		add(code, condition.first());, +		code.add(" ? ");, +		add(code, condition.second());, +		code.add(" : ");, +		add(code, condition.third());, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +	private IfCondition condition;, +, +	public TernaryInsn(IfCondition condition, RegisterArg result) {, +		this(condition, result, LiteralArg.TRUE, LiteralArg.FALSE);, +	}, +	public void simplifyCondition() {, +		condition = IfCondition.simplify(condition);, +		if (condition.getMode() == IfCondition.Mode.NOT) {, +			invert();, +		}, +	}, +, +	private void invert() {, +		condition = IfCondition.invert(condition);, +		InsnArg tmp = getArg(0);, +		setArg(0, getArg(1));, +		setArg(1, tmp);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +		TERNARY,, +	public static IfCondition ternary(IfCondition a, IfCondition b, IfCondition c) {, +		return new IfCondition(Mode.TERNARY, Arrays.asList(a, b, c));, +	}, +, +	public IfCondition third() {, +		return args.get(2);, +	}, +, +			case TERNARY:, +				return ternary(not(cond.first()), cond.third(), cond.second());, +			cond = invert(cond.first());, +		}, +		if (cond.getMode() == Mode.TERNARY && cond.first().getMode() == Mode.NOT) {, +			cond = invert(cond);, +			case TERNARY:, +				return first() + " ? " + second() + " : " + third();]
[+++ b/jadx-cli/build.gradle, +++ b/jadx-cli/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +			if(pkg.length() == 0) {, +				parClsName = clsName.substring(0, sep);, +			}, +, +++ b/jadx-cli/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +			if(pkg.length() == 0) {, +				parClsName = clsName.substring(0, sep);, +			}, +, +++ b/jadx-gui/build.gradle]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +	private static final int ITERATIVE_LIMIT = 500;, +, +		int k = 0;, +			if (k++ > ITERATIVE_LIMIT) {, +				throw new JadxOverflowException("Iterative traversal limit reached, method: " + mth);, +			}]
[+++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		JavaPackage that = (JavaPackage) o;, +		return name.equals(that.name);, +	}, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		JavaPackage that = (JavaPackage) o;, +		return name.equals(that.name);, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +		if (Consts.DEBUG) {, +		}, +		if (Jadx.class.desiredAssertionStatus()) {, +	}, +			if (args.isRawCFGOutput()) {, +			}, +			if (args.isCFGOutput()) {, +			}, +, +			if (args.isCFGOutput()) {, +			}, +				if (ver != null) {, +			}, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		JavaPackage that = (JavaPackage) o;, +		return name.equals(that.name);, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +		if (Consts.DEBUG) {, +		}, +		if (Jadx.class.desiredAssertionStatus()) {, +	}, +			if (args.isRawCFGOutput()) {, +			}, +			if (args.isCFGOutput()) {, +			}, +, +			if (args.isCFGOutput()) {, +			}, +				if (ver != null) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +				if (r != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		JavaPackage that = (JavaPackage) o;, +		return name.equals(that.name);, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +		if (Consts.DEBUG) {, +		}, +		if (Jadx.class.desiredAssertionStatus()) {, +	}, +			if (args.isRawCFGOutput()) {, +			}, +			if (args.isCFGOutput()) {, +			}, +, +			if (args.isCFGOutput()) {, +			}, +				if (ver != null) {, +			}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +				if (r != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		NClass nClass = (NClass) o;, +		return name.equals(nClass.name);, +	}, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +		if (this == o) {, +		if (o == null || getClass() != o.getClass()) {, +			return false;, +		}, +		JavaPackage that = (JavaPackage) o;, +		return name.equals(that.name);, +	}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +		if (Consts.DEBUG) {, +		}, +		if (Jadx.class.desiredAssertionStatus()) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JList resultsList;, +	private static class ResultsModel extends DefaultListModel {, +	private static class ResultsCellRenderer implements ListCellRenderer {, +		public Component getListCellRendererComponent(JList list,, +		resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +		Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JList resultsList;, +	private static class ResultsModel extends DefaultListModel {, +	private static class ResultsCellRenderer implements ListCellRenderer {, +		public Component getListCellRendererComponent(JList list,, +		resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.Iterator;, +		if (mth.isNoCode()) {, +		}, +					if (type == InsnType.RETURN || type == InsnType.THROW) {, +					}, +					if (type == InsnType.MONITOR_ENTER || type == InsnType.MONITOR_EXIT) {, +					}, +							if (jump.getSrc() == prevInsn.getOffset()) {, +					}, +							if (jump.getDest() == insn.getOffset()) {, +					}, +						if (targBlock == curBlock) {, +					}, +							if (connBlock != destBlock) {, +		}, +			if (i > 100) {, +		}, +		if (!from.getSuccessors().contains(to)) {, +		}, +		if (!to.getPredecessors().contains(from)) {, +	}, +				if (block == entryBlock) {, +				}, +				if (!d.equals(dset)) {, +			}, +			if (block == entryBlock) {, +			}, +		mth.getExitBlocks().clear();, +				if (insns.get(0).getType() == InsnType.RETURN) {, +					mth.getExitBlocks().add(block);, +				}, +		if (splitReturn(mth)) {, +		if (mergeReturn(mth)) {, +			return true;, +	/**, +	 * Merge return blocks for void methods, +	 */, +	private static boolean mergeReturn(MethodNode mth) {, +		if (mth.getExitBlocks().size() == 1 || !mth.getReturnType().equals(ArgType.VOID)) {, +			return false;, +		}, +		boolean merge = false;, +		for (BlockNode exitBlock : mth.getExitBlocks()) {, +			List<BlockNode> preds = exitBlock.getPredecessors();, +			if (preds.size() == 1) {, +				BlockNode pred = preds.get(0);, +				for (BlockNode otherExitBlock : mth.getExitBlocks()) {, +					if (exitBlock != otherExitBlock, +							&& otherExitBlock.isDominator(pred), +							&& otherExitBlock.getPredecessors().size() == 1) {, +						// merge, +						BlockNode otherPred = otherExitBlock.getPredecessors().get(0);, +						removeConnection(otherPred, otherExitBlock);, +						connect(otherPred, exitBlock);, +						merge = true;, +					}, +				}, +			}, +		}, +		if (merge) {, +			cleanExitNodes(mth);, +		}, +		return merge;, +	}, +, +	/**, +	 * Splice return block if several predecessors presents, +	 */, +	private static boolean splitReturn(MethodNode mth) {, +		if (mth.getExitBlocks().size() != 1) {, +			return false;, +		}, +		boolean split = false;, +		BlockNode exitBlock = mth.getExitBlocks().get(0);, +		if (exitBlock.getPredecessors().size() > 1, +				&& exitBlock.getInstructions().size() == 1, +				&& !exitBlock.getInstructions().get(0).getAttributes().contains(AttributeType.CATCH_BLOCK), +				&& !exitBlock.getAttributes().contains(AttributeFlag.SYNTHETIC)) {, +			InsnNode returnInsn = exitBlock.getInstructions().get(0);, +			List<BlockNode> preds = new ArrayList<BlockNode>(exitBlock.getPredecessors());, +			if (returnInsn.getArgsCount() != 0 && !isReturnArgAssignInPred(mth, preds, returnInsn)) {, +				return false;, +			}, +			split = true;, +			for (BlockNode pred : preds) {, +				BlockNode newRetBlock = startNewBlock(mth, exitBlock.getStartOffset());, +				newRetBlock.getAttributes().add(AttributeFlag.SYNTHETIC);, +				newRetBlock.getInstructions().add(duplicateReturnInsn(returnInsn));, +				removeConnection(pred, exitBlock);, +				connect(pred, newRetBlock);, +			}, +		}, +		if (split) {, +			cleanExitNodes(mth);, +		}, +		return split;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new SSATransform());, +			passes.add(new TypeInference());, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new SSATransform());, +			passes.add(new TypeInference());, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getRegisterArg());, +				makeArithOneArg((ArithNode) insn, code);, +				makeConstructor((ConstructorInsn) insn, code);, +			case PHI:, +				break;, +, +	private void makeConstructor(ConstructorInsn insn, CodeWriter code), +	private void makeArithOneArg(ArithNode insn, CodeWriter code) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new SSATransform());, +			passes.add(new TypeInference());, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getRegisterArg());, +				makeArithOneArg((ArithNode) insn, code);, +				makeConstructor((ConstructorInsn) insn, code);, +			case PHI:, +				break;, +, +	private void makeConstructor(ConstructorInsn insn, CodeWriter code), +	private void makeArithOneArg(ArithNode insn, CodeWriter code) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.IAttribute;, +		String name = arg.getName();, +		arg.getSVar().setName(name);, +					List<IAttribute> catchAttrs = attrs.getAll(AttributeType.CATCH_BLOCK);, +					for (IAttribute catchAttr : catchAttrs) {, +						code.add("\t " + catchAttr);, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new SSATransform());, +			passes.add(new TypeInference());, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getRegisterArg());, +				makeArithOneArg((ArithNode) insn, code);, +				makeConstructor((ConstructorInsn) insn, code);, +			case PHI:, +				break;, +, +	private void makeConstructor(ConstructorInsn insn, CodeWriter code), +	private void makeArithOneArg(ArithNode insn, CodeWriter code) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.IAttribute;, +		String name = arg.getName();, +		arg.getSVar().setName(name);, +					List<IAttribute> catchAttrs = attrs.getAll(AttributeType.CATCH_BLOCK);, +					for (IAttribute catchAttr : catchAttrs) {, +						code.add("\t " + catchAttr);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +			} else {, +				declareVars(code, cont);, +				if (cont instanceof IfRegion) {, +			}, +			declareVars(code, region);, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +		LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +	// instArg equal 'null' for static fields, +	private final InsnArg instArg;, +	public FieldArg(FieldInfo field, InsnArg reg) {, +		this.instArg = reg;, +	public InsnArg getInstanceArg() {, +		return instArg;, +		return instArg == null;, +		if (instArg != null ? !instArg.equals(fieldArg.instArg) : fieldArg.instArg != null) {, +		result = 31 * result + (instArg != null ? instArg.hashCode() : 0);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +	// instArg equal 'null' for static fields, +	private final InsnArg instArg;, +	public FieldArg(FieldInfo field, InsnArg reg) {, +		this.instArg = reg;, +	public InsnArg getInstanceArg() {, +		return instArg;, +		return instArg == null;, +		if (instArg != null ? !instArg.equals(fieldArg.instArg) : fieldArg.instArg != null) {, +		result = 31 * result + (instArg != null ? instArg.hashCode() : 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			InsnArg reg = null;, +				reg = get.getArg(0);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +	// instArg equal 'null' for static fields, +	private final InsnArg instArg;, +	public FieldArg(FieldInfo field, InsnArg reg) {, +		this.instArg = reg;, +	public InsnArg getInstanceArg() {, +		return instArg;, +		return instArg == null;, +		if (instArg != null ? !instArg.equals(fieldArg.instArg) : fieldArg.instArg != null) {, +		result = 31 * result + (instArg != null ? instArg.hashCode() : 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			InsnArg reg = null;, +				reg = get.getArg(0);, +++ b/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java, +import jadx.core.dex.instructions.args.InsnWrapArg;, +			unbindArgUsage(mth, arg);, +		}, +		insn.add(AFlag.INCONSISTENT_CODE);, +	}, +, +	public static void unbindArgUsage(MethodNode mth, InsnArg arg) {, +		} else if (arg instanceof InsnWrapArg) {, +			InsnWrapArg wrap = (InsnWrapArg) arg;, +			unbindInsn(mth, wrap.getWrapInsn());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +	// instArg equal 'null' for static fields, +	private final InsnArg instArg;, +	public FieldArg(FieldInfo field, InsnArg reg) {, +		this.instArg = reg;, +	public InsnArg getInstanceArg() {, +		return instArg;, +		return instArg == null;, +		if (instArg != null ? !instArg.equals(fieldArg.instArg) : fieldArg.instArg != null) {, +		result = 31 * result + (instArg != null ? instArg.hashCode() : 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +			InsnArg reg = null;, +				reg = get.getArg(0);, +++ b/jadx-core/src/main/java/jadx/core/utils/InstructionRemover.java, +import jadx.core.dex.instructions.args.InsnWrapArg;, +			unbindArgUsage(mth, arg);, +		}, +		insn.add(AFlag.INCONSISTENT_CODE);, +	}, +, +	public static void unbindArgUsage(MethodNode mth, InsnArg arg) {, +		} else if (arg instanceof InsnWrapArg) {, +			InsnWrapArg wrap = (InsnWrapArg) arg;, +			unbindInsn(mth, wrap.getWrapInsn());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *  JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +	// instArg equal 'null' for static fields]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		}, +		if (isClassInnerFor(useCls, extClsInfo)) {, +			return shortName;, +		}, +		if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, +	private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, +		ClassInfo a = useCls.getTopParentClass();, +		ClassInfo b = extClsInfo.getTopParentClass();, +		if (a != null) {, +			return a.equals(b);, +		}, +		// useCls - is a top class, +		return useCls.equals(b);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		}, +		if (isClassInnerFor(useCls, extClsInfo)) {, +			return shortName;, +		}, +		if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, +	private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, +		ClassInfo a = useCls.getTopParentClass();, +		ClassInfo b = extClsInfo.getTopParentClass();, +		if (a != null) {, +			return a.equals(b);, +		}, +		// useCls - is a top class, +		return useCls.equals(b);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName, false);, +	public String makeFullClsName(String shortName, boolean raw) {, +			String innerSep = raw ? "$" : ".";, +			return parentClass.makeFullClsName(parentClass.getShortName(), raw) + innerSep + shortName;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		}, +		if (isClassInnerFor(useCls, extClsInfo)) {, +			return shortName;, +		}, +		if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, +	private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, +		ClassInfo a = useCls.getTopParentClass();, +		ClassInfo b = extClsInfo.getTopParentClass();, +		if (a != null) {, +			return a.equals(b);, +		}, +		// useCls - is a top class, +		return useCls.equals(b);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName, false);, +	public String makeFullClsName(String shortName, boolean raw) {, +			String innerSep = raw ? "$" : ".";, +			return parentClass.makeFullClsName(parentClass.getShortName(), raw) + innerSep + shortName;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		}, +			classInfo.rename(cls.dex(), classInfo.makeFullClsName(newShortName, true));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		}, +		if (isClassInnerFor(useCls, extClsInfo)) {, +			return shortName;, +		}, +		if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, +	private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, +		ClassInfo a = useCls.getTopParentClass();, +		ClassInfo b = extClsInfo.getTopParentClass();, +		if (a != null) {, +			return a.equals(b);, +		}, +		// useCls - is a top class, +		return useCls.equals(b);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		this.fullName = makeFullClsName(clsName, false);, +	public String makeFullClsName(String shortName, boolean raw) {, +			String innerSep = raw ? "$" : ".";, +			return parentClass.makeFullClsName(parentClass.getShortName(), raw) + innerSep + shortName;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		}, +			classInfo.rename(cls.dex(), classInfo.makeFullClsName(newShortName, true));, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass2.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		}, +		if (isClassInnerFor(useCls, extClsInfo)) {, +			return shortName;, +		}, +		if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, +	private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, +		ClassInfo a = useCls.getTopParentClass();, +		ClassInfo b = extClsInfo.getTopParentClass();, +		if (a != null) {, +			return a.equals(b);, +		}, +		// useCls - is a top class, +		return useCls.equals(b);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +			} catch (Exception e) {]
[+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +	private boolean useImports = true;]
[+++ b/.travis.yml, +    - openjdk6, +++ b/.travis.yml, +    - openjdk6, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/.travis.yml, +    - openjdk6, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ b/.travis.yml, +    - openjdk6, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/.travis.yml, +    - openjdk6, +++ b/jadx-core/build.gradle, +    compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import java.util.Enumeration;, +, +		// Input file could be .apk or .zip files, +		// we should consider the input file could contain only one single dex, multi-dex, or instantRun support dex for Android .apk files, +		String instantRunDexSuffix = "classes" + ext;, +		for (Enumeration<? extends ZipEntry> e = zf.entries(); e.hasMoreElements(); ) {, +			ZipEntry entry = e.nextElement();, +			String entryName = entry.getName();, +, +				if ((entryName.startsWith("classes") && entryName.endsWith(ext)) || entryName.endsWith(instantRunDexSuffix)) {, +						index++;, +						index++;, +				} else if (entryName.equals("instant-run.zip") && ext.equals(".dex")) {, +					File jarFile = FileUtils.createTempFile("instant-run.zip");, +					FileOutputStream fos = new FileOutputStream(jarFile);, +					try {, +						IOUtils.copy(inputStream, fos);, +					} finally {, +						close(fos);, +					}, +					InputFile tempFile = new InputFile(jarFile);, +					tempFile.loadFromZip(ext);, +					List<DexFile> dexFiles = tempFile.getDexFiles();, +					if (!dexFiles.isEmpty()) {, +						index += dexFiles.size();, +						this.dexFiles.addAll(dexFiles);, +					}, +				}]
[+++ b/.travis.yml, +script:, +    - TERM=dumb ./gradlew clean build dist, +++ b/.travis.yml, +script:, +    - TERM=dumb ./gradlew clean build dist, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("Output directory exists as file " + outputDir);, +++ b/.travis.yml, +script:, +    - TERM=dumb ./gradlew clean build dist, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("Output directory exists as file " + outputDir);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private static final String STRING_CHARSET = "US-ASCII";, +, +					throw new JadxRuntimeException("Duplicate class: " + clsRawName);, +			throw new JadxRuntimeException("Unknown file format: " + outputName);, +			throw new JadxRuntimeException("Can't load classpath file: " + CLST_FILENAME);, +			throw new JadxRuntimeException("Unknown file format: " + name);, +		int readHeaderLength = in.read(header);, +		if (readHeaderLength != JADX_CLS_SET_HEADER.length(), +				|| !JADX_CLS_SET_HEADER.equals(new String(header, STRING_CHARSET)), +				|| version != VERSION) {, +		byte[] bytes = name.getBytes(STRING_CHARSET);, +		return new String(bytes, STRING_CHARSET);, +	public int getClassesCount() {, +		return classes.length;, +	}, +, +	public void addToMap(Map<String, NClass> nameMap) {, +		for (NClass cls : classes) {, +			nameMap.put(cls.getName(), cls);, +		}, +++ b/.travis.yml, +script:, +    - TERM=dumb ./gradlew clean build dist, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("Output directory exists as file " + outputDir);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private static final String STRING_CHARSET = "US-ASCII";, +, +					throw new JadxRuntimeException("Duplicate class: " + clsRawName);, +			throw new JadxRuntimeException("Unknown file format: " + outputName);, +			throw new JadxRuntimeException("Can't load classpath file: " + CLST_FILENAME);, +			throw new JadxRuntimeException("Unknown file format: " + name);, +		int readHeaderLength = in.read(header);, +		if (readHeaderLength != JADX_CLS_SET_HEADER.length(), +				|| !JADX_CLS_SET_HEADER.equals(new String(header, STRING_CHARSET)), +				|| version != VERSION) {, +		byte[] bytes = name.getBytes(STRING_CHARSET);, +		return new String(bytes, STRING_CHARSET);, +	public int getClassesCount() {, +		return classes.length;, +	}, +, +	public void addToMap(Map<String, NClass> nameMap) {, +		for (NClass cls : classes) {, +			nameMap.put(cls.getName(), cls);, +		}, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private final Map<String, Set<String>> ancestorCache = new WeakHashMap<String, Set<String>>();, +			nameMap = new HashMap<String, NClass>(set.getClassesCount());, +			set.addToMap(nameMap);, +			throw new JadxRuntimeException("Classpath already loaded");, +			throw new JadxRuntimeException("Classpath must be loaded first");, +++ b/.travis.yml, +script:, +    - TERM=dumb ./gradlew clean build dist, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +	private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, +			throw new JadxException("Output directory exists as file " + outputDir);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private static final String STRING_CHARSET = "US-ASCII";, +, +					throw new JadxRuntimeException("Duplicate class: " + clsRawName);, +			throw new JadxRuntimeException("Unknown file format: " + outputName);, +			throw new JadxRuntimeException("Can't load classpath file: " + CLST_FILENAME);, +			throw new JadxRuntimeException("Unknown file format: " + name);, +		int readHeaderLength = in.read(header);, +		if (readHeaderLength != JADX_CLS_SET_HEADER.length(), +				|| !JADX_CLS_SET_HEADER.equals(new String(header, STRING_CHARSET)), +				|| version != VERSION) {, +		byte[] bytes = name.getBytes(STRING_CHARSET);, +		return new String(bytes, STRING_CHARSET);, +	public int getClassesCount() {, +		return classes.length;, +	}, +]
[+++ b/jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java, +import org.junit.jupiter.api.extension.ExtendWith;, +, +import jadx.NotYetImplementedExtension;, +@ExtendWith(NotYetImplementedExtension.class), +++ b/jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java, +import org.junit.jupiter.api.extension.ExtendWith;, +, +import jadx.NotYetImplementedExtension;, +@ExtendWith(NotYetImplementedExtension.class), +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/MissingGenericsTypesTest.java, +package jadx.tests.integration.generics;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.containsString;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +public class MissingGenericsTypesTest extends SmaliTest {, +, +	/*, +		private int x;, +, +		public void test() {, +			Map<String, String> map = new HashMap();, +			x = 1;, +			for (String s : map.keySet()) {, +				System.out.println(s);, +			}, +		}, +	*/, +, +	@Test, +	@NotYetImplemented, +	public void test() {, +		ClassNode cls = getClassNodeFromSmaliWithPath("generics", "MissingGenericsTypesTest");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("Map<String"));, +	}, +}, +++ b/jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java, +import org.junit.jupiter.api.extension.ExtendWith;, +, +import jadx.NotYetImplementedExtension;, +@ExtendWith(NotYetImplementedExtension.class), +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/MissingGenericsTypesTest.java, +package jadx.tests.integration.generics;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.containsString;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +public class MissingGenericsTypesTest extends SmaliTest {, +, +	/*, +		private int x;, +, +		public void test() {, +			Map<String, String> map = new HashMap();, +			x = 1;, +			for (String s : map.keySet()) {, +				System.out.println(s);, +			}, +		}, +	*/, +, +	@Test, +	@NotYetImplemented, +	public void test() {, +		ClassNode cls = getClassNodeFromSmaliWithPath("generics", "MissingGenericsTypesTest");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("Map<String"));, +	}, +}, +++ b/jadx-core/src/test/smali/generics/MissingGenericsTypesTest.smali, +.class public LMissingGenericsTypesTest;, +.super Ljava/lang/Object;, +, +# instance fields, +.field private x:I, +, +, +# direct methods, +.method public constructor <init>()V, +    .locals 0, +, +    .line 9, +    invoke-direct {p0}, Ljava/lang/Object;-><init>()V, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +		if (obj instanceof Integer) {, +				ResRefField resField = new ResRefField(dex, str.replace('/', '.'));, +				if (field == null) {, +					return resField;, +				}, +				if (!field.getName().equals(resField.getName())) {, +					field = resField;, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +		if (obj instanceof Integer) {, +				ResRefField resField = new ResRefField(dex, str.replace('/', '.'));, +				if (field == null) {, +					return resField;, +				}, +				if (!field.getName().equals(resField.getName())) {, +					field = resField;, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +import jadx.core.dex.visitors.typeinference.PostTypeInference;, +				FieldNode f = null;, +				ArgType litArgType = litArg.getType();, +				if (litArgType.isTypeKnown()) {, +					f = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +				} else if (litArgType.contains(PrimitiveType.INT)) {, +					f = mth.getParentClass().getConstField((int) literal, false);, +				}, +		PostTypeInference.process(mth, insn);]
[+++ b/jadx-gui/build.gradle, +    compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/build.gradle, +    compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import jadx.api.JadxDecompiler;, +import javax.swing.BorderFactory;, +		JLabel name = new JLabel("jadx");, +		JLabel version = new JLabel("version: " + JadxDecompiler.getVersion());, +		textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));, +++ b/jadx-gui/build.gradle, +    compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import jadx.api.JadxDecompiler;, +import javax.swing.BorderFactory;, +		JLabel name = new JLabel("jadx");, +		JLabel version = new JLabel("version: " + JadxDecompiler.getVersion());, +		textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate;, +import jadx.gui.update.data.Release;, +import jadx.gui.utils.Link;, +import javax.swing.Box;, +	private Link updateLink;, +		JadxUpdate.check(new JadxUpdate.IUpdateCallback() {, +			@Override, +			public void onUpdate(final Release r) {, +				SwingUtilities.invokeLater(new Runnable() {, +					@Override, +					public void run() {, +						updateLink.setText(String.format(NLS.str("menu.update_label"), r.getName()));, +						updateLink.setVisible(true);, +					}, +				});, +			}, +		});, +			ProgressMonitor progressMonitor = new ProgressMonitor(mainPanel, NLS.str("msg.saving_sources"), "", 0, 100);, +		toolbar.add(Box.createHorizontalGlue());, +		updateLink = new Link("", JadxUpdate.JADX_RELEASES_URL);, +		updateLink.setVisible(false);, +		toolbar.add(updateLink);, +, +++ b/jadx-gui/build.gradle, +    compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import jadx.api.JadxDecompiler;, +import javax.swing.BorderFactory;, +		JLabel name = new JLabel("jadx");, +		JLabel version = new JLabel("version: " + JadxDecompiler.getVersion());, +		textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate;, +import jadx.gui.update.data.Release;, +import jadx.gui.utils.Link;, +import javax.swing.Box;, +	private Link updateLink;, +		JadxUpdate.check(new JadxUpdate.IUpdateCallback() {, +			@Override, +			public void onUpdate(final Release r) {, +				SwingUtilities.invokeLater(new Runnable() {, +					@Override, +					public void run() {, +						updateLink.setText(String.format(NLS.str("menu.update_label"), r.getName()));, +						updateLink.setVisible(true);, +					}, +				});, +			}, +		});, +			ProgressMonitor progressMonitor = new ProgressMonitor(mainPanel, NLS.str("msg.saving_sources"), "", 0, 100);, +		toolbar.add(Box.createHorizontalGlue());, +		updateLink = new Link("", JadxUpdate.JADX_RELEASES_URL);, +		updateLink.setVisible(false);, +		toolbar.add(updateLink);, +, +++ b/jadx-gui/src/main/java/jadx/gui/update/JadxUpdate.java, +package jadx.gui.update;, +, +import jadx.api.JadxDecompiler;, +import jadx.gui.update.data.Release;, +, +import java.io.InputStreamReader;, +import java.io.Reader;, +import java.lang.reflect.Type;, +import java.net.HttpURLConnection;, +import java.net.URL;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.google.gson.Gson;, +import com.google.gson.reflect.TypeToken;, +, +public class JadxUpdate {, +	private static final Logger LOG = LoggerFactory.getLogger(JadxUpdate.class);, +, +	public static final String JADX_RELEASES_URL = "https://github.com/skylot/jadx/releases";]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, +		assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, +		assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java, +	private final List<RegisterArg> args = new ArrayList<>();, +	private final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();, +			if (!arg.contains(AFlag.DONT_GENERATE)) {, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, +		assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java, +	private final List<RegisterArg> args = new ArrayList<>();, +	private final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();, +			if (!arg.contains(AFlag.DONT_GENERATE)) {, +	}, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, +		assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java, +	private final List<RegisterArg> args = new ArrayList<>();, +	private final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();, +			if (!arg.contains(AFlag.DONT_GENERATE)) {, +	}, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariablesUsageWithLoops.java, +package jadx.tests.integration.variables;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.containsString;, +, +import java.util.ArrayList;, +import java.util.List;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +public class TestVariablesUsageWithLoops extends IntegrationTest {, +, +	public static class TestEnhancedFor {, +, +		public void test() {, +			List list;, +			synchronized (this) {, +				list = new ArrayList();, +			}, +			for (Object o : list) {, +				System.out.println(o);, +			}, +		}, +	}, +, +	@Test, +	public void testEnhancedFor() {, +		ClassNode cls = getClassNode(TestEnhancedFor.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("     list = new ArrayList"));, +	}, +, +	public static class TestForLoop {, +, +		public void test() {, +			List list;, +			synchronized (this) {, +				list = new ArrayList();, +			}, +			for (int i = 0; i < list.size(); i++) {, +				System.out.println(i);, +			}, +		}, +	}, +, +	@Test, +	public void testForLoop() {, +		ClassNode cls = getClassNode(TestForLoop.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("     list = new ArrayList"));, +	}, +}]
[+++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +, +*******************************************************************************, +Copyright (c) 2008-2012 Kazó Csaba, +, +Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:, +, +The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software., +, +THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE., +*******************************************************************************, +, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +, +++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +, +*******************************************************************************, +Copyright (c) 2008-2012 Kazó Csaba, +, +Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:, +, +The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software., +, +THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE., +*******************************************************************************, +, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public ResContainer loadContent() {, +++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +, +*******************************************************************************, +Copyright (c) 2008-2012 Kazó Csaba, +, +Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:, +, +The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software., +, +THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE., +*******************************************************************************, +, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public ResContainer loadContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +	public ResContainer loadContent() {, +++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +, +*******************************************************************************, +Copyright (c) 2008-2012 Kazó Csaba, +, +Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:, +, +The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software., +, +THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE., +*******************************************************************************, +, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public ResContainer loadContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +	public ResContainer loadContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +			case IMG:, +++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +, +*******************************************************************************, +Copyright (c) 2008-2012 Kazó Csaba, +, +Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:, +, +The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software., +, +THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE., +*******************************************************************************, +, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +	public ResContainer loadContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +	public ResContainer loadContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +			case IMG:, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +, +			case IMG:, +				return ResContainer.singleImageFile(rf.getName(), inputStream);, +++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.getClsp().printMissingClasses();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.getClsp().printMissingClasses();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.ArrayList;, +	private final Set<String> missingClasses = new HashSet<String>();, +, +			missingClasses.add(clsName);, +			missingClasses.add(clsName);, +, +	public void printMissingClasses() {, +		int count = missingClasses.size();, +		if (count == 0) {, +			return;, +		}, +		LOG.warn("Found {} references to unknown classes", count);, +		if (LOG.isDebugEnabled()) {, +			List<String> clsNames = new ArrayList<String>(missingClasses);, +			Collections.sort(clsNames);, +			for (String cls : clsNames) {, +				LOG.debug("  {}", cls);, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +		root.getClsp().printMissingClasses();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.ArrayList;, +	private final Set<String> missingClasses = new HashSet<String>();, +, +			missingClasses.add(clsName);, +			missingClasses.add(clsName);, +, +	public void printMissingClasses() {, +		int count = missingClasses.size();, +		if (count == 0) {, +			return;, +		}, +		LOG.warn("Found {} references to unknown classes", count);, +		if (LOG.isDebugEnabled()) {, +			List<String> clsNames = new ArrayList<String>(missingClasses);, +			Collections.sort(clsNames);, +			for (String cls : clsNames) {, +				LOG.debug("  {}", cls);, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +					if (jadxArgs.getInput().isEmpty()) {, +						mainWindow.openFile();, +					} else {, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +					if (jadxArgs.getInput().isEmpty()) {, +						mainWindow.openFile();, +					} else {, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +	private static final File WORK_DIR = new File(System.getProperty("user.dir"));, +, +	public void openFile() {, +		JFileChooser fileChooser = new JFileChooser();, +		fileChooser.setAcceptAllFileFilterUsed(true);, +		fileChooser.setFileFilter(new FileNameExtensionFilter("supported files", "dex", "apk", "jar"));, +		fileChooser.setToolTipText(NLS.str("file.open"));, +		// fileChooser.setCurrentDirectory(WORK_DIR);, +		int ret = fileChooser.showDialog(mainPanel, NLS.str("file.open"));, +		if (ret == JFileChooser.APPROVE_OPTION) {, +			openFile(fileChooser.getSelectedFile());, +		}, +	}, +, +		fileChooser.setToolTipText(NLS.str("file.save_all_msg"));, +		int ret = fileChooser.showDialog(mainPanel, NLS.str("file.select"));, +			openFile();, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +					if (jadxArgs.getInput().isEmpty()) {, +						mainWindow.openFile();, +					} else {, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +	private static final File WORK_DIR = new File(System.getProperty("user.dir"));, +, +	public void openFile() {, +		JFileChooser fileChooser = new JFileChooser();, +		fileChooser.setAcceptAllFileFilterUsed(true);, +		fileChooser.setFileFilter(new FileNameExtensionFilter("supported files", "dex", "apk", "jar"));, +		fileChooser.setToolTipText(NLS.str("file.open"));, +		// fileChooser.setCurrentDirectory(WORK_DIR);, +		int ret = fileChooser.showDialog(mainPanel, NLS.str("file.open"));, +		if (ret == JFileChooser.APPROVE_OPTION) {, +			openFile(fileChooser.getSelectedFile());, +		}, +	}, +, +		fileChooser.setToolTipText(NLS.str("file.save_all_msg"));, +		int ret = fileChooser.showDialog(mainPanel, NLS.str("file.select"));, +			openFile();, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +file.select=Select]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +				connectExceptionHandlers(block, insn, blocksMap);, +	private static void connectExceptionHandlers(BlockNode block, InsnNode insn,, +	                                             Map<Integer, BlockNode> blocksMap) {, +			BlockNode handlerBlock = initHandlerBlock(h, blocksMap);, +	private static BlockNode initHandlerBlock(ExceptionHandler excHandler, Map<Integer, BlockNode> blocksMap) {, +		BlockNode handlerBlock = excHandler.getHandlerBlock();, +		if (handlerBlock != null) {, +			return handlerBlock;, +		}, +		BlockNode blockByOffset = getBlock(excHandler.getHandleOffset(), blocksMap);, +		excHandler.setHandlerBlock(blockByOffset);, +		return blockByOffset;, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +		HashSet<BlockNode> visited = new HashSet<BlockNode>();, +		collectWhileDominates(dominator, start, result, visited);, +	private static void collectWhileDominates(BlockNode dominator, BlockNode child, List<BlockNode> result, HashSet<BlockNode> visited) {, +		if (visited.contains(child)) return;, +		visited.add(child);, +				collectWhileDominates(dominator, node, result, visited);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +		return regNum;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +				|| exitBlock.contains(AFlag.SYNTHETIC), +				|| exitBlock.contains(AType.SPLITTER_BLOCK)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +				|| exitBlock.contains(AFlag.SYNTHETIC), +				|| exitBlock.contains(AType.SPLITTER_BLOCK)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMove.java, +package jadx.tests.integration.trycatch;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatchNoMove extends SmaliTest {, +, +//	private static void test(AutoCloseable closeable) {, +//		if (closeable != null) {, +//			try {, +//				closeable.close();, +//			} catch (Exception ignored) {, +//			}, +//		}, +//	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMove");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("if (autoCloseable != null) {"));, +		assertThat(code, containsOne("try {"));, +		assertThat(code, containsOne("autoCloseable.close();"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +				|| exitBlock.contains(AFlag.SYNTHETIC), +				|| exitBlock.contains(AType.SPLITTER_BLOCK)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMove.java, +package jadx.tests.integration.trycatch;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatchNoMove extends SmaliTest {, +, +//	private static void test(AutoCloseable closeable) {, +//		if (closeable != null) {, +//			try {, +//				closeable.close();, +//			} catch (Exception ignored) {, +//			}, +//		}, +//	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMove");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("if (autoCloseable != null) {"));, +		assertThat(code, containsOne("try {"));, +		assertThat(code, containsOne("autoCloseable.close();"));, +	}, +}, +++ b/jadx-core/src/test/smali/trycatch/TestTryCatchNoMove.smali, +.class public LTestTryCatchNoMove;, +.super Ljava/lang/Object;, +, +.method private static test(Ljava/lang/AutoCloseable;)V, +    .locals 0, +, +    if-eqz p0, :cond_0, +, +    .line 187, +    :try_start_0, +    invoke-interface {p0}, Ljava/lang/AutoCloseable;->close()V, +    :try_end_0, +    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0, +, +    :catch_0, +    :cond_0, +    return-void, +.end method]
[+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +			fixSplitterBlock(mth, block);, +	private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, +			mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +			fixSplitterBlock(mth, block);, +	private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, +			mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +			fixSplitterBlock(mth, block);, +	private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, +			mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +				mth.addWarn("No exception handlers in catch block: " + tb);, +			processTryCatchBlock(mth, tb, tryBlocksMap);, +		}, +	}, +, +	private static void processTryCatchBlock(MethodNode mth, TryCatchBlock tb, Map<BlockNode, TryCatchBlock> tryBlocksMap) {, +				mth.addWarn("Exception block dominator not found, dom blocks: " + domBlocks);, +				return;, +			mth.addWarn("Failed to process nested try/catch");, +					ErrorsCounter.methodWarn(mth, "Can't wrap try/catch for region: " + region);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +			fixSplitterBlock(mth, block);, +	private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, +			mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +				mth.addWarn("No exception handlers in catch block: " + tb);, +			processTryCatchBlock(mth, tb, tryBlocksMap);, +		}, +	}, +, +	private static void processTryCatchBlock(MethodNode mth, TryCatchBlock tb, Map<BlockNode, TryCatchBlock> tryBlocksMap) {, +				mth.addWarn("Exception block dominator not found, dom blocks: " + domBlocks);, +				return;, +			mth.addWarn("Failed to process nested try/catch");, +					ErrorsCounter.methodWarn(mth, "Can't wrap try/catch for region: " + region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +				processExcHandler(mth, handler, exits);, +	private void processExcHandler(MethodNode mth, ExceptionHandler handler, Set<BlockNode> exits) {, +		RegionStack stack = new RegionStack(this.mth);, +		List<BlockNode> handlerExits = BlockUtils.bitSetToBlocks(this.mth, domFrontier);, +		boolean inLoop = this.mth.getLoopForBlock(start) != null;, +					&& RegionUtils.isRegionContainsBlock(this.mth.getRegion(), exit)) {, +			mth.addWarn("Missing exception handler attribute for start block: " + start);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +			fixSplitterBlock(mth, block);, +	private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, +			mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +				mth.addWarn("No exception handlers in catch block: " + tb);, +			processTryCatchBlock(mth, tb, tryBlocksMap);, +		}, +	}, +, +	private static void processTryCatchBlock(MethodNode mth, TryCatchBlock tb, Map<BlockNode, TryCatchBlock> tryBlocksMap) {, +				mth.addWarn("Exception block dominator not found, dom blocks: " + domBlocks);, +				return;, +			mth.addWarn("Failed to process nested try/catch");, +					ErrorsCounter.methodWarn(mth, "Can't wrap try/catch for region: " + region);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +				processExcHandler(mth, handler, exits);, +	private void processExcHandler(MethodNode mth, ExceptionHandler handler, Set<BlockNode> exits) {, +		RegionStack stack = new RegionStack(this.mth);, +		List<BlockNode> handlerExits = BlockUtils.bitSetToBlocks(this.mth, domFrontier);, +		boolean inLoop = this.mth.getLoopForBlock(start) != null;, +					&& RegionUtils.isRegionContainsBlock(this.mth.getRegion(), exit)) {, +			mth.addWarn("Missing exception handler attribute for start block: " + start);, +++ b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java, +				int decompiledLine = mth.getDecompiledLine() - 1;, +				int startLine = getCommentLinesCount(lines, decompiledLine);, +				for (int i = startLine; i > 0 && i < lines.length; i++) {, +					if (i >= decompiledLine) {, +				}, +				LOG.info("Print method: {}\n{}", mth.getMethodInfo().getShortId(), mthCode);, +	protected int getCommentLinesCount(String[] lines, int line) {, +		for (int i = line - 1; i > 0 && i < lines.length; i--) {, +			String str = lines[i];, +			if (str.isEmpty() || str.equals(CodeWriter.NL)) {, +				return i + 1;, +			}, +		}, +		return 0;, +	}, +]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.Enumeration;, +	public JClass searchClassInTree(JClass node) {, +		Enumeration en = this.breadthFirstEnumeration();, +		while (en.hasMoreElements()) {, +			Object obj = en.nextElement();, +			if (node.equals(obj)) {, +				return (JClass) obj;, +			}, +		}, +		return null;, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.Enumeration;, +	public JClass searchClassInTree(JClass node) {, +		Enumeration en = this.breadthFirstEnumeration();, +		while (en.hasMoreElements()) {, +			Object obj = en.nextElement();, +			if (node.equals(obj)) {, +				return (JClass) obj;, +			}, +		}, +		return null;, +	}, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +	private JRoot treeRoot;, +		treeRoot = new JRoot(wrapper);, +		if (jCls.getParent() == null && treeRoot != null) {, +			// node not register in tree, +			jCls = treeRoot.searchClassInTree(jCls);, +			if (jCls == null) {, +				LOG.error("Class not found in tree");, +				return;, +			}, +		}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (thisClass.startsWith(field.getDeclClass().getFullName())) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (thisClass.startsWith(field.getDeclClass().getFullName())) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +, +	// FIXME: !!code from InsnGen.sfield, +		if (thisClass.startsWith(field.getDeclClass().getFullName())) {]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +	public String getTestName() {, +		return this.getClass().getSimpleName();, +	}, +, +	public String getTestPkg() {, +		return this.getClass().getPackage().getName().replace("jadx.tests.integration.", "");, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +	public String getTestName() {, +		return this.getClass().getSimpleName();, +	}, +, +	public String getTestPkg() {, +		return this.getClass().getPackage().getName().replace("jadx.tests.integration.", "");, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +import jadx.api.JadxInternalAccess;, +import jadx.core.dex.nodes.RootNode;, +	protected List<ClassNode> loadFromSmaliFiles() {, +		compileSmali(outDex, collectSmaliFiles(getTestPkg(), getTestName()));, +		JadxDecompiler d = loadFiles(Collections.singletonList(outDex));, +		RootNode root = JadxInternalAccess.getRoot(d);, +		List<ClassNode> classes = root.getClasses(false);, +		for (ClassNode cls : classes) {, +			decompileAndCheckCls(d, cls);, +		}, +		return classes;, +		assertThat("Smali files not found in " + smaliDir, smaliFileNames, notNullValue());, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +	public String getTestName() {, +		return this.getClass().getSimpleName();, +	}, +, +	public String getTestPkg() {, +		return this.getClass().getPackage().getName().replace("jadx.tests.integration.", "");, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +import jadx.api.JadxInternalAccess;, +import jadx.core.dex.nodes.RootNode;, +	protected List<ClassNode> loadFromSmaliFiles() {, +		compileSmali(outDex, collectSmaliFiles(getTestPkg(), getTestName()));, +		JadxDecompiler d = loadFiles(Collections.singletonList(outDex));, +		RootNode root = JadxInternalAccess.getRoot(d);, +		List<ClassNode> classes = root.getClasses(false);, +		for (ClassNode cls : classes) {, +			decompileAndCheckCls(d, cls);, +		}, +		return classes;, +		assertThat("Smali files not found in " + smaliDir, smaliFileNames, notNullValue());, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestCaseSensitiveChecks.java, +package jadx.tests.integration.names;, +, +import java.util.List;, +import java.util.stream.Collectors;, +, +import org.hamcrest.Matchers;, +import org.junit.jupiter.api.Test;, +, +import jadx.core.Consts;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.emptyString;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.not;, +, +public class TestCaseSensitiveChecks extends SmaliTest {, +	/*, +		public class A {}, +		public class a {}, +	*/, +, +	@Test, +	public void test() {, +		args.setFsCaseSensitive(false);, +, +		List<ClassNode> classes = loadFromSmaliFiles();, +		for (ClassNode cls : classes) {, +			assertThat(cls.getPackage(), is(Consts.DEFAULT_PACKAGE_NAME));, +		}, +		long namesCount = classes.stream().map(cls -> cls.getShortName().toLowerCase()).distinct().count();, +		assertThat(namesCount, is(2L));, +	}, +, +	@Test, +	public void testCaseSensitiveFS() {, +		args.setFsCaseSensitive(true);, +, +		List<ClassNode> classes = loadFromSmaliFiles();, +		for (ClassNode cls : classes) {, +			assertThat(cls.getPackage(), is(Consts.DEFAULT_PACKAGE_NAME));, +		}, +		List<String> names = classes.stream().map(ClassNode::getShortName).collect(Collectors.toList());, +		assertThat(names, Matchers.containsInAnyOrder("A", "a"));, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';, +				oneArgInsn(code, insn, state, op);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';, +				oneArgInsn(code, insn, state, op);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.CallMthInterface;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.IfNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.RegisterArg;, +				return simplifyArith((ArithNode) insn);, +				return convertInvoke(mth, (InvokeNode) insn);, +	private static InsnNode convertInvoke(MethodNode mth, InvokeNode insn) {, +		MethodInfo callMth = insn.getCallMth();, +	private static InsnNode simplifyArith(ArithNode arith) {, +						arith.getResult(), arith.getArg(0),, +			InsnArg firstArg = arith.getArg(0);, +			if (arith.getOp() == ArithOp.XOR && firstArg.getType() == ArgType.BOOLEAN, +					&& (lit == 0 || lit == 1)) {, +				InsnNode node = new InsnNode(lit == 0 ? InsnType.MOVE : InsnType.NOT, 1);, +				node.setResult(arith.getResult());, +				node.addArg(firstArg);, +				return node;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';, +				oneArgInsn(code, insn, state, op);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.CallMthInterface;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.IfNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.RegisterArg;, +				return simplifyArith((ArithNode) insn);, +				return convertInvoke(mth, (InvokeNode) insn);, +	private static InsnNode convertInvoke(MethodNode mth, InvokeNode insn) {, +		MethodInfo callMth = insn.getCallMth();, +	private static InsnNode simplifyArith(ArithNode arith) {, +						arith.getResult(), arith.getArg(0),, +			InsnArg firstArg = arith.getArg(0);, +			if (arith.getOp() == ArithOp.XOR && firstArg.getType() == ArgType.BOOLEAN, +					&& (lit == 0 || lit == 1)) {, +				InsnNode node = new InsnNode(lit == 0 ? InsnType.MOVE : InsnType.NOT, 1);, +				node.setResult(arith.getResult());, +				node.addArg(firstArg);, +				return node;, +			}, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestXor.java, +import jadx.tests.api.SmaliTest;, +public class TestXor extends SmaliTest {, +		public boolean test1() {, +			return test() ^ true;, +		public boolean test2(boolean v) {, +			return v ^ true;, +		}, +, +		public boolean test() {, +	public void test() {, +		assertThat(code, containsOne("return !test();"));, +		assertThat(code, containsOne("return !v;"));, +	}, +, +	@Test, +	public void smali() {, +		/*, +    		public boolean test1() {, +				return test() ^ true;, +			}, +, +			public boolean test2() {, +				return test() ^ false;, +			}, +, +			public boolean test() {, +				return true;, +			}, +		 */, +		ClassNode cls = getClassNodeFromSmaliWithPath("conditions", "TestXor");, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("return !test();"));, +		assertThat(code, containsOne("return test();"));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';, +				oneArgInsn(code, insn, state, op);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.CallMthInterface;, +import jadx.core.dex.instructions.ConstStringNode;]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public void addArgDot(CodeWriter code, InsnArg arg) throws CodegenException {, +		int len = code.length();, +		addArg(code, arg, true);, +		if (len != code.length()) {, +			code.add('.');, +		}, +	}, +, +		addArgDot(code, arg);, +					addArgDot(code, arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public void addArgDot(CodeWriter code, InsnArg arg) throws CodegenException {, +		int len = code.length();, +		addArg(code, arg, true);, +		if (len != code.length()) {, +			code.add('.');, +		}, +	}, +, +		addArgDot(code, arg);, +					addArgDot(code, arg);, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +import jadx.core.codegen.CodeWriter;, +	protected String makeIndent(int indent) {, +		StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT.length());, +		for (int i = 0; i < indent; i++) {, +			sb.append(CodeWriter.INDENT);, +		}, +		return sb.toString();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +	public void addArgDot(CodeWriter code, InsnArg arg) throws CodegenException {, +		int len = code.length();, +		addArg(code, arg, true);, +		if (len != code.length()) {, +			code.add('.');, +		}, +	}, +, +		addArgDot(code, arg);, +					addArgDot(code, arg);, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +import jadx.core.codegen.CodeWriter;, +	protected String makeIndent(int indent) {, +		StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT.length());, +		for (int i = 0; i < indent; i++) {, +			sb.append(CodeWriter.INDENT);, +		}, +		return sb.toString();, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/internal/inner/TestAnonymousClass3.java, +package jadx.tests.internal.inner;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestAnonymousClass3 extends InternalJadxTest {, +, +	public static class TestCls {, +		public static class Inner {, +			private int f;, +			private double d;, +, +			public void test() {, +				new Thread() {, +					@Override, +					public void run() {, +						int a = f--;, +						p(a);, +, +						f += 2;, +						f *= 2;, +, +						a = ++f;, +						p(a);, +, +						d /= 3;, +					}, +, +					public void p(int a) {, +					}, +				}.start();, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import java.util.Objects;, +				return ternary(cond.first(), not(cond.second()), not(cond.third()));, +		if (cond.getCompare() != null) {, +			return new IfCondition(cond.compare.invert());, +		}, +, +	@Override, +	public boolean equals(Object obj) {, +		if (this == obj) {, +			return true;, +		}, +		if (!(obj instanceof IfCondition)) {, +			return false;, +		}, +		IfCondition other = (IfCondition) obj;, +		if (mode != other.mode) {, +			return false;, +		}, +		return Objects.equals(other.args, other.args), +			&& Objects.equals(compare, other.compare);, +	}, +, +	@Override, +	public int hashCode() {, +		int result = super.hashCode();, +		result = 31 * result + mode.hashCode();, +		result = 31 * result + args.hashCode();, +		result = 31 * result + (compare != null ? compare.hashCode() : 0);, +		return result;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import java.util.Objects;, +				return ternary(cond.first(), not(cond.second()), not(cond.third()));, +		if (cond.getCompare() != null) {, +			return new IfCondition(cond.compare.invert());, +		}, +, +	@Override, +	public boolean equals(Object obj) {, +		if (this == obj) {, +			return true;, +		}, +		if (!(obj instanceof IfCondition)) {, +			return false;, +		}, +		IfCondition other = (IfCondition) obj;, +		if (mode != other.mode) {, +			return false;, +		}, +		return Objects.equals(other.args, other.args), +			&& Objects.equals(compare, other.compare);, +	}, +, +	@Override, +	public int hashCode() {, +		int result = super.hashCode();, +		result = 31 * result + mode.hashCode();, +		result = 31 * result + args.hashCode();, +		result = 31 * result + (compare != null ? compare.hashCode() : 0);, +		return result;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java, +			return (!a ? c : b) ? 1 : 2;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import java.util.Objects;, +				return ternary(cond.first(), not(cond.second()), not(cond.third()));, +		if (cond.getCompare() != null) {, +			return new IfCondition(cond.compare.invert());, +		}, +, +	@Override, +	public boolean equals(Object obj) {, +		if (this == obj) {, +			return true;, +		}, +		if (!(obj instanceof IfCondition)) {, +			return false;, +		}, +		IfCondition other = (IfCondition) obj;, +		if (mode != other.mode) {, +			return false;, +		}, +		return Objects.equals(other.args, other.args), +			&& Objects.equals(compare, other.compare);, +	}, +, +	@Override, +	public int hashCode() {, +		int result = super.hashCode();, +		result = 31 * result + mode.hashCode();, +		result = 31 * result + args.hashCode();, +		result = 31 * result + (compare != null ? compare.hashCode() : 0);, +		return result;, +	}, +, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestTernaryInIf.java, +			return (!a ? c : b) ? 1 : 2;]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EliminatePhiNodes());, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EliminatePhiNodes());, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +				boolean wrap = isArgWrapNeeded(firstArg);, +		addArg(code, firstArg, isArgWrapNeeded(firstArg));, +		addArg(code, secondArg, isArgWrapNeeded(secondArg));, +		return !condition.isCompare() && condition.getMode() != IfCondition.Mode.NOT;, +	private static boolean isArgWrapNeeded(InsnArg arg) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.ARITH) {, +		} else {, +			switch (insnType) {, +				case INVOKE:, +				case SGET:, +				case IGET:, +				case AGET:, +				case CONST:, +				case ARRAY_LENGTH:, +				default:, +					return true;, +			}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EliminatePhiNodes());, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +				boolean wrap = isArgWrapNeeded(firstArg);, +		addArg(code, firstArg, isArgWrapNeeded(firstArg));, +		addArg(code, secondArg, isArgWrapNeeded(secondArg));, +		return !condition.isCompare() && condition.getMode() != IfCondition.Mode.NOT;, +	private static boolean isArgWrapNeeded(InsnArg arg) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.ARITH) {, +		} else {, +			switch (insnType) {, +				case INVOKE:, +				case SGET:, +				case IGET:, +				case AGET:, +				case CONST:, +				case ARRAY_LENGTH:, +				default:, +					return true;, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	private AType() {, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EliminatePhiNodes());, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +				boolean wrap = isArgWrapNeeded(firstArg);, +		addArg(code, firstArg, isArgWrapNeeded(firstArg));, +		addArg(code, secondArg, isArgWrapNeeded(secondArg));, +		return !condition.isCompare() && condition.getMode() != IfCondition.Mode.NOT;, +	private static boolean isArgWrapNeeded(InsnArg arg) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.ARITH) {, +		} else {, +			switch (insnType) {, +				case INVOKE:, +				case SGET:, +				case IGET:, +				case AGET:, +				case CONST:, +				case ARRAY_LENGTH:, +				default:, +					return true;, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	private AType() {, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +		return new IfCondition(mode, Arrays.asList(a, b));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			passes.add(new EliminatePhiNodes());, +			if (args.isCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false));, +			}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +				boolean wrap = isArgWrapNeeded(firstArg);, +		addArg(code, firstArg, isArgWrapNeeded(firstArg));]
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +, +	private List<JavaClass> innerClasses = Collections.emptyList();, +	private List<JavaField> fields = Collections.emptyList();, +	private List<JavaMethod> methods = Collections.emptyList();, +	}, +, +	public void decompile() {, +		decompiler.processClass(cls);, +		if (inClsCount != 0) {, +				if (!inner.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (fieldsCount != 0) {, +				if (!f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (methodsCount != 0) {, +				if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					mths.add(new JavaMethod(this, m));, +			decompile();, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +, +	private List<JavaClass> innerClasses = Collections.emptyList();, +	private List<JavaField> fields = Collections.emptyList();, +	private List<JavaMethod> methods = Collections.emptyList();, +	}, +, +	public void decompile() {, +		decompiler.processClass(cls);, +		if (inClsCount != 0) {, +				if (!inner.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (fieldsCount != 0) {, +				if (!f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (methodsCount != 0) {, +				if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					mths.add(new JavaMethod(this, m));, +			decompile();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +	private final JavaClass parent;, +	public JavaMethod(JavaClass cls, MethodNode m) {, +		this.parent = cls;, +		return mth.getMethodInfo().getName();, +, +	public JavaClass getDeclaringClass() {, +		return parent;, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +, +	private List<JavaClass> innerClasses = Collections.emptyList();, +	private List<JavaField> fields = Collections.emptyList();, +	private List<JavaMethod> methods = Collections.emptyList();, +	}, +, +	public void decompile() {, +		decompiler.processClass(cls);, +		if (inClsCount != 0) {, +				if (!inner.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (fieldsCount != 0) {, +				if (!f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (methodsCount != 0) {, +				if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					mths.add(new JavaMethod(this, m));, +			decompile();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +	private final JavaClass parent;, +	public JavaMethod(JavaClass cls, MethodNode m) {, +		this.parent = cls;, +		return mth.getMethodInfo().getName();, +, +	public JavaClass getDeclaringClass() {, +		return parent;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			if (mth.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +			if (it.hasNext()) {, +		}, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +, +	private List<JavaClass> innerClasses = Collections.emptyList();, +	private List<JavaField> fields = Collections.emptyList();, +	private List<JavaMethod> methods = Collections.emptyList();, +	}, +, +	public void decompile() {, +		decompiler.processClass(cls);, +		if (inClsCount != 0) {, +				if (!inner.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (fieldsCount != 0) {, +				if (!f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +			}, +		if (methodsCount != 0) {, +				if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, +					mths.add(new JavaMethod(this, m));]
[+++ b/build.gradle, +    apply plugin: 'groovy', +, +        testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , +        // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/build.gradle, +    apply plugin: 'groovy', +, +        testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , +        // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/jadx-core/build.gradle, +task packTests(type: Jar) {, +    classifier = 'tests', +    from sourceSets.test.output, +}, +, +++ b/build.gradle, +    apply plugin: 'groovy', +, +        testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , +        // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/jadx-core/build.gradle, +task packTests(type: Jar) {, +    classifier = 'tests', +    from sourceSets.test.output, +}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +			return Collections.emptyMap();, +++ b/build.gradle, +    apply plugin: 'groovy', +, +        testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , +        // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/jadx-core/build.gradle, +task packTests(type: Jar) {, +    classifier = 'tests', +    from sourceSets.test.output, +}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, +			return Collections.emptyMap();, +++ b/jadx-core/src/test/groovy/jadx/tests/TestSignatureParser.groovy, +package jadx.tests, +, +import jadx.core.dex.instructions.args.ArgType, +import jadx.core.dex.nodes.parser.SignatureParser, +import spock.lang.Specification, +, +import static jadx.core.dex.instructions.args.ArgType.*, +, +class TestSignatureParser extends Specification {, +    def "simple types"() {, +        expect:, +        new SignatureParser(str).consumeType() == result, +, +        where:, +        str                   | result, +        ""                    | null, +        "I"                   | INT, +        "[I"                  | array(INT), +        "Ljava/lang/Object;"  | OBJECT, +        "[Ljava/lang/Object;" | array(OBJECT), +        "[[I"                 | array(array(INT)), +    }, +, +    def "generics"() {, +        expect:, +        new SignatureParser(str).consumeType() == result, +, +        where:, +        str               | result, +        "TD;"             | genericType("D"), +        "La<TV;Lb;>;"     | generic("La;", genericType("V"), object("b")), +        "La<Lb<Lc;>;>;"   | generic("La;", generic("Lb;", object("Lc;"))), +        "La<TD;>.c;"      | genericInner(generic("La;", genericType("D")), "c", null), +        "La<Lb;>.c<TV;>;" | genericInner(generic("La;", object("Lb;")), "c", genericType("V")), +    }, +, +    def "inner generic"() {, +        expect:, +        new SignatureParser(str).consumeType().getObject() == result, +, +        where:, +        str                                           | result, +        "La<TV;>.LinkedHashIterator<Lb\$c<Ls;TV;>;>;" | "a\$LinkedHashIterator", +    }, +, +    def "wildcards"() {, +        expect:, +        new SignatureParser("La<$s>;").consumeType() == generic("La;", r as ArgType[]), +, +        where:, +        s       | r, +        "*"     | wildcard(), +        "+Lb;"  | wildcard(object("b"), 1), +        "-Lb;"  | wildcard(object("b"), -1), +        "+TV;"  | wildcard(genericType("V"), 1), +        "-TV;"  | wildcard(genericType("V"), -1), +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + * uses generic type for omit cast after 'AttributeStorage.get' method, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + * uses generic type for omit cast after 'AttributeStorage.get' method, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +		attributes = new IdentityHashMap<AType<?>, IAttribute>();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +	private MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, +		this.name = name;, +		alias = name;, +		aliasFromPreset = false;, +		this.declClass = declClass;, +, +		this.args = args;, +		this.retType = retType;, +		shortId = makeSignature(true);, +	}, +, +	public static MethodInfo externalMth(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, +		return new MethodInfo(declClass, name, args, retType);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +	private MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, +		this.name = name;, +		alias = name;, +		aliasFromPreset = false;, +		this.declClass = declClass;, +, +		this.args = args;, +		this.retType = retType;, +		shortId = makeSignature(true);, +	}, +, +	public static MethodInfo externalMth(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, +		return new MethodInfo(declClass, name, args, retType);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +	public InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +	private MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, +		this.name = name;, +		alias = name;, +		aliasFromPreset = false;, +		this.declClass = declClass;, +, +		this.args = args;, +		this.retType = retType;, +		shortId = makeSignature(true);, +	}, +, +	public static MethodInfo externalMth(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, +		return new MethodInfo(declClass, name, args, retType);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +	public InvokeNode(MethodInfo mth, InvokeType invokeType, int argsCount) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.deobf.NameMapper;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.instructions.InvokeType;, +import jadx.core.dex.nodes.RootNode;, +			case CONSTRUCTOR:, +				simplfyConstructor(mth.root(), (ConstructorInsn) insn);, +				break;, +, +	private static void simplfyConstructor(RootNode root, ConstructorInsn insn) {, +		if (insn.getArgsCount() != 0, +				&& insn.getCallMth().getDeclClass().getType().equals(ArgType.STRING)) {, +			InsnArg arg = insn.getArg(0);, +			InsnNode node = arg.isInsnWrap(), +					? ((InsnWrapArg) arg).getWrapInsn(), +					: insn;, +		    if (node.getArgsCount() != 0) {, +		    	ArgType argType = node.getArg(0).getType();, +		    	if (node.getType() == InsnType.FILLED_NEW_ARRAY, +		    			&& (argType == ArgType.BYTE || argType == ArgType.CHAR)) {, +		    		int printable = 0;, +		    		byte[] arr = new byte[node.getArgsCount()];, +		    		for (int i = 0; i < arr.length; i++) {, +		    			arr[i] = (byte) ((LiteralArg) node.getArg(i)).getLiteral();, +		    			if (NameMapper.isPrintableChar(arr[i])) {, +		    				printable++;, +		    			}, +		    		}, +		    		if (printable >= arr.length - printable) {, +		    			InsnWrapArg wa = new InsnWrapArg(new ConstStringNode(new String(arr)));, +		    			if (insn.getArgsCount() == 1) {, +		    				insn.setArg(0, wa);, +		    			} else {, +		    				MethodInfo mi = MethodInfo.externalMth(, +		    						ClassInfo.fromType(root, ArgType.STRING),, +		    						"getBytes",, +		    						Collections.emptyList(),, +		    						ArgType.array(ArgType.BYTE));, +		    				InvokeNode in = new InvokeNode(mi, InvokeType.VIRTUAL, 1);, +		    				in.addArg(wa);, +		    				insn.setArg(0, new InsnWrapArg(in));, +		    			}, +		    		}, +		    	}, +		    }, +		}, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		boolean badThen = thenBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(thenBlock, info);, +		boolean badElse = elseBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(elseBlock, info);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +		boolean badThen = thenBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(thenBlock, info);, +		boolean badElse = elseBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(elseBlock, info);, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopDetection4.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.util.Iterator;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopDetection4 extends InternalJadxTest {, +, +	public static class TestCls {, +		private Iterator<String> iterator;, +		private SomeCls filter;, +, +		private String test() {, +			while (iterator.hasNext()) {, +				String next = iterator.next();, +				String filtered = filter.filter(next);, +				if (filtered != null) {, +					return filtered;, +				}, +			}, +			return null;, +		}, +, +		private class SomeCls {, +			public String filter(String str) {, +				return str;, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsOne("while (this.iterator.hasNext()) {"));, +		assertThat(code, containsOne("if (filtered != null) {"));, +		assertThat(code, containsOne("return filtered;"));, +		assertThat(code, containsOne("return null;"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (!insn.contains(AFlag.DECLARE_VAR)) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (!insn.contains(AFlag.DECLARE_VAR)) {, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java, +package jadx.tests.integration.arrays;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import org.junit.jupiter.api.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestArrayInit extends IntegrationTest {, +, +	public static class TestCls {, +, +		byte[] bytes;, +, +		@SuppressWarnings("unused"), +		public void test() {, +			byte[] arr = new byte[]{10, 20, 30};, +		}, +, +		public void test2() {, +			bytes = new byte[]{10, 20, 30};, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("= {10, 20, 30};"));, +		assertThat(code, containsString("this.bytes = new byte[]{10, 20, 30};"));, +	}, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (!insn.contains(AFlag.DECLARE_VAR)) {, +		}, +++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java, +package jadx.tests.integration.arrays;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import org.junit.jupiter.api.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestArrayInit extends IntegrationTest {, +, +	public static class TestCls {, +, +		byte[] bytes;, +, +		@SuppressWarnings("unused"), +		public void test() {, +			byte[] arr = new byte[]{10, 20, 30};, +		}, +, +		public void test2() {, +			bytes = new byte[]{10, 20, 30};, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("= {10, 20, 30};"));, +		assertThat(code, containsString("this.bytes = new byte[]{10, 20, 30};"));, +	}, +}, +++ b/jadx-core/src/test/java/jadx/tests/integration/inline/TestInline2.java, +		assertThat(code, containsOne("int[] a = {1, 2, 4, 6, 8};"));]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (arg.isThis()) {, +			return RegisterArg.THIS_ARG_NAME;, +		}, +		String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (arg.isThis()) {, +			return RegisterArg.THIS_ARG_NAME;, +		}, +		String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (arg.isThis()) {, +			return RegisterArg.THIS_ARG_NAME;, +		}, +		String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public static final String THIS_ARG_NAME = "this";, +, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		}, +		if (!isAttrStorageEmpty()) {, +			sb.append(' ').append(getAttributesString());, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (arg.isThis()) {, +			return RegisterArg.THIS_ARG_NAME;, +		}, +		String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public static final String THIS_ARG_NAME = "this";, +, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		}, +		if (!isAttrStorageEmpty()) {, +			sb.append(' ').append(getAttributesString());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (arg.isThis()) {, +			return RegisterArg.THIS_ARG_NAME;, +		}, +		String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public static final String THIS_ARG_NAME = "this";, +, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		}, +		if (!isAttrStorageEmpty()) {, +			sb.append(' ').append(getAttributesString());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +			if (assignPos >= inlineBorder || !canMove(assignPos, inlineBorder)) {, +				// allow inline only one use arg, +						|| sVar.getVariableUseCount() != 1, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +		if (arg.isThis()) {, +			return RegisterArg.THIS_ARG_NAME;, +		}, +		String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +		return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +	public static final String THIS_ARG_NAME = "this";, +, +		if (isThis()) {, +			return THIS_ARG_NAME;, +		}, +		if (!isAttrStorageEmpty()) {, +			sb.append(' ').append(getAttributesString());, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +			if (assignPos >= inlineBorder || !canMove(assignPos, inlineBorder)) {, +				// allow inline only one use arg, +						|| sVar.getVariableUseCount() != 1, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +		markThisArgs(mth.getThisArg());, +	private static void markThisArgs(RegisterArg thisArg) {, +			markOneArgAsThis(thisArg);, +			thisArg.getSVar().getUseList().forEach(SSATransform::markOneArgAsThis);, +		}, +	}, +, +	private static void markOneArgAsThis(RegisterArg arg) {, +		if (arg == null) {, +			return;, +		}, +		arg.add(AFlag.THIS);]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxTextArea.java, +package jadx.gui;, +, +import jadx.api.CodePosition;, +import jadx.gui.treemodel.JClass;, +, +import javax.swing.event.HyperlinkEvent;, +import javax.swing.event.HyperlinkListener;, +import javax.swing.text.BadLocationException;, +import java.awt.Color;, +, +import org.fife.ui.rsyntaxtextarea.LinkGenerator;, +import org.fife.ui.rsyntaxtextarea.LinkGeneratorResult;, +import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +import org.fife.ui.rsyntaxtextarea.SyntaxScheme;, +import org.fife.ui.rsyntaxtextarea.Token;, +import org.fife.ui.rsyntaxtextarea.TokenTypes;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +public class JadxTextArea extends RSyntaxTextArea {, +	private static final Logger LOG = LoggerFactory.getLogger(JadxTextArea.class);, +, +	private static final Color BACKGROUND = new Color(0xf7f7f7);, +	private static final Color JUMP_FOREGROUND = new Color(0x785523);, +	private static final Color JUMP_BACKGROUND = new Color(0xE6E6FF);, +, +	private final JClass cls;, +	private final MainWindow rootWindow;, +, +, +	public JadxTextArea(MainWindow mainWindow, JClass cls) {, +		this.rootWindow = mainWindow;, +		this.cls = cls;, +, +		setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVA);, +		SyntaxScheme scheme = getSyntaxScheme();, +		scheme.getStyle(Token.FUNCTION).foreground = Color.BLACK;, +, +		setMarkOccurrences(true);, +		setBackground(BACKGROUND);, +		setAntiAliasingEnabled(true);, +		setEditable(false);, +		getCaret().setVisible(true);, +, +		setHyperlinksEnabled(true);, +		CodeLinkGenerator codeLinkProcessor = new CodeLinkGenerator(cls);, +		setLinkGenerator(codeLinkProcessor);, +		addHyperlinkListener(codeLinkProcessor);, +, +		setText(cls.getCode());, +	}, +, +	private boolean isJumpToken(Token token) {, +		if (token.getType() == TokenTypes.IDENTIFIER) {, +			CodePosition pos = getCodePosition(cls, this, token.getOffset());, +			if (pos != null) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	@Override, +	public boolean getUnderlineForToken(Token t) {, +		if (isJumpToken(t)) {, +			return true;, +		}, +		return super.getUnderlineForToken(t);, +	}, +, +	static CodePosition getCodePosition(JClass jCls, RSyntaxTextArea textArea, int offset) {, +		try {, +			int line = textArea.getLineOfOffset(offset);, +			int lineOffset = offset - textArea.getLineStartOffset(line);, +			return jCls.getCls().getDefinitionPosition(line + 1, lineOffset + 1);, +		} catch (BadLocationException e) {, +			LOG.error("Can't get line by offset", e);, +			return null;, +		}, +	}, +, +	private class CodeLinkGenerator implements LinkGenerator, HyperlinkListener {, +		private final JClass jCls;, +, +		public CodeLinkGenerator(JClass cls) {, +			this.jCls = cls;, +		}, +, +		@Override, +		public LinkGeneratorResult isLinkAtOffset(RSyntaxTextArea textArea, int offset) {, +			try {, +				Token token = textArea.modelToToken(offset);, +				if (token != null) {, +					offset = token.getOffset();, +				}, +				final CodePosition defPos = getCodePosition(jCls, textArea, offset);, +				if (defPos != null) {, +					final int sourceOffset = offset;]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.BlockNode;, +		BlockNode header = region.getHeader();, +		if (header != null) {, +			List<InsnNode> headerInsns = header.getInstructions();, +			if (headerInsns.size() > 1) {, +				// write not inlined instructions from header, +				mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +				for (int i = 0; i < headerInsns.size() - 1; i++) {, +					InsnNode insn = headerInsns.get(i);, +					makeInsn(insn, code);, +				}, +			}, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.BlockNode;, +		BlockNode header = region.getHeader();, +		if (header != null) {, +			List<InsnNode> headerInsns = header.getInstructions();, +			if (headerInsns.size() > 1) {, +				// write not inlined instructions from header, +				mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +				for (int i = 0; i < headerInsns.size() - 1; i++) {, +					InsnNode insn = headerInsns.get(i);, +					makeInsn(insn, code);, +				}, +			}, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.BlockNode;, +		BlockNode header = region.getHeader();, +		if (header != null) {, +			List<InsnNode> headerInsns = header.getInstructions();, +			if (headerInsns.size() > 1) {, +				// write not inlined instructions from header, +				mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +				for (int i = 0; i < headerInsns.size() - 1; i++) {, +					InsnNode insn = headerInsns.get(i);, +					makeInsn(insn, code);, +				}, +			}, +		}, +]
[+++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.util.function.Consumer;, +	private void partialSync(Consumer<JadxSettings> updater) {, +		updater.accept(settings);]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +				String rfName = rf.getName().toUpperCase();, +				if (rfName.endsWith(".DSA")||rfName.endsWith(".RSA")) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		return mthInfo.getName();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +		return mthInfo.getName();, +++ b/jadx-core/src/test/java/jadx/tests/internal/names/TestSameMethodsNames.java, +package jadx.tests.internal.names;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestSameMethodsNames extends InternalJadxTest {, +, +	public static class TestCls<V> {, +, +		public static void test() {, +			new Bug().Bug();, +		}, +, +		public static class Bug {, +			public Bug() {, +				System.out.println("constructor");, +			}, +, +			void Bug() {, +				System.out.println("Bug");, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +		System.out.println(code);, +, +		assertThat(code, containsOne("new Bug().Bug();"));, +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +						deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));, +		return clsPresetMap.get(cls.makeRawFullName());, +++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +						deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));, +		return clsPresetMap.get(cls.makeRawFullName());, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +	public String makeRawFullName() {, +		return makeFullClsName(this.name, true);, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +import static jadx.core.utils.StringUtils.notEmpty;, +, +		return notEmpty(str), +				&& VALID_JAVA_IDENTIFIER.matcher(str).matches(), +				&& isAllCharsPrintable(str);, +		return notEmpty(str), +				&& VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches(), +				&& isAllCharsPrintable(str);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +import static jadx.core.utils.StringUtils.notEmpty;, +, +		return notEmpty(str), +				&& VALID_JAVA_IDENTIFIER.matcher(str).matches(), +				&& isAllCharsPrintable(str);, +		return notEmpty(str), +				&& VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches(), +				&& isAllCharsPrintable(str);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import jadx.core.deobf.NameMapper;, +			applyDebugInfo(reg, var);, +		}, +	}, +, +	private static void applyDebugInfo(RegisterArg reg, LocalVar var) {, +		String varName = var.getName();, +		if (NameMapper.isValidIdentifier(varName)) {, +			reg.mergeDebugInfo(var.getType(), varName);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +import static jadx.core.utils.StringUtils.notEmpty;, +, +		return notEmpty(str), +				&& VALID_JAVA_IDENTIFIER.matcher(str).matches(), +				&& isAllCharsPrintable(str);, +		return notEmpty(str), +				&& VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches(), +				&& isAllCharsPrintable(str);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import jadx.core.deobf.NameMapper;, +			applyDebugInfo(reg, var);, +		}, +	}, +, +	private static void applyDebugInfo(RegisterArg reg, LocalVar var) {, +		String varName = var.getName();, +		if (NameMapper.isValidIdentifier(varName)) {, +			reg.mergeDebugInfo(var.getType(), varName);, +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, +	public static boolean notEmpty(String str) {, +		return str != null && !str.isEmpty();, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			addImport(classInfo);, +	private void addImport(ClassInfo classInfo) {, +		if (parentGen != null) {, +			parentGen.addImport(classInfo);, +		} else {, +			imports.add(classInfo);, +		}, +	}, +, +		if (classNode != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			addImport(classInfo);, +	private void addImport(ClassInfo classInfo) {, +		if (parentGen != null) {, +			parentGen.addImport(classInfo);, +		} else {, +			imports.add(classInfo);, +		}, +	}, +, +		if (classNode != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				regArg.replaceTypedVar(f);, +				if (wrap) {, +					code.add('(');, +				}, +					code.add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			addImport(classInfo);, +	private void addImport(ClassInfo classInfo) {, +		if (parentGen != null) {, +			parentGen.addImport(classInfo);, +		} else {, +			imports.add(classInfo);, +		}, +	}, +, +		if (classNode != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				regArg.replaceTypedVar(f);, +				if (wrap) {, +					code.add('(');, +				}, +					code.add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			addImport(classInfo);, +	private void addImport(ClassInfo classInfo) {, +		if (parentGen != null) {, +			parentGen.addImport(classInfo);, +		} else {, +			imports.add(classInfo);, +		}, +	}, +, +		if (classNode != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				regArg.replaceTypedVar(f);, +				if (wrap) {, +					code.add('(');, +				}, +					code.add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/BlockRegState.java, +		regs[arg.getRegNum()] = arg;, +		arg.getTypedVar().getUseList().add(arg);, +		RegisterArg reg = regs[arg.getRegNum()];, +		TypedVar regType = reg.getTypedVar();, +			reg.forceSetTypedVar(regType);, +		arg.replaceTypedVar(reg);, +		reg.getTypedVar().getUseList().add(arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +			addImport(classInfo);, +	private void addImport(ClassInfo classInfo) {, +		if (parentGen != null) {, +			parentGen.addImport(classInfo);, +		} else {, +			imports.add(classInfo);, +		}, +	}, +, +		if (classNode != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				regArg.replaceTypedVar(f);, +				if (wrap) {, +					code.add('(');, +				}, +					code.add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/BlockRegState.java, +		regs[arg.getRegNum()] = arg;, +		arg.getTypedVar().getUseList().add(arg);, +		RegisterArg reg = regs[arg.getRegNum()];, +		TypedVar regType = reg.getTypedVar();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +						&& parentClass.equals(fieldsCls.getClassInfo()), +						&& field.getName().startsWith("this$") /* TODO: don't check name */) {, +		if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +						&& parentClass.equals(fieldsCls.getClassInfo()), +						&& field.getName().startsWith("this$") /* TODO: don't check name */) {, +		if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import java.util.List;, +, +			BlockNode returnBlock = mth.getBasicBlocks().get(1);, +			if (returnBlock.contains(AFlag.RETURN) || returnBlock.getInstructions().isEmpty()) {, +				BlockNode firstBlock = mth.getBasicBlocks().get(0);, +				inlineMth(mth, firstBlock, returnBlock);, +	private static void inlineMth(MethodNode mth, BlockNode firstBlock, BlockNode returnBlock) {, +		List<InsnNode> insnList = firstBlock.getInstructions();, +		if (insnList.isEmpty()) {, +			return;, +		}, +		if (insnList.size() == 1) {, +			addInlineAttr(mth, insnList.get(0));, +			return;, +		}, +		// other field operations, +		if (insnList.size() == 2, +				&& returnBlock.getInstructions().size() == 1, +				&& !mth.getReturnType().equals(ArgType.VOID)) {, +			InsnNode get = insnList.get(0);, +			InsnNode put = insnList.get(1);, +			InsnArg retArg = returnBlock.getInstructions().get(0).getArg(0);, +			if (get.getType() == InsnType.IGET, +					&& put.getType() == InsnType.IPUT, +					&& retArg.isRegister(), +					&& get.getResult().equalRegisterAndType((RegisterArg) retArg)) {, +				RegisterArg retReg = (RegisterArg) retArg;, +				retReg.getSVar().removeUse(retReg);, +				CodeShrinker.shrinkMethod(mth);, +, +				insnList = firstBlock.getInstructions();, +				if (insnList.size() == 1) {, +					addInlineAttr(mth, insnList.get(0));, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +						&& parentClass.equals(fieldsCls.getClassInfo()), +						&& field.getName().startsWith("this$") /* TODO: don't check name */) {, +		if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import java.util.List;, +, +			BlockNode returnBlock = mth.getBasicBlocks().get(1);, +			if (returnBlock.contains(AFlag.RETURN) || returnBlock.getInstructions().isEmpty()) {, +				BlockNode firstBlock = mth.getBasicBlocks().get(0);, +				inlineMth(mth, firstBlock, returnBlock);, +	private static void inlineMth(MethodNode mth, BlockNode firstBlock, BlockNode returnBlock) {, +		List<InsnNode> insnList = firstBlock.getInstructions();, +		if (insnList.isEmpty()) {, +			return;, +		}, +		if (insnList.size() == 1) {, +			addInlineAttr(mth, insnList.get(0));, +			return;, +		}, +		// other field operations, +		if (insnList.size() == 2, +				&& returnBlock.getInstructions().size() == 1, +				&& !mth.getReturnType().equals(ArgType.VOID)) {, +			InsnNode get = insnList.get(0);, +			InsnNode put = insnList.get(1);, +			InsnArg retArg = returnBlock.getInstructions().get(0).getArg(0);, +			if (get.getType() == InsnType.IGET, +					&& put.getType() == InsnType.IPUT, +					&& retArg.isRegister(), +					&& get.getResult().equalRegisterAndType((RegisterArg) retArg)) {, +				RegisterArg retReg = (RegisterArg) retArg;, +				retReg.getSVar().removeUse(retReg);, +				CodeShrinker.shrinkMethod(mth);, +, +				insnList = firstBlock.getInstructions();, +				if (insnList.size() == 1) {, +					addInlineAttr(mth, insnList.get(0));, +				}, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestAnonymousClass5.java, +package jadx.tests.integration.inner;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.Map;, +]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +				if (cls.getFullName().equals(exclude), +						|| cls.getFullName().startsWith(exclude + '.')) {, +		if (excludedPackages.isEmpty()) {, +			return Collections.emptyList();, +		}, +		String newExclusion = settings.getExcludedPackages() + ' ' + packageToExclude;, +		settings.setExcludedPackages(newExclusion.trim());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +				if (cls.getFullName().equals(exclude), +						|| cls.getFullName().startsWith(exclude + '.')) {, +		if (excludedPackages.isEmpty()) {, +			return Collections.emptyList();, +		}, +		String newExclusion = settings.getExcludedPackages() + ' ' + packageToExclude;, +		settings.setExcludedPackages(newExclusion.trim());, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, +				|| excludedPackages.stream().filter(p -> !p.isEmpty()), +					.noneMatch(p -> name.equals(p) || name.startsWith(p + '.'));]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			insertContinue(loop);, +					insertBreak(stack, loopExit, exitEdge);, +		insertContinue(loop);, +			if (insertBreak(stack, exit, exitEdge)) {, +	private boolean insertBreak(RegionStack stack, BlockNode loopExit, Edge exitEdge) {, +		addBreakLabel(exitEdge, exit, breakInsn);, +	private void addBreakLabel(Edge exitEdge, BlockNode exit, InsnNode breakInsn) {, +		BlockNode outBlock = BlockUtils.getNextBlock(exitEdge.getTarget());, +		if (outBlock == null) {, +			return;, +		}, +		List<LoopInfo> exitLoop = mth.getAllLoopsForBlock(outBlock);, +		if (!exitLoop.isEmpty()) {, +			return;, +		}, +		List<LoopInfo> inLoops = mth.getAllLoopsForBlock(exitEdge.getSource());, +		if (inLoops.size() < 2) {, +			return;, +		}, +		// search for parent loop, +		LoopInfo parentLoop = null;, +		for (LoopInfo loop : inLoops) {, +			if (loop.getParentLoop() == null) {, +				parentLoop = loop;, +				break;, +			}, +		}, +		if (parentLoop == null) {, +			return;, +		}, +		if (parentLoop.getEnd() != exit && !parentLoop.getExitNodes().contains(exit)) {, +			LoopLabelAttr labelAttr = new LoopLabelAttr(parentLoop);, +			breakInsn.addAttr(labelAttr);, +			parentLoop.getStart().addAttr(labelAttr);, +		}, +	}, +, +	private static void insertContinue(LoopInfo loop) {, +		Set<BlockNode> loopExitNodes = loop.getExitNodes();, +			if (canInsertContinue(pred, predecessors, loopEnd, loopExitNodes)) {, +, +	private static boolean canInsertContinue(BlockNode pred, List<BlockNode> predecessors, BlockNode loopEnd,, +			Set<BlockNode> loopExitNodes) {, +		if (!pred.contains(AFlag.SYNTHETIC), +				|| BlockUtils.checkLastInsnType(pred, InsnType.CONTINUE)) {, +			return false;, +		List<BlockNode> preds = pred.getPredecessors();, +		if (preds.isEmpty()) {, +			return false;, +		}, +		BlockNode codePred = preds.get(0);, +		if (codePred.contains(AFlag.SKIP)) {, +			return false;, +		}, +		if (loopEnd.isDominator(codePred), +				|| loopExitNodes.contains(codePred)) {, +			return false;, +		}, +		if (isDominatedOnBlocks(codePred, predecessors)) {, +			return false;, +		}, +		boolean gotoExit = false;, +		for (BlockNode exit : loopExitNodes) {, +			if (BlockUtils.isPathExists(codePred, exit)) {, +				gotoExit = true;, +				break;, +			}, +		}, +		return gotoExit;, +		for (Map.Entry<Integer, List<Object>> entry : casesMap.entrySet()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			insertContinue(loop);, +					insertBreak(stack, loopExit, exitEdge);, +		insertContinue(loop);, +			if (insertBreak(stack, exit, exitEdge)) {, +	private boolean insertBreak(RegionStack stack, BlockNode loopExit, Edge exitEdge) {, +		addBreakLabel(exitEdge, exit, breakInsn);, +	private void addBreakLabel(Edge exitEdge, BlockNode exit, InsnNode breakInsn) {, +		BlockNode outBlock = BlockUtils.getNextBlock(exitEdge.getTarget());, +		if (outBlock == null) {, +			return;, +		}, +		List<LoopInfo> exitLoop = mth.getAllLoopsForBlock(outBlock);, +		if (!exitLoop.isEmpty()) {, +			return;, +		}, +		List<LoopInfo> inLoops = mth.getAllLoopsForBlock(exitEdge.getSource());, +		if (inLoops.size() < 2) {, +			return;, +		}, +		// search for parent loop, +		LoopInfo parentLoop = null;, +		for (LoopInfo loop : inLoops) {, +			if (loop.getParentLoop() == null) {, +				parentLoop = loop;, +				break;, +			}, +		}, +		if (parentLoop == null) {]
[+++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, +	private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, +				executor.execute(new ResourcesSaver(outDir, resourceFile));, +	synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, +	private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, +				executor.execute(new ResourcesSaver(outDir, resourceFile));, +	synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +	public ResContainer getContent() {, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, +	private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, +				executor.execute(new ResourcesSaver(outDir, resourceFile));, +	synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +	public ResContainer getContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +package jadx.api;, +, +import jadx.core.codegen.CodeWriter;, +import jadx.core.xmlgen.ResContainer;, +, +public class ResourceFileContent extends ResourceFile {, +, +	private final CodeWriter content;, +, +	public ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +		super(null, name, type);, +		this.content = content;, +	}, +, +	@Override, +	public ResContainer getContent() {, +		return ResContainer.singleFile(getName(), content);, +	}, +}, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, +	private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, +				executor.execute(new ResourcesSaver(outDir, resourceFile));, +	synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +	public ResContainer getContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +package jadx.api;, +, +import jadx.core.codegen.CodeWriter;, +import jadx.core.xmlgen.ResContainer;, +, +public class ResourceFileContent extends ResourceFile {, +, +	private final CodeWriter content;, +, +	public ResourceFileContent(String name, ResourceType type, CodeWriter content) {, +		super(null, name, type);, +		this.content = content;, +	}, +, +	@Override, +	public ResContainer getContent() {, +		return ResContainer.singleFile(getName(), content);, +	}, +}, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +			case ARSC:, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, +	private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, +				executor.execute(new ResourcesSaver(outDir, resourceFile));, +	synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +	public ResContainer getContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +package jadx.api;, +, +import jadx.core.codegen.CodeWriter;, +import jadx.core.xmlgen.ResContainer;, +, +public class ResourceFileContent extends ResourceFile {, +, +	private final CodeWriter content;, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		if (classInfo.getAlias().getPackage().isEmpty()) {, +			String fullName = classInfo.makeFullClsName(classInfo.getAlias().getShortName(), true);, +			String newFullName = Consts.DEFAULT_PACKAGE_NAME + "." + fullName;, +			classInfo.rename(cls.dex(), newFullName);, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		if (classInfo.getAlias().getPackage().isEmpty()) {, +			String fullName = classInfo.makeFullClsName(classInfo.getAlias().getShortName(), true);, +			String newFullName = Consts.DEFAULT_PACKAGE_NAME + "." + fullName;, +			classInfo.rename(cls.dex(), newFullName);, +		}, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.empty;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.notNullValue;, +		assertThat("Class not found: " + clsName, cls, notNullValue());, +		assertThat(clsName, is(cls.getClassInfo().getFullName()));, +			throw (AssertionError) cause;, +		assertThat("File list is empty", list, not(empty()));, +		assertThat("Test source file not found: " + fileName, file.exists(), is(true));, +		List<File> compileFileList = Collections.singletonList(file);, +		List<File> files = StaticCompiler.compile(compileFileList, outTmp, withDebugInfo);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +		if (classInfo.getAlias().getPackage().isEmpty()) {, +			String fullName = classInfo.makeFullClsName(classInfo.getAlias().getShortName(), true);, +			String newFullName = Consts.DEFAULT_PACKAGE_NAME + "." + fullName;, +			classInfo.rename(cls.dex(), newFullName);, +		}, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.empty;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.notNullValue;, +		assertThat("Class not found: " + clsName, cls, notNullValue());, +		assertThat(clsName, is(cls.getClassInfo().getFullName()));, +			throw (AssertionError) cause;, +		assertThat("File list is empty", list, not(empty()));, +		assertThat("Test source file not found: " + fileName, file.exists(), is(true));, +		List<File> compileFileList = Collections.singletonList(file);, +		List<File> files = StaticCompiler.compile(compileFileList, outTmp, withDebugInfo);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, +			LOG.debug("Loaded settings: {}", makeString(settings));]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +, +				try (InputStream inputStream = new BufferedInputStream(new FileInputStream(file))) {, +					return decoder.decode(file.length(), inputStream);, +			} else {, +				try (ZipFile zipFile = new ZipFile(zipRef.getZipFile())) {, +					ZipEntry entry = zipFile.getEntry(zipRef.getEntryName());, +					if (!ZipSecurity.isValidZipEntry(entry)) {, +						return null;, +					try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) {, +						return decoder.decode(entry.getSize(), inputStream);, +					}, +				}, +			}, +, +			default:, +	}, +		try (ZipFile zip = new ZipFile(file)) {, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +, +				try (InputStream inputStream = new BufferedInputStream(new FileInputStream(file))) {, +					return decoder.decode(file.length(), inputStream);, +			} else {, +				try (ZipFile zipFile = new ZipFile(zipRef.getZipFile())) {, +					ZipEntry entry = zipFile.getEntry(zipRef.getEntryName());, +					if (!ZipSecurity.isValidZipEntry(entry)) {, +						return null;, +					try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) {, +						return decoder.decode(entry.getSize(), inputStream);, +					}, +				}, +			}, +, +			default:, +	}, +		try (ZipFile zip = new ZipFile(file)) {, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	private Consts() {, +	}, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +, +				try (InputStream inputStream = new BufferedInputStream(new FileInputStream(file))) {, +					return decoder.decode(file.length(), inputStream);, +			} else {, +				try (ZipFile zipFile = new ZipFile(zipRef.getZipFile())) {, +					ZipEntry entry = zipFile.getEntry(zipRef.getEntryName());, +					if (!ZipSecurity.isValidZipEntry(entry)) {, +						return null;, +					try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) {, +						return decoder.decode(entry.getSize(), inputStream);, +					}, +				}, +			}, +, +			default:, +	}, +		try (ZipFile zip = new ZipFile(file)) {, +		} catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, +	private Consts() {, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.HashSet;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Map;, +import java.util.Map.Entry;, +import java.util.Set;, +]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +	protected boolean highlightTextCaseInsensitive = false;, +				searchContext.setMatchCase(!highlightTextCaseInsensitive);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +	protected boolean highlightTextCaseInsensitive = false;, +				searchContext.setMatchCase(!highlightTextCaseInsensitive);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JCheckBox caseChBox;, +		boolean caseInsensitive = caseChBox.isSelected();, +			resultsModel.addAll(index.searchClsName(text, caseInsensitive));, +			resultsModel.addAll(index.searchMthName(text, caseInsensitive));, +			resultsModel.addAll(index.searchFldName(text, caseInsensitive));, +			resultsModel.addAll(index.searchCode(text, caseInsensitive));, +		highlightTextCaseInsensitive = caseInsensitive;, +		caseChBox = new JCheckBox(NLS.str("search_dialog.ignorecase"));, +		caseChBox.addItemListener(new ItemListener() {, +			public void itemStateChanged(ItemEvent e) {, +				performSearch();, +			}, +		});, +, +		JPanel searchInPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));, +		searchInPanel.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.search_in")));, +		searchInPanel.add(clsChBox);, +		searchInPanel.add(mthChBox);, +		searchInPanel.add(fldChBox);, +		searchInPanel.add(codeChBox);, +, +		searchOptions.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.options")));, +		searchOptions.add(caseChBox);, +, +		Box box = Box.createHorizontalBox();, +		box.setAlignmentX(LEFT_ALIGNMENT);, +		box.add(searchInPanel);, +		box.add(searchOptions);, +		searchPane.add(box);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +	protected boolean highlightTextCaseInsensitive = false;, +				searchContext.setMatchCase(!highlightTextCaseInsensitive);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JCheckBox caseChBox;, +		boolean caseInsensitive = caseChBox.isSelected();, +			resultsModel.addAll(index.searchClsName(text, caseInsensitive));, +			resultsModel.addAll(index.searchMthName(text, caseInsensitive));, +			resultsModel.addAll(index.searchFldName(text, caseInsensitive));, +			resultsModel.addAll(index.searchCode(text, caseInsensitive));, +		highlightTextCaseInsensitive = caseInsensitive;, +		caseChBox = new JCheckBox(NLS.str("search_dialog.ignorecase"));, +		caseChBox.addItemListener(new ItemListener() {, +			public void itemStateChanged(ItemEvent e) {, +				performSearch();, +			}, +		});, +, +		JPanel searchInPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));, +		searchInPanel.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.search_in")));, +		searchInPanel.add(clsChBox);, +		searchInPanel.add(mthChBox);, +		searchInPanel.add(fldChBox);, +		searchInPanel.add(codeChBox);, +, +		searchOptions.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.options")));, +		searchOptions.add(caseChBox);, +, +		Box box = Box.createHorizontalBox();, +		box.setAlignmentX(LEFT_ALIGNMENT);, +		box.add(searchInPanel);, +		box.add(searchOptions);, +		searchPane.add(box);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +, +	/**, +	 * Adapt character case for case insensitive searches, +	 */, +	public static char caseChar(char ch, boolean toLower) {, +		return toLower ? Character.toLowerCase(ch) : ch;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +	protected boolean highlightTextCaseInsensitive = false;, +				searchContext.setMatchCase(!highlightTextCaseInsensitive);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, +	private JCheckBox caseChBox;, +		boolean caseInsensitive = caseChBox.isSelected();, +			resultsModel.addAll(index.searchClsName(text, caseInsensitive));, +			resultsModel.addAll(index.searchMthName(text, caseInsensitive));, +			resultsModel.addAll(index.searchFldName(text, caseInsensitive));, +			resultsModel.addAll(index.searchCode(text, caseInsensitive));, +		highlightTextCaseInsensitive = caseInsensitive;, +		caseChBox = new JCheckBox(NLS.str("search_dialog.ignorecase"));, +		caseChBox.addItemListener(new ItemListener() {, +			public void itemStateChanged(ItemEvent e) {, +				performSearch();, +			}, +		});, +, +		JPanel searchInPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));, +		searchInPanel.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.search_in")));, +		searchInPanel.add(clsChBox);, +		searchInPanel.add(mthChBox);, +		searchInPanel.add(fldChBox);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +			} else if (b.contains(AFlag.SYNTHETIC)) {, +				List<BlockNode> s = b.getSuccessors();, +				if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +					toRemove.add(b);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +			} else if (b.contains(AFlag.SYNTHETIC)) {, +				List<BlockNode> s = b.getSuccessors();, +				if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +					toRemove.add(b);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(IfMakerHelper.class);, +				LOG.debug("Stop processing blocks after bad 'else' in 'if': {}, method: {}", info, mth);, +				LOG.debug("Stop processing blocks after bad 'then' in 'if': {}, method: {}", info, mth);, +		for (BlockNode pred : preds) {, +			if (!ifBlocks.contains(pred) && !pred.contains(AFlag.LOOP_END)) {, +				return false;, +			}, +		}, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +			} else if (b.contains(AFlag.SYNTHETIC)) {, +				List<BlockNode> s = b.getSuccessors();, +				if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +					toRemove.add(b);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(IfMakerHelper.class);, +				LOG.debug("Stop processing blocks after bad 'else' in 'if': {}, method: {}", info, mth);, +				LOG.debug("Stop processing blocks after bad 'then' in 'if': {}, method: {}", info, mth);, +		for (BlockNode pred : preds) {, +			if (!ifBlocks.contains(pred) && !pred.contains(AFlag.LOOP_END)) {, +				return false;, +			}, +		}, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			if (block == loop.getStart() || block == loop.getEnd(), +					|| BlockUtils.isEmptySimplePath(loop.getStart(), block)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +			} else if (b.contains(AFlag.SYNTHETIC)) {, +				List<BlockNode> s = b.getSuccessors();, +				if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +					toRemove.add(b);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(IfMakerHelper.class);, +				LOG.debug("Stop processing blocks after bad 'else' in 'if': {}, method: {}", info, mth);, +				LOG.debug("Stop processing blocks after bad 'then' in 'if': {}, method: {}", info, mth);, +		for (BlockNode pred : preds) {, +			if (!ifBlocks.contains(pred) && !pred.contains(AFlag.LOOP_END)) {, +				return false;, +			}, +		}, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			if (block == loop.getStart() || block == loop.getEnd(), +					|| BlockUtils.isEmptySimplePath(loop.getStart(), block)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +, +	/**, +	 * Return true if on path from start to end no instructions and no branches., +	 */, +	public static boolean isEmptySimplePath(BlockNode start, BlockNode end) {, +		if (start == end && start.getInstructions().isEmpty()) {, +			return true;, +		}, +		if (!start.getInstructions().isEmpty() || start.getCleanSuccessors().size() != 1) {, +			return false;, +		}, +		BlockNode block = getNextBlock(start);, +		while (block != null, +				&& block != end, +				&& block.getCleanSuccessors().size() < 2, +				&& block.getPredecessors().size() == 1, +				&& block.getInstructions().isEmpty()) {, +			block = getNextBlock(block);, +		}, +		return block == end;, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +			} else if (b.contains(AFlag.SYNTHETIC)) {, +				List<BlockNode> s = b.getSuccessors();, +				if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +					toRemove.add(b);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.Iterator;, +, +			Iterator<MethodInfo> it = o.getMethods().iterator();, +			if (it.hasNext()) {, +				MethodInfo mth = it.next();, +, +				String firstMethodAlias = mth.getAlias();, +, +				while (it.hasNext()) {, +					mth = it.next();, +					if (!mth.getAlias().equals(firstMethodAlias)) {, +						mth.setAlias(firstMethodAlias);, +				}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.Iterator;, +, +			Iterator<MethodInfo> it = o.getMethods().iterator();, +			if (it.hasNext()) {, +				MethodInfo mth = it.next();, +, +				String firstMethodAlias = mth.getAlias();, +, +				while (it.hasNext()) {, +					mth = it.next();, +					if (!mth.getAlias().equals(firstMethodAlias)) {, +						mth.setAlias(firstMethodAlias);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +		ClassInfo cls = dex.getInfoStorage().getCls(type);, +		return dex.getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		if (classInfo.isRenamed(), +				&& !cls.getShortName().equals(cls.getAlias().getShortName())) {, +			code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.Iterator;, +, +			Iterator<MethodInfo> it = o.getMethods().iterator();, +			if (it.hasNext()) {, +				MethodInfo mth = it.next();, +, +				String firstMethodAlias = mth.getAlias();]
[+++ b/build.gradle, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = JavaVersion.VERSION_1_6, +        targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/build.gradle, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = JavaVersion.VERSION_1_6, +        targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +			passes.add(new DebugInfoVisitor());, +++ b/build.gradle, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = JavaVersion.VERSION_1_6, +        targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +			passes.add(new DebugInfoVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			code.add(mgen.getNameGen().useArg((RegisterArg) arg));, +		code.add(mgen.getNameGen().assignArg(arg));, +++ b/build.gradle, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = JavaVersion.VERSION_1_6, +        targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +			passes.add(new DebugInfoVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			code.add(mgen.getNameGen().useArg((RegisterArg) arg));, +		code.add(mgen.getNameGen().assignArg(arg));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	private final NameGen nameGen;, +		this.nameGen = new NameGen(classGen.isFallbackMode());, +	public NameGen getNameGen() {, +		return nameGen;, +	}, +, +		MethodParameters paramsAnnotation = mth.get(AType.ANNOTATION_MTH_PARAMETERS);, +			argsCode.add(nameGen.assignArg(arg));, +		InsnNode[] insnArr = mth.getInstructions();, +		if (insnArr == null) {, +			code.startLine(getFallbackMethodGen(mth).nameGen.useArg(mth.getThisArg())).add(" = this;");, +		addFallbackInsns(code, mth, insnArr, true);, +	public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, boolean addLabels) {, +		for (InsnNode insn : insnArr) {, +			if (insn == null) {, +				continue;, +			}, +++ b/build.gradle, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = JavaVersion.VERSION_1_6, +        targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +			passes.add(new DebugInfoVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +			code.add(mgen.getNameGen().useArg((RegisterArg) arg));, +		code.add(mgen.getNameGen().assignArg(arg));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	private final NameGen nameGen;, +		this.nameGen = new NameGen(classGen.isFallbackMode());, +	public NameGen getNameGen() {, +		return nameGen;, +	}, +, +		MethodParameters paramsAnnotation = mth.get(AType.ANNOTATION_MTH_PARAMETERS);, +			argsCode.add(nameGen.assignArg(arg));, +		InsnNode[] insnArr = mth.getInstructions();, +		if (insnArr == null) {, +			code.startLine(getFallbackMethodGen(mth).nameGen.useArg(mth.getThisArg())).add(" = this;");, +		addFallbackInsns(code, mth, insnArr, true);, +	public static void addFallbackInsns(CodeWriter code, MethodNode mth, InsnNode[] insnArr, boolean addLabels) {, +		for (InsnNode insn : insnArr) {, +			if (insn == null) {, +				continue;, +			}, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +package jadx.core.codegen;, +, +import jadx.core.Consts;, +import jadx.core.deobf.NameMapper;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.NamedArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.utils.Utils;, +, +import java.util.HashSet;, +import java.util.Set;, +, +public class NameGen {, +, +	private final Set<String> varNames = new HashSet<String>();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +		return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +		return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import jadx.core.dex.instructions.PhiInsn;, +				if (assignInsn == null || assignInsn instanceof PhiInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +		return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import jadx.core.dex.instructions.PhiInsn;, +				if (assignInsn == null || assignInsn instanceof PhiInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.dex.attributes.nodes.LoopInfo;, +		boolean badThen = isBadBranchBlock(info, thenBlock);, +		boolean badElse = isBadBranchBlock(info, elseBlock);, +	private static boolean isBadBranchBlock(IfInfo info, BlockNode block) {, +		// check if block at end of loop edge, +		if (block.contains(AFlag.LOOP_START) && block.getPredecessors().size() == 1) {, +			BlockNode pred = block.getPredecessors().get(0);, +			if (pred.contains(AFlag.LOOP_END)) {, +				List<LoopInfo> startLoops = block.getAll(AType.LOOP);, +				List<LoopInfo> endLoops = pred.getAll(AType.LOOP);, +				// search for same loop, +				for (LoopInfo startLoop : startLoops) {, +					for (LoopInfo endLoop : endLoops) {, +						if (startLoop == endLoop) {, +							return true;, +						}, +					}, +				}, +			}, +		}, +		return !allPathsFromIf(block, info);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +		return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import jadx.core.dex.instructions.PhiInsn;, +				if (assignInsn == null || assignInsn instanceof PhiInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.dex.attributes.nodes.LoopInfo;, +		boolean badThen = isBadBranchBlock(info, thenBlock);, +		boolean badElse = isBadBranchBlock(info, elseBlock);, +	private static boolean isBadBranchBlock(IfInfo info, BlockNode block) {, +		// check if block at end of loop edge, +		if (block.contains(AFlag.LOOP_START) && block.getPredecessors().size() == 1) {, +			BlockNode pred = block.getPredecessors().get(0);, +			if (pred.contains(AFlag.LOOP_END)) {, +				List<LoopInfo> startLoops = block.getAll(AType.LOOP);, +				List<LoopInfo> endLoops = pred.getAll(AType.LOOP);, +				// search for same loop, +				for (LoopInfo startLoop : startLoops) {, +					for (LoopInfo endLoop : endLoops) {, +						if (startLoop == endLoop) {, +							return true;, +						}, +					}, +				}, +			}, +		}, +		return !allPathsFromIf(block, info);, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		if (phiInsn == null, +				|| phiInsn.getArgsCount() != 2, +		// can't make loop if argument from increment instruction is assign in loop, +		for (InsnArg iArg : incrInsn.getArguments()) {, +			if (iArg.isRegister() && assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {, +				return false;, +			}, +		}, +				LOG.debug(" checkArrayForEach: Wrapped insn not found: {}, mth: {}", arrGetInsn, mth);, +				LOG.warn(" checkIterableForEach: Wrapped insn not found: {}, mth: {}", nextCall, mth);, +	private static boolean assignOnlyInLoop(MethodNode mth, LoopRegion loopRegion, RegisterArg arg) {, +		InsnNode assignInsn = arg.getAssignInsn();, +		if (assignInsn == null) {, +			return true;, +		}, +		if (!argInLoop(mth, loopRegion, assignInsn.getResult())) {, +			return false;, +		}, +		if (assignInsn instanceof PhiInsn) {, +			PhiInsn phiInsn = (PhiInsn) assignInsn;, +			for (InsnArg phiArg : phiInsn.getArguments()) {, +				if (!assignOnlyInLoop(mth, loopRegion, (RegisterArg) phiArg)) {, +					return false;, +				}, +			}, +		}, +		return true;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, +		return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import jadx.core.dex.instructions.PhiInsn;, +				if (assignInsn == null || assignInsn instanceof PhiInsn) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		List<BlockNode> basicBlocks = mth.getBasicBlocks();, +		BitSet outs = new BitSet(basicBlocks.size());, +					BlockNode first = basicBlocks.get(df.nextSetBit(0));, +					BlockNode second = basicBlocks.get(df.nextSetBit(first.getId() + 1));, +		outs.clear(block.getId());, +		if (loop != null) {, +			outs.clear(loop.getStart().getId());, +		}, +, +				BlockNode b = basicBlocks.get(i);, +			out = basicBlocks.get(outs.nextSetBit(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +		List<BlockNode> basicBlocks = mth.getBasicBlocks();, +		BitSet outs = new BitSet(basicBlocks.size());, +					BlockNode first = basicBlocks.get(df.nextSetBit(0));, +					BlockNode second = basicBlocks.get(df.nextSetBit(first.getId() + 1));, +		outs.clear(block.getId());, +		if (loop != null) {, +			outs.clear(loop.getStart().getId());, +		}, +, +				BlockNode b = basicBlocks.get(i);, +			out = basicBlocks.get(outs.nextSetBit(0));, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop.java, +package jadx.tests.integration.switches;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertThat;, +, +public class TestSwitchInLoop extends IntegrationTest {, +	public static class TestCls {, +		public int test(int k) {, +			int a = 0;, +			while (true) {, +				switch (k) {, +					case 0:, +						return a;, +					default:, +						a++;, +						k >>= 1;, +				}, +			}, +		}, +, +		public void check() {, +			assertEquals(1, test(1));, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("switch (k) {"));, +		assertThat(code, containsOne("case 0:"));, +		assertThat(code, containsOne("return a;"));, +		assertThat(code, containsOne("default:"));, +		assertThat(code, containsOne("a++;"));, +		assertThat(code, containsOne("k >>= 1;"));, +	}, +}]
[+++ b/jadx-core/build.gradle, +    compile 'commons-io:commons-io:2.6', +++ b/jadx-core/build.gradle, +    compile 'commons-io:commons-io:2.6', +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import java.io.File;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.apache.commons.io.FilenameUtils;, +, +import jadx.core.utils.files.FileUtils;, +		if (dexNodes.isEmpty()) {, +		boolean isCaseSensitive = FileUtils.isCaseSensitiveFS(new File(inputPath)); // args.getOutDir() - not set in gui, +		checkClasses(root, isCaseSensitive);, +	private void checkClasses(RootNode root, boolean caseSensitive) {, +			if (!caseSensitive) {, +++ b/jadx-core/build.gradle, +    compile 'commons-io:commons-io:2.6', +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import java.io.File;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.apache.commons.io.FilenameUtils;, +, +import jadx.core.utils.files.FileUtils;, +		if (dexNodes.isEmpty()) {, +		boolean isCaseSensitive = FileUtils.isCaseSensitiveFS(new File(inputPath)); // args.getOutDir() - not set in gui, +		checkClasses(root, isCaseSensitive);, +	private void checkClasses(RootNode root, boolean caseSensitive) {, +			if (!caseSensitive) {, +++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java, +			FileUtils.makeDirs(srcOutDir);, +			FileUtils.makeDirs(resOutDir);, +++ b/jadx-core/build.gradle, +    compile 'commons-io:commons-io:2.6', +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import java.io.File;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.apache.commons.io.FilenameUtils;, +, +import jadx.core.utils.files.FileUtils;, +		if (dexNodes.isEmpty()) {, +		boolean isCaseSensitive = FileUtils.isCaseSensitiveFS(new File(inputPath)); // args.getOutDir() - not set in gui, +		checkClasses(root, isCaseSensitive);, +	private void checkClasses(RootNode root, boolean caseSensitive) {, +			if (!caseSensitive) {, +++ b/jadx-core/src/main/java/jadx/core/export/ExportGradleProject.java, +			FileUtils.makeDirs(srcOutDir);, +			FileUtils.makeDirs(resOutDir);, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import org.apache.commons.io.IOCase;, +import org.jetbrains.annotations.Nullable;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +		if (file != null) {, +			makeDirs(file.getParentFile());, +		}, +	}, +, +	private static final Object MKDIR_SYNC = new Object();, +, +	public static void makeDirs(@Nullable File dir) {, +		if (dir != null) {, +			synchronized (MKDIR_SYNC) {, +				if (!dir.exists() && !dir.mkdirs()) {, +	}, +, +	public static boolean isCaseSensitiveFS(File testDir) {, +		if (testDir != null) {, +			File caseCheckUpper = new File(testDir, "CaseCheck");, +			File caseCheckLow = new File(testDir, "casecheck");, +			try {, +				makeDirs(testDir);, +				if (caseCheckUpper.createNewFile()) {, +					boolean caseSensitive = !caseCheckLow.exists();, +					LOG.debug("Filesystem at {} is {} case-sensitive", testDir.getAbsolutePath(),, +							(caseSensitive ? "" : "NOT"));, +					return caseSensitive;, +				} else {, +					LOG.debug("Failed to create file: {}", caseCheckUpper.getAbsolutePath());, +				}, +			} catch (Exception e) {, +				LOG.debug("Failed to detect filesystem case-sensitivity by file creation", e);, +			} finally {, +				try {, +					caseCheckUpper.delete();, +					caseCheckLow.delete();, +				} catch (Exception e) {, +					// ignore, +				}, +			}, +		}, +		return IOCase.SYSTEM.isCaseSensitive();]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import java.util.stream.Collectors;, +	/**, +	 * Get the complete list of classes, +	 * @return, +	 */, +	/**, +	 * Get all classes that are not excluded by the excluded packages settings, +	 * @return, +	 */, +	public List<JavaClass> getIncludedClasses() {, +		List<JavaClass> classList = decompiler.getClasses();, +		String excludedPackages = settings.getExcludedPackages().trim();, +		if (excludedPackages.length() == 0), +			return classList;, +		String[] excluded = excludedPackages.split("[ ]+");, +, +		return classList.stream().filter(cls -> {, +			for (String exclude : excluded) {, +				if (cls.getFullName().startsWith(exclude)), +					return false;, +			}, +			return true;, +		}).collect(Collectors.toList());, +	}, +, +, +	public JadxSettings getSettings() {, +		return settings;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import java.util.stream.Collectors;, +	/**, +	 * Get the complete list of classes, +	 * @return, +	 */, +	/**, +	 * Get all classes that are not excluded by the excluded packages settings, +	 * @return, +	 */, +	public List<JavaClass> getIncludedClasses() {, +		List<JavaClass> classList = decompiler.getClasses();, +		String excludedPackages = settings.getExcludedPackages().trim();, +		if (excludedPackages.length() == 0), +			return classList;, +		String[] excluded = excludedPackages.split("[ ]+");, +, +		return classList.stream().filter(cls -> {, +			for (String exclude : excluded) {, +				if (cls.getFullName().startsWith(exclude)), +					return false;, +			}, +			return true;, +		}).collect(Collectors.toList());, +	}, +, +, +	public JadxSettings getSettings() {, +		return settings;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +				String msg = NLS.str("message.indexingClassesSkipped");, +				msg = String.format(msg, searchIndex.getSkippedCount());, +				JOptionPane.showMessageDialog(null, msg);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import java.util.stream.Collectors;, +	/**, +	 * Get the complete list of classes, +	 * @return, +	 */, +	/**, +	 * Get all classes that are not excluded by the excluded packages settings, +	 * @return, +	 */, +	public List<JavaClass> getIncludedClasses() {, +		List<JavaClass> classList = decompiler.getClasses();, +		String excludedPackages = settings.getExcludedPackages().trim();, +		if (excludedPackages.length() == 0), +			return classList;, +		String[] excluded = excludedPackages.split("[ ]+");, +, +		return classList.stream().filter(cls -> {, +			for (String exclude : excluded) {, +				if (cls.getFullName().startsWith(exclude)), +					return false;, +			}, +			return true;, +		}).collect(Collectors.toList());, +	}, +, +, +	public JadxSettings getSettings() {, +		return settings;, +	}, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +				String msg = NLS.str("message.indexingClassesSkipped");, +				msg = String.format(msg, searchIndex.getSkippedCount());, +				JOptionPane.showMessageDialog(null, msg);]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.ui.SearchDialog.SearchOptions;, +import javax.swing.AbstractAction;, +import javax.swing.Action;, +import java.util.EnumSet;, +import static javax.swing.KeyStroke.getKeyStroke;, +, +	private void saveAll() {, +		tree.requestFocus();, +		Action openAction = new AbstractAction(NLS.str("file.open"), ICON_OPEN) {, +				openFile();, +		};, +		openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open"));, +		openAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_O, KeyEvent.CTRL_DOWN_MASK));, +, +		Action saveAllAction = new AbstractAction(NLS.str("file.save_all"), ICON_SAVE_ALL) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				saveAll();, +			}, +		};, +		saveAllAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.save_all"));, +		saveAllAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_S, KeyEvent.CTRL_DOWN_MASK));, +		Action prefsAction = new AbstractAction(NLS.str("menu.preferences"), ICON_PREF) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				new JadxSettingsWindow(MainWindow.this, settings).setVisible(true);, +		prefsAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("menu.preferences"));, +		prefsAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_P,, +				KeyEvent.CTRL_DOWN_MASK | KeyEvent.SHIFT_DOWN_MASK));, +		Action exitAction = new AbstractAction(NLS.str("file.exit"), ICON_CLOSE) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				dispose();, +			}, +		};, +		Action syncAction = new AbstractAction(NLS.str("menu.sync"), ICON_SYNC) {, +		syncAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("menu.sync"));, +		syncAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_T, KeyEvent.CTRL_DOWN_MASK));, +		Action textSearchAction = new AbstractAction(NLS.str("menu.text_search"), ICON_SEARCH) {, +				new SearchDialog(MainWindow.this, EnumSet.of(SearchOptions.CODE)).setVisible(true);, +		textSearchAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("menu.text_search"));, +		textSearchAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_F,, +				KeyEvent.CTRL_DOWN_MASK | KeyEvent.SHIFT_DOWN_MASK));, +		Action clsSearchAction = new AbstractAction(NLS.str("menu.class_search"), ICON_FIND) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				new SearchDialog(MainWindow.this, EnumSet.of(SearchOptions.CLASS)).setVisible(true);, +			}, +		};, +		clsSearchAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("menu.class_search"));, +		clsSearchAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_N, KeyEvent.CTRL_DOWN_MASK));, +		Action logAction = new AbstractAction(NLS.str("menu.log"), ICON_LOG) {, +		logAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("menu.log"));, +		logAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_L,, +				KeyEvent.CTRL_DOWN_MASK | KeyEvent.SHIFT_DOWN_MASK));, +, +		Action aboutAction = new AbstractAction(NLS.str("menu.about")) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				new AboutDialog().setVisible(true);, +			}, +		};, +, +		Action backAction = new AbstractAction(NLS.str("nav.back"), ICON_BACK) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				tabbedPane.navBack();, +			}, +		};, +		backAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("nav.back"));, +		backAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_LEFT,, +				KeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK));, +, +		Action forwardAction = new AbstractAction(NLS.str("nav.forward"), ICON_FORWARD) {, +			@Override, +			public void actionPerformed(ActionEvent e) {, +				tabbedPane.navForward();, +			}, +		};, +		forwardAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("nav.forward"));, +		forwardAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_RIGHT,, +				KeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK));, +, +		JMenu file = new JMenu(NLS.str("menu.file"));, +		file.setMnemonic(KeyEvent.VK_F);, +		file.add(openAction);, +		file.add(saveAllAction);, +		file.addSeparator();, +		file.add(recentFiles);, +		file.addSeparator();, +		file.add(prefsAction);, +		file.addSeparator();, +		file.add(exitAction);, +, +		JMenu view = new JMenu(NLS.str("menu.view"));, +		view.setMnemonic(KeyEvent.VK_V);, +		view.add(flatPkgMenuItem);, +		view.add(syncAction);, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, +		CodegenUtils.addComments(code, cls);, +		insertDecompilationProblems(code, cls);, +			CodegenUtils.addComments(code, mth);, +	private void insertDecompilationProblems(CodeWriter code, AttrNode node) {, +		List<JadxError> errors = node.getAll(AType.JADX_ERROR);, +		List<JadxWarn> warns = node.getAll(AType.JADX_WARN);, +			CodegenUtils.addComments(code, f);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, +		CodegenUtils.addComments(code, cls);, +		insertDecompilationProblems(code, cls);, +			CodegenUtils.addComments(code, mth);, +	private void insertDecompilationProblems(CodeWriter code, AttrNode node) {, +		List<JadxError> errors = node.getAll(AType.JADX_ERROR);, +		List<JadxWarn> warns = node.getAll(AType.JADX_WARN);, +			CodegenUtils.addComments(code, f);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	public static final AType<AttrList<String>> COMMENTS = new AType<>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, +		CodegenUtils.addComments(code, cls);, +		insertDecompilationProblems(code, cls);, +			CodegenUtils.addComments(code, mth);, +	private void insertDecompilationProblems(CodeWriter code, AttrNode node) {, +		List<JadxError> errors = node.getAll(AType.JADX_ERROR);, +		List<JadxWarn> warns = node.getAll(AType.JADX_WARN);, +			CodegenUtils.addComments(code, f);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	public static final AType<AttrList<String>> COMMENTS = new AType<>();, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java, +import jadx.core.utils.ErrorsCounter;, +		DexNode dex = cls.dex();, +		if (value instanceof Integer) {, +			FieldNode rField = getResourceField((Integer) value, dex);, +			if (rField != null) {, +				return rField;, +			}, +		}, +	private FieldNode getResourceField(Integer value, DexNode dex) {, +		String str = resourcesNames.get(value);, +		if (str == null) {, +			return null;, +		}, +		ClassNode appResClass = dex.root().getAppResClass();, +		if (appResClass == null) {, +			return null;, +		}, +		String[] parts = str.split("/", 2);, +		if (parts.length != 2) {, +			return null;, +		}, +		String typeName = parts[0];, +		String fieldName = parts[1];, +		for (ClassNode innerClass : appResClass.getInnerClasses()) {, +			if (innerClass.getShortName().equals(typeName)) {, +				return innerClass.searchFieldByName(fieldName);, +			}, +		}, +		ErrorsCounter.classWarn(appResClass, "Not found resource field with id: " + value + ", name: " + str.replace('/', '.'));, +		return null;, +	}, +, +	@Nullable, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, +		CodegenUtils.addComments(code, cls);, +		insertDecompilationProblems(code, cls);, +			CodegenUtils.addComments(code, mth);, +	private void insertDecompilationProblems(CodeWriter code, AttrNode node) {, +		List<JadxError> errors = node.getAll(AType.JADX_ERROR);, +		List<JadxWarn> warns = node.getAll(AType.JADX_WARN);, +			CodegenUtils.addComments(code, f);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +	public static final AType<AttrList<String>> COMMENTS = new AType<>();, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ConstStorage.java, +import jadx.core.utils.ErrorsCounter;, +		DexNode dex = cls.dex();, +		if (value instanceof Integer) {, +			FieldNode rField = getResourceField((Integer) value, dex);, +			if (rField != null) {, +				return rField;, +			}, +		}, +	private FieldNode getResourceField(Integer value, DexNode dex) {, +		String str = resourcesNames.get(value);, +		if (str == null) {, +			return null;, +		}, +		ClassNode appResClass = dex.root().getAppResClass();, +		if (appResClass == null) {, +			return null;, +		}, +		String[] parts = str.split("/", 2);, +		if (parts.length != 2) {, +			return null;, +		}, +		String typeName = parts[0];, +		String fieldName = parts[1];]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.dex().deepResolveMethod(callMth);, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.dex().deepResolveMethod(callMth);, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		shortId = makeSignature(true);, +	public String makeSignature(boolean includeRetType) {, +		StringBuilder signature = new StringBuilder();, +		signature.append(name);, +		signature.append('(');, +		for (ArgType arg : args) {, +			signature.append(TypeGen.signature(arg));, +		}, +		signature.append(')');, +		if (includeRetType) {, +			signature.append(TypeGen.signature(retType));, +		}, +		return signature.toString();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		MethodNode callMthNode = mth.dex().deepResolveMethod(callMth);, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +		shortId = makeSignature(true);, +	public String makeSignature(boolean includeRetType) {, +		StringBuilder signature = new StringBuilder();, +		signature.append(name);, +		signature.append('(');, +		for (ArgType arg : args) {, +			signature.append(TypeGen.signature(arg));, +		}, +		signature.append(')');, +		if (includeRetType) {, +			signature.append(TypeGen.signature(retType));, +		}, +		return signature.toString();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import org.jetbrains.annotations.NotNull;, +	public ClassNode resolveClass(@NotNull ArgType type) {, +		if (type.isGeneric()) {, +			type = ArgType.object(type.getObject());, +		}, +		return resolveClass(ClassInfo.fromType(this, type));, +	}, +, +	@Nullable, +	public MethodNode resolveMethod(@NotNull MethodInfo mth) {, +	/**, +	 * Search method in class hierarchy., +	 */, +	@Nullable, +	public MethodNode deepResolveMethod(@NotNull MethodInfo mth) {, +		ClassNode cls = resolveClass(mth.getDeclClass());, +		if (cls == null) {, +			return null;, +		}, +		return deepResolveMethod(cls, mth.makeSignature(false));, +	}, +, +	@Nullable, +	private MethodNode deepResolveMethod(@NotNull ClassNode cls, String signature) {, +		for (MethodNode m : cls.getMethods()) {, +			if (m.getMethodInfo().getShortId().startsWith(signature)) {, +				return m;, +			}, +		}, +		MethodNode found;, +		ArgType superClass = cls.getSuperClass();, +		if (superClass != null) {, +			ClassNode superNode = resolveClass(superClass);, +			if (superNode != null) {, +				found = deepResolveMethod(superNode, signature);, +				if (found != null) {, +					return found;, +				}, +			}, +		}, +		for (ArgType iFaceType : cls.getInterfaces()) {, +			ClassNode iFaceNode = resolveClass(iFaceType);, +			if (iFaceNode != null) {, +				found = deepResolveMethod(iFaceNode, signature);, +				if (found != null) {, +					return found;, +				}, +			}, +		}]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		JadxDecompiler d = loadFiles(Collections.singletonList(file));, +		RootNode root = JadxInternalAccess.getRoot(d);, +, +		ClassNode cls = root.searchClassByName(clsName);, +		assertThat("Class not found: " + clsName, cls, notNullValue());, +		assertThat(clsName, is(cls.getClassInfo().getFullName()));, +, +		decompileAndCheckCls(d, cls);, +		return cls;, +	}, +, +	protected JadxDecompiler loadFiles(List<File> inputFiles) {, +			args.setInputFiles(inputFiles);, +		return d;, +	}, +	protected void decompileAndCheckCls(JadxDecompiler d, ClassNode cls) {, +		runAutoCheck(cls.getClassInfo().getFullName());, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		JadxDecompiler d = loadFiles(Collections.singletonList(file));, +		RootNode root = JadxInternalAccess.getRoot(d);, +, +		ClassNode cls = root.searchClassByName(clsName);, +		assertThat("Class not found: " + clsName, cls, notNullValue());, +		assertThat(clsName, is(cls.getClassInfo().getFullName()));, +, +		decompileAndCheckCls(d, cls);, +		return cls;, +	}, +, +	protected JadxDecompiler loadFiles(List<File> inputFiles) {, +			args.setInputFiles(inputFiles);, +		return d;, +	}, +	protected void decompileAndCheckCls(JadxDecompiler d, ClassNode cls) {, +		runAutoCheck(cls.getClassInfo().getFullName());, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +import org.jetbrains.annotations.Nullable;, +import jadx.api.JadxDecompiler;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.junit.Assert.assertThat;, +, +	protected ClassNode getClassNodeFromSmali(String clsName) {, +		return getClassNodeFromSmali(clsName, clsName);, +	}, +, +	protected ClassNode getClassNodeFromSmaliFiles(String pkg, String testName, String clsName) {, +		compileSmali(outDex, collectSmaliFiles(pkg, testName));, +	protected JadxDecompiler loadSmaliFile(String pkg, String smaliFileName) {, +		File outDex = createTempFile(".dex");, +		compileSmali(outDex, Collections.singletonList(getSmaliFile(pkg + File.separatorChar + smaliFileName)));, +		return loadFiles(Collections.singletonList(outDex));, +	}, +, +	protected JadxDecompiler loadSmaliFiles(String pkg, String testNameDir) {, +		File outDex = createTempFile(".dex");, +		compileSmali(outDex, collectSmaliFiles(pkg, testNameDir));, +		return loadFiles(Collections.singletonList(outDex));, +	}, +, +	private List<File> collectSmaliFiles(String pkg, @Nullable String testDir) {, +		String smaliFilesDir;, +		if (testDir == null) {, +			smaliFilesDir = pkg + File.separatorChar;, +		} else {, +			smaliFilesDir = pkg + File.separatorChar + testDir + File.separatorChar;, +		}, +		File smaliDir = new File(SMALI_TESTS_DIR, smaliFilesDir);, +		String[] smaliFileNames = smaliDir.list((dir, name) -> name.endsWith(".smali"));, +		assertThat("Smali files not found", smaliFileNames, notNullValue());, +		return Arrays.stream(smaliFileNames), +				.map(file -> new File(smaliDir, file)), +				.collect(Collectors.toList());, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +		JadxDecompiler d = loadFiles(Collections.singletonList(file));, +		RootNode root = JadxInternalAccess.getRoot(d);, +, +		ClassNode cls = root.searchClassByName(clsName);, +		assertThat("Class not found: " + clsName, cls, notNullValue());, +		assertThat(clsName, is(cls.getClassInfo().getFullName()));, +, +		decompileAndCheckCls(d, cls);, +		return cls;, +	}, +, +	protected JadxDecompiler loadFiles(List<File> inputFiles) {, +			args.setInputFiles(inputFiles);, +		return d;, +	}, +	protected void decompileAndCheckCls(JadxDecompiler d, ClassNode cls) {, +		runAutoCheck(cls.getClassInfo().getFullName());, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +import org.jetbrains.annotations.Nullable;, +import jadx.api.JadxDecompiler;, +import static org.hamcrest.Matchers.notNullValue;, +import static org.junit.Assert.assertThat;, +, +	protected ClassNode getClassNodeFromSmali(String clsName) {, +		return getClassNodeFromSmali(clsName, clsName);, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, +		List<AnnotationsList> paramList = paramsAnnotations.getParamList();, +		if (n >= paramList.size()) {, +			return;, +		}, +		AnnotationsList aList = paramList.get(n);]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +		ClassInfo classInfo = cls.getClassInfo();, +		String alias = getAliasFromSourceFile(cls);, +		if (alias == null) {, +			String clsName = classInfo.getShortName();, +			alias = String.format("C%04d%s", clsIndex++, makeName(clsName));, +		}, +		PackageNode pkg = getPackageNode(classInfo.getPackage(), true);, +		clsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));, +		return alias;, +	}, +, +	@Nullable, +	private String getAliasFromSourceFile(ClassNode cls) {, +		if (sourceFileAttr == null) {, +			return null;, +		}, +		return null;]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new BlockProcessor());, +			passes.add(new BlockExceptionHandler());, +			passes.add(new BlockFinallyExtract());, +			passes.add(new BlockFinish());, +, +			passes.add(new SSATransform());, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			passes.add(new FinishTypeInference());, +			passes.add(new EliminatePhiNodes());, +, +, +			passes.add(new LoopRegionVisitor());, +			passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, +		}, +		if (srcDir == null) {, +			args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, +		}, +		if (resDir == null) {, +			args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, +		}, +		checkDir(args.getOutDir(), "Output");, +		checkDir(args.getOutDirSrc(), "Source output");, +		checkDir(args.getOutDirRes(), "Resources output");, +	private static void checkDir(File dir, String desc) {, +			throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;]
[+++ b/jadx-gui/build.gradle, +    icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/build.gradle, +    icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, +		setWindowIcons();, +	}, +, +	private void setWindowIcons() {, +		List<Image> icons = new ArrayList<>();, +		icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo.png"));, +		setIconImages(icons);, +++ b/jadx-gui/build.gradle, +    icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, +		setWindowIcons();, +	}, +, +	private void setWindowIcons() {, +		List<Image> icons = new ArrayList<>();, +		icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo.png"));, +		setIconImages(icons);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +	public static Image openImage(String path) {, +		URL resource = Utils.class.getResource(path);, +		if (resource == null) {, +			throw new JadxRuntimeException("Image not found: " + path);, +		}, +		return Toolkit.getDefaultToolkit().createImage(resource);, +	}, +, +++ b/jadx-gui/build.gradle, +    icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, +		setWindowIcons();, +	}, +, +	private void setWindowIcons() {, +		List<Image> icons = new ArrayList<>();, +		icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo.png"));, +		setIconImages(icons);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +	public static Image openImage(String path) {, +		URL resource = Utils.class.getResource(path);, +		if (resource == null) {, +			throw new JadxRuntimeException("Image not found: " + path);, +		}, +		return Toolkit.getDefaultToolkit().createImage(resource);, +	}, +, +++ b/jadx-gui/src/main/resources/logos/jadx-logo-16px.png, +++ b/jadx-gui/build.gradle, +    icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, +		setWindowIcons();, +	}, +, +	private void setWindowIcons() {, +		List<Image> icons = new ArrayList<>();, +		icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, +		icons.add(Utils.openImage("/logos/jadx-logo.png"));, +		setIconImages(icons);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +	public static Image openImage(String path) {, +		URL resource = Utils.class.getResource(path);, +		if (resource == null) {, +			throw new JadxRuntimeException("Image not found: " + path);, +		}, +		return Toolkit.getDefaultToolkit().createImage(resource);, +	}, +, +++ b/jadx-gui/src/main/resources/logos/jadx-logo-16px.png, +++ b/jadx-gui/src/main/resources/logos/jadx-logo-32px.png, +++ b/jadx-gui/build.gradle, +    icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, +		setWindowIcons();, +	}, +]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:5.0.3', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:5.0.3', +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +package jadx.core.utils;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +, +import org.objectweb.asm.ClassReader;, +, +public class AsmUtils {, +, +	private AsmUtils() {, +	}, +, +	public static String getNameFromClassFile(File file) throws IOException {, +		FileInputStream in = new FileInputStream(file);, +		ClassReader classReader = new ClassReader(in);, +		return classReader.getClassName();, +	}, +, +}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:5.0.3', +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +package jadx.core.utils;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +, +import org.objectweb.asm.ClassReader;, +, +public class AsmUtils {, +, +	private AsmUtils() {, +	}, +, +	public static String getNameFromClassFile(File file) throws IOException {, +		FileInputStream in = new FileInputStream(file);, +		ClassReader classReader = new ClassReader(in);, +		return classReader.getClassName();, +	}, +, +}, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +package jadx.core.utils.files;, +, +import java.io.BufferedInputStream;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +import java.util.jar.JarEntry;, +import java.util.jar.JarOutputStream;, +, +public class FileUtils {, +, +	private FileUtils() {, +	}, +, +	public static void addFileToJar(JarOutputStream jar, File source, String entryName) throws IOException {, +		BufferedInputStream in = null;, +		try {, +			JarEntry entry = new JarEntry(entryName);, +			entry.setTime(source.lastModified());, +			jar.putNextEntry(entry);, +			in = new BufferedInputStream(new FileInputStream(source));, +, +			byte[] buffer = new byte[8192];, +			while (true) {, +				int count = in.read(buffer);, +				if (count == -1) {, +					break;, +				}, +				jar.write(buffer, 0, count);, +			}, +			jar.closeEntry();, +		} finally {, +			if (in != null) {, +				in.close();, +			}, +		}, +	}, +}, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +	@Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-core/build.gradle, +    compile 'org.ow2.asm:asm:5.0.3', +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +	private int namespaceDepth = 0;, +					if (namespaceDepth == 0) {, +						// skip padding on file end, +						return;, +					}, +		namespaceDepth++;, +		namespaceDepth--;, +		int elementNameId = is.readInt32();, +		String elemName = getString(elementNameId);, +		if (currentTag.equals(elemName) && isOneLine && !isLastEnd) {, +			writer.add(elemName).add(">");]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +	private static boolean allArgsNull(ConstructorInsn insn) {, +			} else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +	private static boolean allArgsNull(ConstructorInsn insn) {, +			} else {, +++ b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java, +import static org.hamcrest.Matchers.greaterThan;, +			processByPatterns(jadx, clsPtrn, mthPtrn);, +	private void processByPatterns(JadxDecompiler jadx, Pattern clsPattern, @Nullable Pattern mthPattern) {, +		int processed = 0;, +				if (processCls(mthPattern, passes, classNode)) {, +					processed++;, +				}, +			}, +		}, +		assertThat("No classes processed", processed, greaterThan(0));, +	}, +, +	private boolean processCls(@Nullable Pattern mthPattern, List<IDexTreeVisitor> passes, ClassNode classNode) {, +		if (!decompile) {, +			return false;, +		}, +		return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +	private static boolean allArgsNull(ConstructorInsn insn) {, +			} else {, +++ b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java, +import static org.hamcrest.Matchers.greaterThan;, +			processByPatterns(jadx, clsPtrn, mthPtrn);, +	private void processByPatterns(JadxDecompiler jadx, Pattern clsPattern, @Nullable Pattern mthPattern) {, +		int processed = 0;, +				if (processCls(mthPattern, passes, classNode)) {, +					processed++;, +				}, +			}, +		}, +		assertThat("No classes processed", processed, greaterThan(0));, +	}, +, +	private boolean processCls(@Nullable Pattern mthPattern, List<IDexTreeVisitor> passes, ClassNode classNode) {, +		if (!decompile) {, +			return false;, +		}, +		return true;, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestOuterConstructorCall.java, +package jadx.tests.integration.inner;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestOuterConstructorCall extends IntegrationTest {, +, +	public static class TestCls {, +		private TestCls(Inner inner) {, +			System.out.println(inner);, +		}, +, +		private class Inner {, +			private TestCls test() {, +				return new TestCls(this);, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsString("private class Inner {"));, +		assertThat(code, containsString("return new TestOuterConstructorCall$TestCls(this);"));, +		assertThat(code, not(containsString("synthetic")));, +	}, +}]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import javax.swing.WindowConstants;, +					mainWindow.pack();, +					mainWindow.setLocationAndPosition();, +					mainWindow.setLocationRelativeTo(null);, +					mainWindow.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import javax.swing.WindowConstants;, +					mainWindow.pack();, +					mainWindow.setLocationAndPosition();, +					mainWindow.setLocationRelativeTo(null);, +					mainWindow.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import java.awt.Dimension;, +import java.awt.Toolkit;, +	private static final double BORDER_RATIO = 0.15;, +	private static final double WINDOW_RATIO = 1 - BORDER_RATIO * 2;, +, +		splitPane.setResizeWeight(0.2);, +	}, +, +	public void setLocationAndPosition() {, +		Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();, +		double w = dimension.getWidth();, +		double h = dimension.getHeight();, +		setLocation((int) (w * BORDER_RATIO), (int) (h * BORDER_RATIO));, +		setSize((int) (w * WINDOW_RATIO), (int) (h * WINDOW_RATIO));]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, +			ExecutorService ex = saveAll(args.getOutDir());, +			ex.awaitTermination(100, TimeUnit.DAYS);, +			LOG.info("done");, +	public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, +		SaveCode savePass = new SaveCode(dir, args);, +		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, +		return executor;, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, +			ExecutorService ex = saveAll(args.getOutDir());, +			ex.awaitTermination(100, TimeUnit.DAYS);, +			LOG.info("done");, +	public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, +		SaveCode savePass = new SaveCode(dir, args);, +		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, +		return executor;, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, +			ExecutorService ex = saveAll(args.getOutDir());, +			ex.awaitTermination(100, TimeUnit.DAYS);, +			LOG.info("done");, +	public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, +		SaveCode savePass = new SaveCode(dir, args);, +		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, +		return executor;, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +	public SaveCode(File dir, IJadxArgs args) {, +		this.dir = dir;, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, +			ExecutorService ex = saveAll(args.getOutDir());, +			ex.awaitTermination(100, TimeUnit.DAYS);, +			LOG.info("done");, +	public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, +		SaveCode savePass = new SaveCode(dir, args);, +		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, +		return executor;, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +	public SaveCode(File dir, IJadxArgs args) {, +		this.dir = dir;, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import javax.swing.ProgressMonitor;, +import java.util.concurrent.ThreadPoolExecutor;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxWrapper.class);, +, +	public void saveAll(final File dir, final ProgressMonitor progressMonitor) {, +		Runnable save = new Runnable() {, +			@Override, +			public void run() {, +				try {, +					ThreadPoolExecutor ex = decompiler.saveAll(dir);, +					while (ex.isTerminating()) {, +						long total = ex.getTaskCount();, +						long done = ex.getCompletedTaskCount();, +						progressMonitor.setProgress((int) (done * 100.0 / (double) total));, +						Thread.sleep(500);, +					}, +					progressMonitor.close();, +					LOG.info("done");, +				} catch (InterruptedException e) {, +					e.printStackTrace();, +				}, +			}, +		};, +		new Thread(save).start();, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, +			ExecutorService ex = saveAll(args.getOutDir());, +			ex.awaitTermination(100, TimeUnit.DAYS);, +			LOG.info("done");, +	public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, +		SaveCode savePass = new SaveCode(dir, args);, +		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, +		return executor;, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +	public SaveCode(File dir, IJadxArgs args) {, +		this.dir = dir;, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import javax.swing.ProgressMonitor;, +import java.util.concurrent.ThreadPoolExecutor;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(JadxWrapper.class);, +, +	public void saveAll(final File dir, final ProgressMonitor progressMonitor) {, +		Runnable save = new Runnable() {, +			@Override, +			public void run() {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +import java.util.ArrayList;, +import java.util.List;, +					// printRegionsWithBlock(mth, block);, +, +	private static void printRegionsWithBlock(MethodNode mth, final BlockNode block) {, +		final List<IRegion> regions = new ArrayList<IRegion>();, +		DepthRegionTraversal.traverseAll(mth, new TracedRegionVisitor() {, +			@Override, +			public void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion) {, +				if (block.equals(container)) {, +					regions.add(currentRegion);, +				}, +			}, +		});, +		LOG.debug(" Found block: {} in regions: {}", block, regions);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +import java.util.ArrayList;, +import java.util.List;, +					// printRegionsWithBlock(mth, block);, +, +	private static void printRegionsWithBlock(MethodNode mth, final BlockNode block) {, +		final List<IRegion> regions = new ArrayList<IRegion>();, +		DepthRegionTraversal.traverseAll(mth, new TracedRegionVisitor() {, +			@Override, +			public void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion) {, +				if (block.equals(container)) {, +					regions.add(currentRegion);, +				}, +			}, +		});, +		LOG.debug(" Found block: {} in regions: {}", block, regions);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +, +	public static void process(MethodNode mth) {, +		final Map<BlockNode, TryCatchBlock> tryBlocksMap = new HashMap<BlockNode, TryCatchBlock>(2);, +		searchTryCatchDominators(mth, tryBlocksMap);, +, +		int k = 0;, +		while (!tryBlocksMap.isEmpty()) {, +			DepthRegionTraversal.traverseAll(mth, new AbstractRegionVisitor() {, +				@Override, +				public void leaveRegion(MethodNode mth, IRegion region) {, +					checkAndWrap(tryBlocksMap, region);, +				}, +			});, +			if (k++ > 100) {, +				throw new JadxRuntimeException("Try/catch wrap count limit reached in " + mth);, +			}, +		}, +	}, +, +	private static void searchTryCatchDominators(MethodNode mth, Map<BlockNode, TryCatchBlock> tryBlocksMap) {, +		final Set<TryCatchBlock> tryBlocks = new HashSet<TryCatchBlock>();, +	private static void checkAndWrap(Map<BlockNode, TryCatchBlock> tryBlocksMap, IRegion region) {, +		for (Map.Entry<BlockNode, TryCatchBlock> entry : tryBlocksMap.entrySet()) {, +			BlockNode dominator = entry.getKey();, +				TryCatchBlock tb = tryBlocksMap.get(dominator);, +				wrapBlocks(region, tb, dominator);, +	private static void wrapBlocks(IRegion region, TryCatchBlock tb, BlockNode dominator) {, +			return;, +	private static boolean isHandlerPath(TryCatchBlock tb, IContainer cont) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +import java.util.ArrayList;, +import java.util.List;, +					// printRegionsWithBlock(mth, block);, +, +	private static void printRegionsWithBlock(MethodNode mth, final BlockNode block) {, +		final List<IRegion> regions = new ArrayList<IRegion>();, +		DepthRegionTraversal.traverseAll(mth, new TracedRegionVisitor() {, +			@Override, +			public void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion) {, +				if (block.equals(container)) {, +					regions.add(currentRegion);, +				}, +			}, +		});, +		LOG.debug(" Found block: {} in regions: {}", block, regions);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +, +	public static void process(MethodNode mth) {, +		final Map<BlockNode, TryCatchBlock> tryBlocksMap = new HashMap<BlockNode, TryCatchBlock>(2);, +		searchTryCatchDominators(mth, tryBlocksMap);, +, +		int k = 0;, +		while (!tryBlocksMap.isEmpty()) {, +			DepthRegionTraversal.traverseAll(mth, new AbstractRegionVisitor() {, +				@Override, +				public void leaveRegion(MethodNode mth, IRegion region) {, +					checkAndWrap(tryBlocksMap, region);, +				}, +			});, +			if (k++ > 100) {, +				throw new JadxRuntimeException("Try/catch wrap count limit reached in " + mth);, +			}, +		}, +	}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	public static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	public static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +	public static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java, +package jadx.core.utils;, +, +import jadx.core.codegen.CodeWriter;, +import jadx.core.codegen.InsnGen;, +import jadx.core.codegen.MethodGen;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.PhiListAttr;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.PhiInsn;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.IBlock;, +import jadx.core.dex.nodes.IContainer;, +import jadx.core.dex.nodes.IRegion;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.visitors.DotGraphVisitor;, +import jadx.core.dex.visitors.regions.DepthRegionTraversal;, +import jadx.core.dex.visitors.regions.TracedRegionVisitor;, +import jadx.core.utils.exceptions.CodegenException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +import java.io.File;, +import java.util.ArrayList;, +import java.util.LinkedHashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +@Deprecated, +public class DebugUtils {, +	private static final Logger LOG = LoggerFactory.getLogger(DebugUtils.class);, +, +	public static void dump(MethodNode mth) {, +		File out = new File("test-graph-tmp");, +		DotGraphVisitor.dump(out).visit(mth);, +		DotGraphVisitor.dumpRaw(out).visit(mth);, +		DotGraphVisitor.dumpRegions(out).visit(mth);, +	}, +, +	public static void printRegionsWithBlock(MethodNode mth, final BlockNode block) {, +		final Set<IRegion> regions = new LinkedHashSet<IRegion>();, +		DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +			@Override, +			public void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion) {, +				if (block.equals(container)) {, +					regions.add(currentRegion);, +				}, +			}, +		});, +		LOG.debug(" Found block: {} in regions: {}", block, regions);, +	}, +, +	public static void printRegions(MethodNode mth) {, +		printRegions(mth, false);, +	}, +, +	public static void printRegions(MethodNode mth, boolean printInsns) {, +		LOG.debug("|{}", mth.toString());, +		printRegion(mth, mth.getRegion(), "|  ", printInsns);, +	}, +, +	private static void printRegion(MethodNode mth, IRegion region, String indent, boolean printInsns) {, +		LOG.debug("{}{}", indent, region);, +		indent += "|  ";, +		for (IContainer container : region.getSubBlocks()) {, +			if (container instanceof IRegion) {, +				printRegion(mth, (IRegion) container, indent, printInsns);, +			} else {, +				LOG.debug("{}{}", indent, container);, +				if (printInsns && container instanceof IBlock) {, +					IBlock block = (IBlock) container;, +					printInsns(mth, indent, block);, +				}, +			}, +		}, +	}, +, +	private static void printInsns(MethodNode mth, String indent, IBlock block) {, +		for (InsnNode insn : block.getInstructions()) {, +			try {, +				MethodGen mg = MethodGen.getFallbackMethodGen(mth);, +				InsnGen ig = new InsnGen(mg, true);, +				CodeWriter code = new CodeWriter();, +				ig.makeInsn(insn, code);, +				String insnStr = code.toString().substring(CodeWriter.NL.length());, +				LOG.debug("{} - {}", indent, insnStr);]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +				writer.add("@style/").add(name.replaceAll("_", "."));]
[+++ /dev/null, +++ /dev/null, +++ b/.travis.yml, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, +    compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.close;, +		if (fileName.endsWith(".apk") || fileName.endsWith(".zip")) {]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, +			if (ri.getTypeName().equals("attr") && !ri.getNamedValues().isEmpty()) {, +			if (valueStr == null || valueStr.equals("0")) {, +		if (valueStr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, +			if (ri.getTypeName().equals("attr") && !ri.getNamedValues().isEmpty()) {, +			if (valueStr == null || valueStr.equals("0")) {, +		if (valueStr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +import org.jetbrains.annotations.Nullable;, +import jadx.core.xmlgen.ParserConstants;, +import jadx.core.xmlgen.ResTableParser;, +, +	@Nullable, +	@Nullable, +	@Nullable, +					if (data == 0) {, +						return "0";, +					}]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +	private static final Logger LOG = LoggerFactory.getLogger(TypeGen.class);, +					LOG.warn("Wrong object literal: " + lit + " for type: " + type);, +					return Long.toString(lit);]
[+++ b/build.gradle, +version = jadxVersion, +    apply plugin: 'jacoco', +            if (!"${it}".contains(':jadx-samples:')) {, +                options.compilerArgs << '-Xlint' << '-Xlint:unchecked' << '-Xlint:deprecation', +        testCompile 'org.mockito:mockito-core:1.9.5', +    gradleVersion = '1.11', +++ b/build.gradle, +version = jadxVersion, +    apply plugin: 'jacoco', +            if (!"${it}".contains(':jadx-samples:')) {, +                options.compilerArgs << '-Xlint' << '-Xlint:unchecked' << '-Xlint:deprecation', +        testCompile 'org.mockito:mockito-core:1.9.5', +    gradleVersion = '1.11', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +version = jadxVersion, +    apply plugin: 'jacoco', +            if (!"${it}".contains(':jadx-samples:')) {, +                options.compilerArgs << '-Xlint' << '-Xlint:unchecked' << '-Xlint:deprecation', +        testCompile 'org.mockito:mockito-core:1.9.5', +    gradleVersion = '1.11', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.11-all.zip]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +	private static final int MAX_SIZE_DIFF = 100;]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);, +				} else if (data instanceof short[]) {, +					arrStr = Arrays.toString((short[]) data);, +				} else if (data instanceof byte[]) {, +					arrStr = Arrays.toString((byte[]) data);, +				} else if (data instanceof long[]) {, +					arrStr = Arrays.toString((long[]) data);, +				} else {, +					arrStr = "?";, +				}, +		if (callMthNode != null) {, +			if (inlineMethod(callMthNode, insn, code)) {, +			callMth = callMthNode.getMethodInfo();, +		}, +		code.add(callMth.getAlias());, +		ArgType origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, +			passes.add(new DebugInfoVisitor());, +			passes.add(new TypeInference());, +, +			if (args.isRawCFGOutput()) {, +				passes.add(DotGraphVisitor.dumpRaw());, +			}, +, +			passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +	private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import java.util.Arrays;, +				Object data = arrayNode.getData();, +				String arrStr;, +				if (data instanceof int[]) {, +					arrStr = Arrays.toString((int[]) data);]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public void parseAndSaveXML() {, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(outDir, "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +	}, +, +		parseAndSaveXML();, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +	public void parseAndSaveXML() {, +		if (this.args.isXMLTest()) {, +			InputFile inf = inputFiles.get(0);, +			try {, +				byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, +				if (buffer != null) {, +					File out = new File(outDir, "AndroidManifest.xml");, +					BinaryXMLParser bxp = new BinaryXMLParser(root);, +					bxp.parse(buffer, out);, +				}, +			} catch (Exception e) {, +				LOG.info("Decompiling AndroidManifest.xml failed!", e);, +			}, +		}, +	}, +, +		parseAndSaveXML();, +, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +					decompiler.parseAndSaveXML();]
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java, +		StringBuilder buf = new StringBuilder(bytes.length * 3);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +						if (accFlags.isPublic()) {, +						}, +	public FieldNode getConstField(Object obj) {, +		return getConstField(obj, true);, +	}, +, +	public FieldNode getConstField(Object obj, boolean searchGlobal) {, +			field = cn.constFields.get(obj);, +		if (field == null && searchGlobal) {, +			field = dex.getConstFields().get(obj);, +		}, +		PrimitiveType type = arg.getType().getPrimitiveType();, +		if (type == null) {, +			return null;, +		}, +		switch (type) {, +			case BOOLEAN:, +				return getConstField(literal == 1, false);, +			case CHAR:, +				return getConstField((char) literal, Math.abs(literal) > 1);, +			case BYTE:, +				return getConstField((byte) literal, Math.abs(literal) > 1);, +			case SHORT:, +				return getConstField((short) literal, Math.abs(literal) > 1);, +			case INT:, +				return getConstField((int) literal, Math.abs(literal) > 1);, +			case LONG:, +				return getConstField(literal, Math.abs(literal) > 1);, +			case FLOAT:, +				return getConstField(Float.intBitsToFloat((int) literal), true);, +			case DOUBLE:, +				return getConstField(Double.longBitsToDouble(literal), true);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +						if (accFlags.isPublic()) {, +						}, +	public FieldNode getConstField(Object obj) {, +		return getConstField(obj, true);, +	}, +, +	public FieldNode getConstField(Object obj, boolean searchGlobal) {, +			field = cn.constFields.get(obj);, +		if (field == null && searchGlobal) {, +			field = dex.getConstFields().get(obj);, +		}, +		PrimitiveType type = arg.getType().getPrimitiveType();, +		if (type == null) {, +			return null;, +		}, +		switch (type) {, +			case BOOLEAN:, +				return getConstField(literal == 1, false);, +			case CHAR:, +				return getConstField((char) literal, Math.abs(literal) > 1);, +			case BYTE:, +				return getConstField((byte) literal, Math.abs(literal) > 1);, +			case SHORT:, +				return getConstField((short) literal, Math.abs(literal) > 1);, +			case INT:, +				return getConstField((int) literal, Math.abs(literal) > 1);, +			case LONG:, +				return getConstField(literal, Math.abs(literal) > 1);, +			case FLOAT:, +				return getConstField(Float.intBitsToFloat((int) literal), true);, +			case DOUBLE:, +				return getConstField(Double.longBitsToDouble(literal), true);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +import java.util.LinkedHashMap;, +		final Map<RegisterArg, Usage> usageMap = new LinkedHashMap<RegisterArg, Usage>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +						if (accFlags.isPublic()) {, +						}, +	public FieldNode getConstField(Object obj) {, +		return getConstField(obj, true);, +	}, +, +	public FieldNode getConstField(Object obj, boolean searchGlobal) {, +			field = cn.constFields.get(obj);, +		if (field == null && searchGlobal) {, +			field = dex.getConstFields().get(obj);, +		}, +		PrimitiveType type = arg.getType().getPrimitiveType();, +		if (type == null) {, +			return null;, +		}, +		switch (type) {, +			case BOOLEAN:, +				return getConstField(literal == 1, false);, +			case CHAR:]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.zip.ZipException;, +import java.util.zip.ZipFile;, +, +	public static boolean isZipFile(final File file) throws IOException {, +		ZipFile zipFile = null;, +		try {, +			zipFile = new ZipFile(file);, +			return zipFile.entries().hasMoreElements();, +		} catch (ZipException e) {, +			return false;, +		} finally {, +			if (zipFile != null) {, +				try {, +					zipFile.close();, +				} catch (IOException e) {, +					LOG.error(e.getMessage());, +				}, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.zip.ZipException;, +import java.util.zip.ZipFile;, +, +	public static boolean isZipFile(final File file) throws IOException {, +		ZipFile zipFile = null;, +		try {, +			zipFile = new ZipFile(file);, +			return zipFile.entries().hasMoreElements();, +		} catch (ZipException e) {, +			return false;, +		} finally {, +			if (zipFile != null) {, +				try {, +					zipFile.close();, +				} catch (IOException e) {, +					LOG.error(e.getMessage());, +				}, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +		if (FileUtils.isZipFile(file)) {, +			// check if zip contains '.dex' files, +			if (fileName.endsWith(".jar")) {, +			return;, +		}]
[+++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.StandardCopyOption;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.MethodNode;, +	private static final int VERSION = 2;, +	private enum ARG_TYPE {WILDCARD, GENERIC, GENERIC_TYPE, OBJECT, ARRAY, PRIMITIVE}, +, +				cls.load();, +				nClass.setMethods(loadMethods(cls, nClass));, +	private NMethod[] loadMethods(ClassNode cls, NClass nClass) {, +		List<NMethod> methods = new ArrayList<>();, +		for (MethodNode m : cls.getMethods()) {, +			if (!m.getAccessFlags().isPublic(), +					&& !m.getAccessFlags().isProtected()) {, +				continue;, +			}, +, +			List<ArgType> args = new ArrayList<>();, +, +			boolean genericArg = false;, +			for (RegisterArg r: m.getArguments(false)) {, +				ArgType argType = r.getType();, +				if (argType.isGeneric()) {, +					args.add(argType);, +					genericArg = true;, +				} else if (argType.isGenericType()) {, +					args.add(argType);, +					genericArg = true;, +				} else {, +					args.add(null);, +				}, +			}, +, +			ArgType retType = m.getReturnType();, +			if (!retType.isGeneric() && !retType.isGenericType()) {, +				retType = null;, +			}, +, +			boolean varArgs = m.getAccessFlags().isVarArgs();, +, +			if (genericArg || retType != null || varArgs) {, +				methods.add(new NMethod(, +						m.getMethodInfo().getShortId(),, +						args.isEmpty(), +							? new ArgType[0], +							: args.toArray(new ArgType[args.size()]),, +						retType,, +						varArgs));, +			}, +		}, +		return methods.toArray(new NMethod[methods.size()]);, +	}, +, +	void save(Path path) throws IOException {, +		Files.createDirectories(path.getParent());, +		String outputName = path.getFileName().toString();, +			try (BufferedOutputStream outputStream = new BufferedOutputStream(Files.newOutputStream(path))) {, +		} else if (outputName.endsWith(".jar")) {, +			Path temp = Files.createTempFile("jadx", ".zip");, +			Files.copy(path, temp, StandardCopyOption.REPLACE_EXISTING);, +, +			try (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(path));, +					ZipInputStream in = new ZipInputStream(Files.newInputStream(temp))) {, +				String clst = CLST_PKG_PATH + '/' + CLST_FILENAME;, +				out.putNextEntry(new ZipEntry(clst));, +				save(out);, +				ZipEntry entry = in.getNextEntry();, +				while (entry != null) {, +					if (!entry.getName().equals(clst)) {, +						out.putNextEntry(new ZipEntry(entry.getName()));, +						FileUtils.copyStream(in, out);, +					}, +					entry = in.getNextEntry();, +				}, +			}, +			Files.delete(temp);, +, +		DataOutputStream out = new DataOutputStream(output);, +		Map<String, NClass> names = new HashMap<>(classes.length);, +			names.put(cls.getName(), cls);, +			NMethod[] methods = cls.getMethods();, +			out.writeByte(methods.length);, +			for (NMethod method : methods) {, +				writeMethod(out, method, names);, +	private static void writeMethod(DataOutputStream out, NMethod method, Map<String, NClass> names) throws IOException {, +		int argCount = 0;, +		ArgType[] argTypes = method.getArgType();, +		for (ArgType arg : argTypes) {, +			if (arg != null) {, +				argCount++;, +			}, +		}, +, +		writeLongString(out, method.getShortId());, +		out.writeByte(argCount);, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				parentClass = parent == null ? this : parent;, +		return parent == this ? this : parent.getTopParentClass();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +				parentClass = parent == null ? this : parent;, +		return parent == this ? this : parent.getTopParentClass();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, +		long chunkEnd = start + size;, +			long end = stylesStart == 0 ? chunkEnd : start + stylesStart;, +			byte[] strArray = is.readInt8Array((int) (end - is.getPos()));, +				// don't trust specified string length, read until \0, +				// stringsOffset can be same for different indexes, +				strings[i] = extractString16(strArray, stringsOffset[i]);, +		is.skip(chunkEnd - is.getPos());, +	private static String extractString16(byte[] strArray, int offset) {, +		int len = strArray.length;, +		int start = offset + 2;, +		int end = start;, +		while (true) {, +			if (end + 1 >= len) {, +				break;, +			}, +			if (strArray[end] == 0 && strArray[end + 1] == 0) {, +				break;, +			}, +			end += 2;, +		}, +		return new String(strArray, start, end - start, ParserStream.STRING_CHARSET_UTF16);, +	}, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		if (hasNextCall == null || nextCall == null, +				|| !checkInvoke(hasNextCall, "java.util.Iterator", "hasNext()Z", 0), +					if (castArg != null && castArg.getParentInsn() != null) {, +		ArgType iterableType = iterableArg.getType();, +		ArgType varType = iterVar.getType();, +		if (iterableType.isGeneric()) {, +			ArgType[] genericTypes = iterableType.getGenericTypes();, +			if (genericTypes == null || genericTypes.length != 1) {, +				return false;, +			}, +			if (gType.equals(varType)) {, +			if (gType.isGenericType()) {, +				iterVar.setType(gType);, +				return true;, +			if (ArgType.isInstanceOf(gType, varType)) {, +				return true;, +			}, +			LOG.warn("Generic type differs: {} and {}", gType, varType);, +			return false;, +		}, +		iterableType = ArgType.generic(iterableType.getObject(), new ArgType[]{varType});, +		iterableArg.setType(iterableType);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +		if (hasNextCall == null || nextCall == null, +				|| !checkInvoke(hasNextCall, "java.util.Iterator", "hasNext()Z", 0), +					if (castArg != null && castArg.getParentInsn() != null) {, +		ArgType iterableType = iterableArg.getType();, +		ArgType varType = iterVar.getType();, +		if (iterableType.isGeneric()) {, +			ArgType[] genericTypes = iterableType.getGenericTypes();, +			if (genericTypes == null || genericTypes.length != 1) {, +				return false;, +			}, +			if (gType.equals(varType)) {, +			if (gType.isGenericType()) {, +				iterVar.setType(gType);, +				return true;, +			if (ArgType.isInstanceOf(gType, varType)) {, +				return true;, +			}, +			LOG.warn("Generic type differs: {} and {}", gType, varType);, +			return false;, +		}, +		iterableType = ArgType.generic(iterableType.getObject(), new ArgType[]{varType});, +		iterableArg.setType(iterableType);, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIterableForEach3.java, +package jadx.tests.integration.loops;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.Set;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestIterableForEach3 extends IntegrationTest {, +, +	public static class TestCls<T extends String> {, +		private Set<T> a;, +		private Set<T> b;, +, +		private void test(T str) {, +			Set<T> set = str.length() == 1 ? a : b;, +			for (T s : set) {, +				if (s.length() == str.length()) {, +					if (str.length() == 0) {, +						set.remove(s);, +					} else {, +						set.add(str);, +					}, +					return;, +				}, +			}, +		}, +	}, +, +	@Test, +	public void test() {, +		ClassNode cls = getClassNode(TestCls.class);, +		String code = cls.getCode().toString();, +, +		assertThat(code, containsOne("for (T s : set) {"));, +		assertThat(code, containsOne("if (str.length() == 0) {"));, +		// TODO move return outside 'if', +	}, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, +		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, +	private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, +			return;, +		if (!af.isSynthetic()) {, +			return;, +		}, +		if (removeBridgeMethod(cls, mth)) {, +			return;, +		}, +		if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, +		List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, +		if (allInsns.size() == 1) {, +			InsnNode wrappedInsn = allInsns.get(0);, +			if (wrappedInsn.getType() == InsnType.RETURN) {, +				InsnArg arg = wrappedInsn.getArg(0);, +				if (arg.isInsnWrap()) {, +					wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, +				}, +			}, +			if (checkSyntheticWrapper(mth, wrappedInsn)) {, +				return true;, +			}, +		}, +		return !isMethodUnique(cls, mth);, +	}, +, +	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {, +		InsnType insnType = insn.getType();, +		if (insnType == InsnType.INVOKE) {, +			MethodInfo callMth = ((InvokeNode) insn).getCallMth();, +			MethodNode wrappedMth = mth.root().deepResolveMethod(callMth);, +			if (wrappedMth != null) {, +				// all args must be registers passed from method args (allow only casts insns), +				for (InsnArg arg : insn.getArguments()) {, +					if (!registersAndCastsOnly(arg)) {, +						return false;, +					}, +				}, +				String alias = mth.getAlias();, +				if (!wrappedMth.getAlias().equals(alias) && wrappedMth.isVirtual()) {, +					wrappedMth.getMethodInfo().setAlias(alias);, +				}, +				return true;, +			}, +		}, +		return false;, +	}, +, +	private static boolean registersAndCastsOnly(InsnArg arg) {, +		if (arg.isRegister()) {, +			return true;, +		}, +		if (arg.isInsnWrap()) {, +			InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +			if (wrapInsn.getType() == InsnType.CHECK_CAST) {, +				return registersAndCastsOnly(wrapInsn.getArg(0));, +			}, +		}, +		return false;, +	}, +, +	private static boolean isMethodUnique(ClassNode cls, MethodNode mth) {, +	private static void removeEmptyMethods(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +		cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, +		cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, +	private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, +			return;, +		if (!af.isSynthetic()) {, +			return;, +		}, +		if (removeBridgeMethod(cls, mth)) {, +			return;, +		}, +		if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, +	private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, +		List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, +		if (allInsns.size() == 1) {, +			InsnNode wrappedInsn = allInsns.get(0);, +			if (wrappedInsn.getType() == InsnType.RETURN) {, +				InsnArg arg = wrappedInsn.getArg(0);, +				if (arg.isInsnWrap()) {, +					wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, +				}, +			}, +			if (checkSyntheticWrapper(mth, wrappedInsn)) {, +				return true;, +			}, +		}, +		return !isMethodUnique(cls, mth);, +	}, +, +	private static boolean checkSyntheticWrapper(MethodNode mth, InsnNode insn) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, +import jadx.gui.utils.Utils;, +		if ((used + Utils.MIN_FREE_MEMORY) > r.maxMemory()) {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, +import jadx.gui.utils.Utils;, +		if ((used + Utils.MIN_FREE_MEMORY) > r.maxMemory()) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, +	/**, +	 * The minimum about of memory in bytes we are trying to keep free, otherwise the application may run out of heap, +	 * which ends up in a Java garbage collector running "amok" (CPU utilization 100% for each core and the UI is, +	 * not responsive)., +	 *, +	 * We can calculate and store this value here as the maximum heap is fixed for each JVM instance, +	 * and can't be changed at runtime., +	 */, +	public static final long MIN_FREE_MEMORY = calculateMinFreeMemory();, +, +	/**, +	 * @return 20% of the maximum heap size limited to 512 MB (bytes), +	 */, +	public static long calculateMinFreeMemory() {, +		Runtime runtime = Runtime.getRuntime();, +		long minFree = (long) (runtime.maxMemory() * 0.2);, +		minFree = Math.min(minFree, 512 * 1048576);, +		return minFree;, +	}, +, +		long totalFree = runtime.freeMemory() + (maxMemory - runtime.totalMemory());, +		return totalFree > MIN_FREE_MEMORY;]
